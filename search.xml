<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Sun Oct 25 2020 08:00:00 GMT+0800 (中国标准时间)</title>
    <url>/2022/10/25/2020-10-25/</url>
    <content><![CDATA[<p>2020年10月25日过去了，我很怀念它</p>
]]></content>
  </entry>
  <entry>
    <title>01排序</title>
    <url>/2020/10/19/01%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>题目大意：有一个数列 a[1..n]，它是 1~n 这 n
个正整数的一个排列。现在支持两种操作：0, l, r: 将
a[l..r]原地升序排序。1, l, r: 将
a[l..r]原地降序排序。操作完后，给定一个位置 q，输出
a[q]的值。<span id="more"></span></p>
<p>考虑暴力，显然就是对于每一次的操作都进行一边<span
class="math inline">\(O(n\times logn)\)</span>的排序，总复杂度：<span
class="math inline">\(O(n^2\times logn)\)</span></p>
<p>这里就是瓶颈，我们可不可以给他优化成<span
class="math inline">\(logn\)</span>的时间复杂度呢</p>
<p>答案是可以的</p>
<p>再来考虑当我知道一个01序列里面1的个数之后，对一个01串进行排序，显然复杂度就是<span
class="math inline">\(logn\)</span>（线段树区间赋值）</p>
<p>由于这是一个排列，所以序列中每个数都不一样，所以我们来二分答案，二分最后p会变成哪一个数字</p>
<p>然后把大于等于mid的判定为1，小与的判定为0</p>
<p>然后对于每一个操作都是log的修改，最后查询q那个位置是否为1，总复杂度：<span
class="math inline">\((n\times logn^2)\)</span></p>
<p>为什么可以二分？好多人的题解里面写的显然。。。我觉得一点也不显然</p>
<p>首先这个题目我们无法用最大最小值的定义来解释他，但是可以观察发现，这个值域是具有单调性的</p>
<p>比如说，我们二分出来的mid为1，显然当前所有数字都为1，也就意味着说，这个答案合理，我们应该往大于1的范围去找</p>
<p>就是l = mid，反之就是r = mid - 1</p>
<p>补：</p>
<p>来自一位<strong>dalao</strong>(<a
href="https://www.acwing.com/user/myspace/index/31999/">Fighting_Peter</a>)的讲解：答案具有单调性，不妨设现在二分答案是mid，那么进行01串转化后，如果答案最后大于mid那么该位置的数一定是1，如果最后答案小于mid该位置的数一定是0，答案范围是值域，我们现在要求最小的一个值满足在进行01串转化后所求位置的数是1。如果二分答案的值偏小那么该位置一定是1，如果二分答案的值偏大那么该位一定是0。根据上述不同即可一次次缩小范围确定答案。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = p &lt;&lt; <span class="number">1</span>, r = (p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(tree[p].dat = tree[l].dat + tree[r].dat);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (! tree[p].tag) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> l = p &lt;&lt; <span class="number">1</span>, r = (p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>, c = tree[p].tag;</span><br><span class="line">    tree[l].tag = tree[r].tag = c;</span><br><span class="line">    <span class="keyword">if</span> (tree[p].tag == <span class="number">1</span>) tree[l].dat = tree[r].dat = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> tree[l].dat = tree[l].len, tree[r].dat = tree[r].len;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(tree[p].tag = <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[p].len = (r - l + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> (<span class="type">void</span>)(tree[p].dat = (a[l] &gt;= k));</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span>, l, mid, k), <span class="built_in">build</span>((p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>, mid + <span class="number">1</span>, r, k);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(<span class="built_in">up</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">updata</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> nl, <span class="type">int</span> nr, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nl &lt;= l &amp;&amp; nr &gt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[p].tag = k + <span class="number">1</span>;</span><br><span class="line">        tree[p].dat = tree[p].len * k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">down</span>(p);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (nl &lt;= mid) <span class="built_in">updata</span>(p &lt;&lt; <span class="number">1</span>, l, mid, nl, nr, k);</span><br><span class="line">    <span class="keyword">if</span> (nr &gt; mid) <span class="built_in">updata</span>((p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>, mid + <span class="number">1</span>, r, nl, nr, k);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(<span class="built_in">up</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">query</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> tree[p].dat == <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">down</span>(p);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) <span class="keyword">return</span> <span class="built_in">query</span>(p &lt;&lt; <span class="number">1</span>, l, mid, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>((p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>, mid + <span class="number">1</span>, r, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> nl, <span class="type">int</span> nr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nl &lt;= l &amp;&amp; nr &gt;= r) <span class="keyword">return</span> tree[p].dat;</span><br><span class="line">    <span class="built_in">down</span>(p);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, <span class="built_in">res</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (nl &lt;= mid) res = <span class="built_in">query</span>(p &lt;&lt; <span class="number">1</span>, l, mid, nl, nr);</span><br><span class="line">    <span class="keyword">if</span> (nr &gt; mid) res += <span class="built_in">query</span>((p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>, mid + <span class="number">1</span>, r, nl, nr);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;tree, <span class="number">0</span>, <span class="keyword">sizeof</span> tree);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n, k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, le[i], ri[i]);</span><br><span class="line">        <span class="keyword">if</span> (cnt == <span class="number">0</span> || cnt == ri[i] - le[i] + <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (opt[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">updata</span>(<span class="number">1</span>, <span class="number">1</span>, n, le[i], ri[i] - cnt, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">updata</span>(<span class="number">1</span>, <span class="number">1</span>, n, ri[i] - cnt + <span class="number">1</span>, ri[i], <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">updata</span>(<span class="number">1</span>, <span class="number">1</span>, n, le[i], le[i] + cnt - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">updata</span>(<span class="number">1</span>, <span class="number">1</span>, n, le[i] + cnt, ri[i], <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) a[i] = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) opt[i] = <span class="built_in">read</span>(), le[i] = <span class="built_in">read</span>(), ri[i] = <span class="built_in">read</span>();</span><br><span class="line">        q = <span class="built_in">read</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">1</span>, r = n, mid, res;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">pd</span>(mid)) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">put</span>(l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>7.21test</title>
    <url>/2020/07/21/7.21test/</url>
    <content><![CDATA[<p>今天考试了, 考了好几道题 <span id="more"></span> 依次为:</p>
<h3 id="矩阵乘法"><a href="https://loj.ac/problem/100">矩阵乘法</a></h3>
<p>代码: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">502</span>, mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, p, m;</span><br><span class="line"><span class="type">int</span> f1[N][N], f2[N][N];</span><br><span class="line"><span class="type">int</span> f3[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">work</span> <span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">   <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= p; ++ i) &#123;</span><br><span class="line">      res += (f1[x][i]*f2[i][y])%mod;</span><br><span class="line">      res %= mod;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (res &gt;= <span class="number">0</span>) <span class="keyword">return</span> res%mod;</span><br><span class="line">   <span class="keyword">if</span> (res &lt; <span class="number">0</span>) <span class="keyword">return</span> (res+mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">main</span> () &#123;</span><br><span class="line">   cin &gt;&gt; n &gt;&gt; p &gt;&gt; m;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= p; ++ j)</span><br><span class="line">         cin &gt;&gt; f1[i][j];</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= p; ++ i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line">	 cin &gt;&gt; f2[i][j];</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line">	 f3[i][j] = <span class="built_in">work</span>(i, j);</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line">         cout &lt;&lt; f3[i][j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">      cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
其实这个题特别水，就是没有学过矩阵乘法的人都能做对
说白了就是个模拟，需要注意<span class="math inline">\(long
long\)</span>，还有<span
class="math inline">\(res\)</span>要边算边模，并且还要判负数</p>
<p>但是我考试的时候，没开<span class="math inline">\(longlong\)</span>,
<span class="math inline">\(res\)</span>没有中途取模</p>
<p>就是<span class="math inline">\(zero\)</span>了....</p>
<h3 id="大炮"><a href="https://loj.ac/problem/2038">大炮</a></h3>
<p>代码: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 2333</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">6e6</span>;</span><br><span class="line"><span class="type">int</span> n, k, T;</span><br><span class="line"><span class="type">int</span> js[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">ksm</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>%mod;</span><br><span class="line">   <span class="keyword">if</span> (b&amp;<span class="number">1</span>) <span class="keyword">return</span> a*<span class="built_in">ksm</span>(a, b<span class="number">-1</span>)%mod;</span><br><span class="line">   <span class="type">int</span> tmp = <span class="built_in">ksm</span>(a, b/<span class="number">2</span>)%mod;</span><br><span class="line">   <span class="keyword">return</span> tmp*tmp%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">C</span> <span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (m &gt; n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">return</span> (js[n]*<span class="built_in">ksm</span>(js[m],mod<span class="number">-2</span>))%mod*<span class="built_in">ksm</span>(js[n-m], mod<span class="number">-2</span>)%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lucas</span> <span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (!m) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">C</span> (n%mod, m%mod)*<span class="built_in">lucas</span>(n/mod, m/mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">   <span class="type">int</span> res = <span class="number">0</span>, t = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">      t = <span class="built_in">lucas</span>(n, i)%mod;</span><br><span class="line">      res += t;</span><br><span class="line">      res %= mod;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> res%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   cin &gt;&gt; T;</span><br><span class="line">   <span class="keyword">while</span> (T-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">      js[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= mod; ++i)</span><br><span class="line">         js[i] = (js[i - <span class="number">1</span>] * i) % mod;</span><br><span class="line">	 cout &lt;&lt; <span class="built_in">calc</span>(n, k) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这就是一个**数学题，要推式子，但是我不会，看出来是个Lucas但是不会写</p>
<p>这个数据比较**正好卡我百分之五十的数据，也就是说，不动脑子，敲Lucas板子的话，可以拿到百分之五十的数据</p>
<p>但是我就是不会推 也不想去推</p>
<p>这种操蛋数学题，正如郑好学长所言，爱练不练的，考的几率没准，简单的大家都会，难的大家都不会</p>
<h3 id="第三题">第三题</h3>
<p><span class="math inline">\(Description\)</span></p>
<p>桌面上有R张红牌和B张黑牌，随机打乱顺序后放在桌面上，开始一张一张地翻牌，翻到红牌得到1美元，黑牌则付出1美元。可以随时停止翻牌，在最优策略下平均能得到多少钱。</p>
<p><span class="math inline">\(Input\)</span></p>
<p>一行输入两个数R,B,其值在0到5000之间</p>
<p><span class="math inline">\(Output\)</span></p>
<p>在最优策略下平均能得到多少钱</p>
<p><span class="math inline">\(Sample\)</span> <span
class="math inline">\(Input\)</span></p>
<p>5 1</p>
<p><span class="math inline">\(Sample\)</span> <span
class="math inline">\(Output\)</span></p>
<p>4.166666</p>
<p><span class="math inline">\(HINT\)</span></p>
<p>输出答案时,小数点后第六位后的全部去掉,<strong>不要四舍五入</strong>.</p>
<p>代码: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> R, B, res;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> nows;</span><br><span class="line"><span class="type">double</span> f[<span class="number">6</span>][<span class="number">6666</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   cin &gt;&gt; R &gt;&gt; B;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= R; ++ i, nows ^=<span class="number">1</span>, f[nows][<span class="number">0</span>] = i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= B; ++ j) </span><br><span class="line">	 f[nows][j] = <span class="built_in">max</span>(<span class="number">0</span>*<span class="number">1.0</span>, </span><br><span class="line">	              <span class="number">1.0</span> * i/(i + j)*(f[nows ^ <span class="number">1</span>][j]+<span class="number">1</span>)</span><br><span class="line">		      + <span class="number">1.0</span> * j/(i + j)*(f[nows][j - <span class="number">1</span>]<span class="number">-1</span>));</span><br><span class="line">   res = f[nows^<span class="number">1</span>][(<span class="type">int</span>)B];</span><br><span class="line">   <span class="type">long</span> <span class="type">long</span> z = res*<span class="number">10000000</span>;</span><br><span class="line">   <span class="type">long</span> <span class="type">long</span> k = z%<span class="number">10</span>;</span><br><span class="line">   z -= k;</span><br><span class="line">   <span class="type">double</span> ans = (<span class="type">double</span>)z/<span class="number">10000000</span>;</span><br><span class="line">   <span class="built_in">printf</span> (<span class="string">&quot;%.6lf&quot;</span>, ans);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> 这是一道期望dp</p>
<p><span class="math inline">\(f[i][j]\)</span>表示选<span
class="math inline">\(i\)</span>张红的<span
class="math inline">\(j\)</span>张黑色的答案</p>
<p>卡内存所以需要滚动数组</p>
<p><span class="math inline">\(f[i][j]\)</span> = <span
class="math inline">\(max\)</span>(<span
class="math inline">\(0,\dfrac{i}{i*j}*(f[i-1][j]+1)+\dfrac{j}{i*j}*(f[i][j-1]-1))\)</span></p>
<h3 id="奶牛去搬砖"><a
href="https://www.luogu.com.cn/problem/P4644">奶牛去搬砖</a></h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">66</span>, INF = <span class="number">214748364</span>;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt;,greater&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt; &gt;q;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span> &#123;<span class="type">int</span> to, nxt, val;&#125;e[N]; <span class="type">int</span> cnt, head[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, S, E;</span><br><span class="line"><span class="type">int</span> dis[N], tag[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span> <span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">   e[++cnt].nxt = head[u]; head[u] = cnt;</span><br><span class="line">   e[cnt].to = v;</span><br><span class="line">   e[cnt].val = w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dij</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = S; i &lt;= E+<span class="number">6</span>; ++ i) dis[i] = INF;</span><br><span class="line">      dis[S] = <span class="number">0</span>, q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>, S));</span><br><span class="line">      <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">	 <span class="type">int</span> x = q.<span class="built_in">top</span>().second; q.<span class="built_in">pop</span>();</span><br><span class="line">	 <span class="keyword">if</span> (tag[x]) <span class="keyword">continue</span>; tag[x] = <span class="number">1</span>;</span><br><span class="line">	    <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = e[i].nxt) &#123;</span><br><span class="line">	       <span class="type">int</span> y = e[i].to;</span><br><span class="line">	       <span class="keyword">if</span> (dis[y] &gt; dis[x]+e[i].val)&#123;</span><br><span class="line">		  dis[y] = dis[x]+e[i].val, dis[y];</span><br><span class="line">		  q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(dis[y], y));</span><br><span class="line">	       &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">   cin &gt;&gt; n &gt;&gt; S &gt;&gt; E;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = S; i &lt;= E; ++ i) <span class="built_in">add</span>(i+<span class="number">1</span>, i, <span class="number">0</span>);</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">      <span class="type">int</span> u, v, w;</span><br><span class="line">      cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">      <span class="keyword">if</span> (u &lt; S) u = S;</span><br><span class="line">      <span class="keyword">if</span> (v &gt; E) v = E;</span><br><span class="line">      <span class="built_in">add</span>(u, v+<span class="number">1</span>, w);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">dij</span>();</span><br><span class="line">   <span class="keyword">if</span> (dis[E+<span class="number">1</span>] == INF) <span class="built_in">puts</span> (<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">   <span class="keyword">else</span> cout &lt;&lt; dis[E+<span class="number">1</span>];</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>建个图，跑一跑，完事。可是考试时候的我，连题目都没看懂什么意思（英文题面，
教练给翻译了，但是感觉那个翻译看起来很不爽，索性没有做）</p>
<p>但是这个题真的很简单，就是需要一步很巧妙的回退思想 <span
class="math inline">\(add(i+1, i,
0)\)</span>:建一条权值为零的回退的边</p>
<p>1 3</p>
<p>4 5</p>
<p>虽然没有交集，但是上述情况是可以满足题意的</p>
<p>所以建边的时候要<span class="math inline">\(add(u,v+1,w)\)</span></p>
<h3 id="单位错选"><a
href="https://www.luogu.com.cn/problem/P1297">单位错选</a></h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e7</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, A, B, C, tmp;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d&quot;</span>, &amp;n, &amp;A, &amp;B, &amp;C, a + <span class="number">1</span>);</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">      a[i] = ((<span class="type">long</span> <span class="type">long</span>) a[i - <span class="number">1</span>] * A + B) % <span class="number">100000001</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">      a[i] = a[i] % C + <span class="number">1</span>;</span><br><span class="line">   res += <span class="number">1.0</span>*<span class="built_in">min</span>(a[<span class="number">1</span>], a[n])/a[<span class="number">1</span>]/a[n];</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++ i) res += <span class="number">1.0</span>*<span class="built_in">min</span>(a[i], a[i + <span class="number">1</span>])/a[i]/a[i + <span class="number">1</span>];</span><br><span class="line">   <span class="built_in">printf</span> (<span class="string">&quot;%.3lf&quot;</span>, res);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设第<span class="math inline">\(i\)</span>个题目的选项数是<span
class="math inline">\(a[i]\)</span>,那么<span
class="math inline">\(gx\)</span>做对这道题目的概率就是<span
class="math inline">\(\dfrac{min(a[i],a[i-1])}{a[i]*a[j]}\)</span></p>
<p><span class="math inline">\(i == 1\)</span>的时候特判
然后把每个题做对的概率加起来就好了</p>
<p>其实说实话，我还是感觉不太理解 也说不出来哪里不明白</p>
<p>可能是初次接触概率的题吧，这是个锅，以后得补上</p>
<h3 id="互相伤害"><a
href="https://www.luogu.com.cn/problem/P1896">互相伤害</a></h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">666</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> f[<span class="number">10</span>][N][N], res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">self</span> <span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> ((x&amp;(x&lt;&lt;<span class="number">1</span>)) || (x&amp;(x&gt;&gt;<span class="number">1</span>))) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Double</span> <span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> ((x&amp;(y&lt;&lt;<span class="number">1</span>)) || (x&amp;(y&gt;&gt;<span class="number">1</span>) || (x&amp;y))) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">work</span> <span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="type">int</span> <span class="title">nows</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">   <span class="keyword">while</span> (x) &#123;<span class="keyword">if</span> (x&amp;<span class="number">1</span>) ++ nows; x &gt;&gt;= <span class="number">1</span>;&#125;</span><br><span class="line">   <span class="keyword">return</span> nows;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">scanf</span> (<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">   f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span>&lt;&lt;n); ++ j) &#123;</span><br><span class="line">         <span class="keyword">if</span> (<span class="built_in">self</span> (j)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> z = <span class="number">0</span>; z &lt; (<span class="number">1</span>&lt;&lt;n); ++ z) &#123;</span><br><span class="line">	       <span class="keyword">if</span> (<span class="built_in">self</span>(z) &amp;&amp; <span class="built_in">Double</span>(z, j)) &#123;</span><br><span class="line">		  <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">0</span>; len &lt;= k; ++ len) &#123;</span><br><span class="line">		      <span class="type">int</span> nx = <span class="built_in">work</span>(j), ny = <span class="built_in">work</span>(z);</span><br><span class="line">		      <span class="keyword">if</span> (nx+ny&gt;len) <span class="keyword">continue</span>;</span><br><span class="line">		      f[i][j][len] += f[i<span class="number">-1</span>][z][len-nx];</span><br><span class="line">		  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span>&lt;&lt;n); ++ i) res += f[n][i][k];</span><br><span class="line">   cout &lt;&lt; res;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>状压dp</p>
<p><span
class="math inline">\(f[i][j][k]\)</span>表示我们当前摆放棋子摆到了第<span
class="math inline">\(i\)</span>行的时候（包括前<span
class="math inline">\(i\)</span>行）当前第<span
class="math inline">\(i\)</span>行的状态为<span
class="math inline">\(j\)</span>，并且一共用了<span
class="math inline">\(k\)</span>个国王所呈现出的方案数</p>
<p>又因为i行之前的状态方案数都是互不影响的，所以说，是“或”的关系，根据加法原理，可以直接相加</p>
<p>所以转移方程可以写出来:</p>
<p><span class="math inline">\(f[i][j][k] +=
f[i-1][z][k-Work(j)]\)</span></p>
<p>自此所有题目分析完毕</p>
<hr />
<p><span class="math inline">\(7.28update\)</span></p>
<p>关于第二题大炮，看了看题解，还是不会推</p>
<p>给出ac代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// da pao</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e3</span>, p = <span class="number">2333</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, T;</span><br><span class="line"><span class="type">int</span> c[N][N], f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Lucas</span> <span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (!m || n == m) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">if</span> (n &lt; m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">Lucas</span>(n/p, m/p)*c[n%p][m%p]%p;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">calc</span> <span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (m == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">if</span> (!m) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">if</span> (n &lt; p) <span class="keyword">return</span> f[n][m];</span><br><span class="line">   <span class="keyword">return</span> (f[n%p][n%p]*<span class="built_in">calc</span>(n/p,m/p<span class="number">-1</span>)+<span class="built_in">Lucas</span>(n/p,m/p)*f[n%p][<span class="built_in">min</span>(n%p, m%p)])%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">yuchuli</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   c[<span class="number">0</span>][<span class="number">0</span>] = f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= p; ++ i) &#123;</span><br><span class="line">      f[i][<span class="number">0</span>] = c[i][<span class="number">0</span>] = c[i][i] = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i<span class="number">-1</span>; ++ j)</span><br><span class="line">	 c[i][j] = (c[i - <span class="number">1</span>][j] + c[i - <span class="number">1</span>][j - <span class="number">1</span>])%p;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= p; ++ j)</span><br><span class="line">	 f[i][j] = (f[i][j - <span class="number">1</span>] + c[i][j])%p;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;	</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">caozuoyixia</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">scanf</span> (<span class="string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">   cout &lt;&lt; <span class="built_in">calc</span>(n, m) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;	</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">yuchuli</span>();</span><br><span class="line">   cin &gt;&gt; T;</span><br><span class="line">   <span class="keyword">while</span> (T --&gt; <span class="number">0</span>) <span class="built_in">caozuoyixia</span>();</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>暑假日常</category>
      </categories>
      <tags>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title>7.23集训</title>
    <url>/2020/07/23/7.23%E9%9B%86%E8%AE%AD/</url>
    <content><![CDATA[<h1 id="上午">上午</h1>
<p>考试了 <span id="more"></span> <span
class="math inline">\(rank\)</span>再次倒数</p>
<h1 id="下午">下午</h1>
<p><strong>讲了一些关于矩阵乘法的东西</strong></p>
<p><a href="https://www.luogu.com.cn/problem/P3216">数学作业</a></p>
<p><span class="math inline">\(n \leq
1e18\)</span>一看数据范围，一点都不大，才<span
class="math inline">\(1e18\)</span>嘛</p>
<p>直接搞矩阵！</p>
<p><img
src="https://cdn.luogu.com.cn/upload/image_hosting/43do7ss7.png" /></p>
<p>其实说实话这题我还是不太熟悉</p>
<p>先埋下一个坑 日后补上</p>
<p><a href="https://www.luogu.com.cn/problem/P2579">大鳄鱼</a></p>
<p>对于这个题，我们首先简化问题，假如底下没有鳄鱼，问题就可以转化为，给你<span
class="math inline">\(n\)</span>个点，<span
class="math inline">\(m\)</span>条边，起点和终点，问你有多少种方案通过恰好走<span
class="math inline">\(k\)</span>步可以到达终点</p>
<p>其中<span class="math inline">\(n \leq 100, k \leq 1e18\)</span></p>
<p>乍一看像最短路问题，但是邻接矩阵的思想，我们可以搞一个矩阵，<span
class="math inline">\(ta\)</span>自乘两次，意为着走了两步</p>
<p><sub>关于这个前进的问题，我还是不很清晰，等以后做矩阵乘法的题的时候，再来补上这个坑</sub></p>
<p>关于鳄鱼的话，通过观察发现，鳄鱼的周期只有<span
class="math inline">\(2,3,4\)</span>所以我们可以找出他们的公倍数<span
class="math inline">\(12\)</span>来</p>
<p><strong>还讲了一些计数问题的dp</strong></p>
<p>第一二类斯特林数</p>
<p>组合数</p>
<p>环形染色</p>
<p>不相邻染色</p>
<p>其实我真的没有听懂多少关于计数问题dp的东西，我连斯特林数这样的计数问题都搞不明白，更别提在计数问题上再进行动规了</p>
<h1 id="晚上">晚上</h1>
<p>改上午考试的题</p>
<p>分别为:</p>
<h4 id="第一题">第一题</h4>
<p><span class="math inline">\(Description\)</span> <span
class="math inline">\(WJQ\)</span>发现这是一个<span
class="math inline">\(n\)</span>行的数塔，第<span
class="math inline">\(n\)</span>行有<span
class="math inline">\(n\)</span>个数。最后一行依次为<span
class="math inline">\(1,2,3...n\)</span>，第<span
class="math inline">\(i\)</span>行的第<span
class="math inline">\(j\)</span>个数等于第<span
class="math inline">\(i+1\)</span>行第<span
class="math inline">\(j\)</span>个数和第<span
class="math inline">\(j+1\)</span>个数的和。他觉得塔顶可能有宝贝，但是太高了他看不见。于是它请你帮忙算算塔顶的数字是多少。</p>
<p><span class="math inline">\(Input\)</span></p>
<p>一行一个数字<span
class="math inline">\(T\)</span>表示数据组数接下来<span
class="math inline">\(T\)</span>行，每行一个数字，表示<span
class="math inline">\(n\)</span>。</p>
<p><span class="math inline">\(Output\)</span></p>
<p>输出<span
class="math inline">\(T\)</span>行，每行一个数字表示答案。由于答案可能过大，又考虑到各位选手可能对高精充满抵触，因此我们的答案对<span
class="math inline">\(998244353\)</span>取模</p>
<p><span class="math inline">\(Sample Input\)</span></p>
<p>2</p>
<p>2</p>
<p>4</p>
<p><span class="math inline">\(Sample Output\)</span></p>
<p>3</p>
<p>20</p>
<p><span class="math inline">\(HINT\)</span></p>
<p><span class="math inline">\(30%\)</span>的数据，<span
class="math inline">\(n \leq 100\)</span> ,<span class="math inline">\(T
\leq 10\)</span></p>
<p><span class="math inline">\(50%\)</span>的数据，<span
class="math inline">\(n \leq 10000\)</span></p>
<p><span class="math inline">\(100%\)</span>的数据，<span
class="math inline">\(n &lt; 1e18\)</span>，<span
class="math inline">\(T \leq 1000\)</span></p>
<hr />
<p>对于这道题吧，假设<span class="math inline">\(T\)</span>只为<span
class="math inline">\(1\)</span>，那就是很好做的模拟题，又看到<span
class="math inline">\(n\)</span>比较大</p>
<p>我们考虑滚动数组...然后<span
class="math inline">\(3min\)</span>写出来了....自我感觉良好，感觉自己貌似很<span
class="math inline">\(nb\)</span>，轻松打暴力能得<span
class="math inline">\(50pts\)</span>.</p>
<p>于是开始信心十足的开始推式子找规律</p>
<p>...</p>
<p>经过一番操作找出来了，写上，交！ <span
class="math inline">\(30pts\)</span>....我tm暴力都能得<span
class="math inline">\(50pts\)</span>呢！我自认为的正解才他娘的<span
class="math inline">\(30pts\)</span>?</p>
<p>就很不舒服嘛....</p>
<p>下面说一说关于这道题，我是怎么推的式子吧</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">48</span></span><br><span class="line"><span class="number">20</span> <span class="number">28</span></span><br><span class="line"><span class="number">8</span> <span class="number">12</span> <span class="number">16</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">7</span> <span class="number">9</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>我们设最左边一列为<span
class="math inline">\(f\)</span>数组，紧靠着<span
class="math inline">\(f\)</span>数组那一列为<span
class="math inline">\(g\)</span>数组</p>
<p>显然 我们的答案就是<span
class="math inline">\(f\)</span>数组，紧接着开始打表找规律</p>
<p><span class="math inline">\(f[1] = 1, g[1] = 2\)</span> <span
class="math inline">\(f[2] = 3, g[2] = 5\)</span> <span
class="math inline">\(f[3] = 8, g[3] = 12\)</span> <span
class="math inline">\(...\)</span></p>
<p>可以观察到，<span class="math inline">\(f[n] =
f[n-1]+g[n-1]\)</span>。但是<span
class="math inline">\(g\)</span>数组怎么求？我们考虑像求<span
class="math inline">\(f\)</span>数组一样，从下往上转移，但是寻寻觅觅发现终究没有办法。于是开始观察<span
class="math inline">\(g\)</span>数组的周围</p>
<p>...</p>
<p>观察发现<span class="math inline">\(f\)</span>数组貌似与<span
class="math inline">\(g\)</span>数组有些关系</p>
<p><span class="math inline">\(g[1] - f[1] = 2 - 1 = 1 =
2^0\)</span></p>
<p><span class="math inline">\(g[2] - f[2] = 5 - 3 = 2 =
2^1\)</span></p>
<p><span class="math inline">\(g[3] - f[3] = 12 - 8 = 4 =
2^2\)</span></p>
<p><span class="math inline">\(...\)</span></p>
<p>得出结论：</p>
<p><span class="math inline">\(f[n] = f[n-1] + g[n-1]\)</span></p>
<p><span class="math inline">\(f[n] = f[n-1] + f[n-1] +
2^{n-2}\)</span></p>
<p><span class="math inline">\(f[n] = 2*f[n-1] + 2^{n-2}\)</span></p>
<p>然后通过递归函数与快速幂就可以做了，在<span class="math inline">\(n
\leq 10000\)</span> 以内贼快</p>
<p><strong>上面就是我三十分代码的原因...</strong>！！！</p>
<p>考完试之后，在讲题的过程中，我意识到我距离正确答案只差一步</p>
<p>其实我们可以再往下推一步，我们令这个式子左右两边同时除以<span
class="math inline">\(2^n\)</span></p>
<p>魔改过程:</p>
<p><span class="math inline">\(\dfrac {f[n]} {2^n} = \dfrac {2*f[n-1]}
{2^n} + \dfrac {2^{n-2}} {2^n}\)</span></p>
<p><span class="math inline">\(\dfrac {f[n]} {2^n} = \dfrac {f[n-1]}
{2^{n-1}} + \dfrac {1} {4}\)</span></p>
<p>我们设<span class="math inline">\(a_n = \dfrac {f[n]}
{2^n}\)</span>，故<span class="math inline">\(a_1 = \dfrac {f[1]} {2^1}
= \dfrac 1 2\)</span></p>
<p>故原来的式子可以继续魔改:</p>
<p><span class="math inline">\(a_n = a_{n-1} + \dfrac 1 4\)</span></p>
<p><span class="math inline">\(a_n = a_1 + (n-1)* \dfrac 1
4\)</span></p>
<p>算到这一步之后，于是我们开开心心的去写代码，却发现系统提示你<span
class="math inline">\(double\)</span>类型不能去模</p>
<p>因此我们还要继续改，直到没有分数为止</p>
<p><span class="math inline">\(4*a_n = 4*a_1 + (n-1)\)</span></p>
<p><span class="math inline">\(4*a_n = 4*\dfrac 1 2+n-1 =
n+1\)</span></p>
<p><span class="math inline">\(a_n = \dfrac {n+1} 4\)</span></p>
<p>又因为<span class="math inline">\(a_n = \dfrac {f[n]}
{2^n}\)</span></p>
<p><span class="math inline">\(f[n] = \dfrac {n+1} 4 * 2^n\)</span></p>
<p><span class="math inline">\(f[n] = (n+1)*2^{n-2}\)</span></p>
<p>于是我们历经千难万险 终于搞出来一个正常的式子，然后就可以<span
class="math inline">\(AC\)</span>了（注意特判<span
class="math inline">\(n\)</span>为<span
class="math inline">\(1\)</span>的情况）</p>
<p>时间复杂度为<span class="math inline">\(log_n\)</span></p>
<p>给出代码: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> LL mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line">LL T, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">ksm</span> <span class="params">(LL a, LL b)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>%mod;</span><br><span class="line">   <span class="keyword">if</span> (b&amp;<span class="number">1</span>) <span class="keyword">return</span> a*<span class="built_in">ksm</span>(a,b<span class="number">-1</span>)%mod;</span><br><span class="line">   LL tmp = <span class="built_in">ksm</span>(a,b/<span class="number">2</span>)%mod;</span><br><span class="line">   <span class="keyword">return</span> tmp*tmp%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">scanf</span> (<span class="string">&quot;%lld&quot;</span>, &amp;T);</span><br><span class="line">   <span class="keyword">while</span> (T --&gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">scanf</span> (<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">      <span class="keyword">if</span>(n == <span class="number">1</span>) cout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">      <span class="keyword">else</span> cout &lt;&lt; (n+<span class="number">1</span>)%mod*<span class="built_in">ksm</span>(<span class="number">2</span>, n<span class="number">-2</span>)%mod &lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="第二题">第二题</h4>
<p><a href="https://www.luogu.com.cn/problem/P2652">同花顺</a></p>
<p><a
href="https://www.luogu.com.cn/record/list?pid=P2652&amp;user=247889">cpp</a></p>
<p>这题他娘的...某谷数据太水...</p>
<p>说说整体思想吧:</p>
<p>首先我们可以想到，如果确定了一张牌作为某同花顺的结尾，那么整个同花顺是确定的</p>
<p>其次，如果有n张牌，那么最终组成的同花顺一定有n张，另外，对于两张完全相同的牌，一定会更换至少一张</p>
<p>有了以上结论，思路就显而易见了</p>
<p>首先将所有的牌按照花色分开，去重，排序，然后对于相同的花色，用一个队列去维护以每一张牌作结尾时能在序列中的所有牌（即维护首尾指针）</p>
<p>然后统计出这些牌的数量，取较大值，答案就是牌的总数与这个值得差值</p>
<p><del>其实我也不太明白这个过程...以后要补上这个锅</del></p>
<h4 id="第三题">第三题</h4>
<p><a href="https://www.luogu.com.cn/problem/P2824">恶心题</a></p>
<p>正解是他娘的珂朵莉树套<span class="math inline">\(01Trie\)</span>
老子不会</p>
<p>打个暴力吸口氧就80分</p>
<p>这还是道省选题，省选自带吸氧，多少感觉这道题作为省选题不太合适</p>
]]></content>
      <categories>
        <category>暑假日常</category>
      </categories>
      <tags>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title>7.12test</title>
    <url>/2020/07/12/7.12test/</url>
    <content><![CDATA[<p>There is three topics <span id="more"></span> first is <a
href="https://www.luogu.com.cn/problem/P1034">square</a></p>
<p>the topic is a <span class="math inline">\(dfs\)</span></p>
<p>we search the any point into any square</p>
<p>the 'in' function is to judge the point whether in the square(we had
celect)</p>
<p><strong>(we search the aim is point, so if the point over the 'n' we
need return rather than over the 'm')</strong></p>
<p>the code is follow <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// square</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, ans = <span class="number">2147483647</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;<span class="type">int</span> x, y;&#125; a[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">mtrx</span> &#123;<span class="type">int</span> l, r, u, d; <span class="type">bool</span> flag;&#125; p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">in</span> <span class="params">(mtrx dy, <span class="type">int</span> one, <span class="type">int</span> two)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (dy.l &lt;= one &amp;&amp; dy.r &gt;= one &amp;&amp;</span><br><span class="line">      dy.d &lt;= two &amp;&amp; dy.u &gt;= two)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">pd</span> <span class="params">(mtrx s, mtrx t)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">in</span>(s, t.l, t.u)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">in</span>(s, t.l, t.d)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">in</span>(s, t.r, t.u)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">in</span>(s, t.r, t.d)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span> <span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="type">int</span> <span class="title">nows</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)&#123;</span><br><span class="line">       <span class="keyword">if</span> (p[i].flag) </span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> j = i+<span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line">             <span class="keyword">if</span> (p[j].flag &amp;&amp; <span class="built_in">pd</span>(p[i], p[j])) </span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">       nows += (p[i].r-p[i].l)*(p[i].u-p[i].d);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (nows &gt;= ans) <span class="keyword">return</span>;</span><br><span class="line">   <span class="keyword">if</span> (num &gt; n) &#123;</span><br><span class="line">      ans = nows;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">      mtrx tmp = p[i];</span><br><span class="line">      <span class="keyword">if</span> (p[i].flag == <span class="number">0</span>) &#123;</span><br><span class="line">         p[i].flag = <span class="number">1</span>;</span><br><span class="line">         p[i].l = p[i].r = a[num].x;</span><br><span class="line">         p[i].u = p[i].d = a[num].y;</span><br><span class="line">         <span class="built_in">dfs</span> (num+<span class="number">1</span>);</span><br><span class="line">         p[i] = tmp;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         p[i].l = <span class="built_in">min</span> (p[i].l, a[num].x);</span><br><span class="line">         p[i].r = <span class="built_in">max</span> (p[i].r, a[num].x);</span><br><span class="line">         p[i].u = <span class="built_in">max</span> (p[i].u, a[num].y);</span><br><span class="line">         p[i].d = <span class="built_in">min</span> (p[i].d, a[num].y);</span><br><span class="line">         <span class="built_in">dfs</span> (num+<span class="number">1</span>);</span><br><span class="line">         p[i] = tmp;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">main</span> () &#123;</span><br><span class="line">   cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cin &gt;&gt; a[i].x &gt;&gt; a[i].y;</span><br><span class="line">   <span class="built_in">dfs</span> (<span class="number">1</span>);</span><br><span class="line">   cout &lt;&lt; ans;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4 2</span></span><br><span class="line"><span class="comment">1 1</span></span><br><span class="line"><span class="comment">2 2</span></span><br><span class="line"><span class="comment">3 6</span></span><br><span class="line"><span class="comment">0 7</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<p>second is <a href="https://www.luogu.com.cn/problem/P2926">pat
cows</a></p>
<p>1.sieve</p>
<p>2.violence</p>
<p>the code is follow <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">						</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>, N_y = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, dx;</span><br><span class="line"><span class="type">int</span> a[N], v[N_y], ans[N_y];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">      <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">      ++ v[a[i]];</span><br><span class="line">      dx = <span class="built_in">max</span> (dx, a[i]);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= dx; ++ i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (v[i])</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= dx; j += i)</span><br><span class="line">	 ans[j] += v[i];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cout &lt;&lt; ans[a[i]]<span class="number">-1</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>third is <a href="https://www.luogu.com.cn/problem/P2470">zip</a></p>
<h4 id="ps">PS:</h4>
<p>1.pd function 'res' must zero</p>
<p>2.from <strong>l</strong> to <strong>r</strong></p>
<p>We will have two happening</p>
<p>one is the block have the M</p>
<p>the other is don't have</p>
<p>we delimit the 'have M' is <span
class="math inline">\(f[i][j][1]\)</span></p>
<p>the other is <span class="math inline">\(f[i][j][0]\)</span></p>
<p>the <span class="math inline">\(f[i][j][0]\)</span> is more easy</p>
<h4 id="before-we-to-do-state">before we to do state</h4>
<p>we should list all of the state(double num). of coures we need pd</p>
<h4 id="and-then....">and then....</h4>
<p>we find a 'k' to apply the epuation</p>
<p>the equation is</p>
<p><span class="math inline">\(f[i][j][0] = min(f[i][j][0],
f[i][k][0]+j-k)\)</span></p>
<p>for the <span class="math inline">\(f[i][j][1]\)</span></p>
<p>compared with the <span class="math inline">\(f[i][j][0]\)</span> is
more difficlt</p>
<p>we can make the all block (i-&gt;j) into two block i-&gt;k, and
k-&gt;j</p>
<p>and the epuation is</p>
<p><span class="math inline">\(the first = min(f[i][k][1],
f[i][k][0])\)</span></p>
<p><span class="math inline">\(the second = min(f[k+1][j][1],
f[k+1[j][0])\)</span></p>
<p><span class="math inline">\(f[i][j][1] = min (f[i][j][1], thefirst +
thesecond + 1)\)</span></p>
<p>(+ 1):because we must put a 'M' on the k</p>
<p>the code is follow <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// zip</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N][N][<span class="number">6</span>];</span><br><span class="line"><span class="type">char</span> ch[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">pd</span> <span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (t-s+<span class="number">1</span>), <span class="built_in">res</span>(<span class="number">0</span>), jz;</span><br><span class="line">    <span class="keyword">if</span> (k&amp;<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    jz = (t+s+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>; k &gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (ch[s+i] == ch[jz+i])</span><br><span class="line">            ++ res;</span><br><span class="line">    <span class="keyword">return</span> res == k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">main</span> () &#123;</span><br><span class="line">   <span class="built_in">scanf</span> (<span class="string">&quot;%s&quot;</span>, ch+<span class="number">1</span>);</span><br><span class="line">   <span class="type">int</span> n = <span class="built_in">strlen</span>(ch+<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">         f[i][j][<span class="number">0</span>] = f[i][j][<span class="number">1</span>] = (j-i+<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; ++ len) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n-len+<span class="number">1</span>; ++ i) &#123;</span><br><span class="line">         <span class="type">int</span> j = i+len<span class="number">-1</span>;</span><br><span class="line">         <span class="keyword">if</span> (<span class="built_in">pd</span>(i, j)) &#123;</span><br><span class="line">            <span class="type">int</span> m = (i+j)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            f[i][j][<span class="number">0</span>] = <span class="built_in">min</span> (f[i][j][<span class="number">0</span>], f[i][m][<span class="number">0</span>]+<span class="number">1</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= j<span class="number">-1</span>; ++ k)</span><br><span class="line">            f[i][j][<span class="number">0</span>] = <span class="built_in">min</span> (f[i][j][<span class="number">0</span>], f[i][k][<span class="number">0</span>]+j-k);</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= j<span class="number">-1</span>; ++ k)</span><br><span class="line">            f[i][j][<span class="number">1</span>] = <span class="built_in">min</span> (f[i][j][<span class="number">1</span>],</span><br><span class="line">                         <span class="built_in">min</span> (f[i][k][<span class="number">0</span>], f[i][k][<span class="number">1</span>])+</span><br><span class="line">                         <span class="built_in">min</span> (f[k+<span class="number">1</span>][j][<span class="number">0</span>], f[k+<span class="number">1</span>][j][<span class="number">1</span>])+<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   cout &lt;&lt; <span class="built_in">min</span> (f[<span class="number">1</span>][n][<span class="number">0</span>], f[<span class="number">1</span>][n][<span class="number">1</span>]);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <span
class="math inline">\(7.14update\)</span> ### PS 1.pd funcition k or m
must not '&gt;&gt;=1'</p>
<p>because if the num first is a even</p>
<p>after the '&gt;&gt;=1' the num maybe an odd</p>
<p>so we must before the '&gt;&gt;=1' to check the even or odd</p>
<p>2.initialization we must let the <span class="math inline">\(i and
j\)</span> 'for' from 1</p>
<p>3.when we search the 'k'</p>
<p><strong>the 'k' is from 1 to j-1</strong></p>
]]></content>
      <categories>
        <category>暑假日常</category>
      </categories>
      <tags>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title>7.25集训</title>
    <url>/2020/07/25/7.25%E9%9B%86%E8%AE%AD/</url>
    <content><![CDATA[<p>#上午</p>
<p>讲了AC自动机 <span id="more"></span> 甩个链接日后补坑</p>
<p><a
href="https://www.luogu.com.cn/problem/solution/P3808">WA自动机</a></p>
<p>思想也懂 但是有些细节和坑点没有排雷，代码实现是有问题的</p>
<p>#下午</p>
<p>讲了他娘的一下午Vim</p>
<p>听得老子一脸懵逼</p>
<p>都他妈的是啥啊，麻烦死了</p>
<p>还是dev好用</p>
<p>#晚上</p>
<p>一晚上的dp</p>
<p>区间dp做了两道以前做过的，并且做了一道新的，这道新的，自己把式子推出来了，感觉不是太难</p>
<p>但是dp是永远没有边界的，难死个人</p>
<p>dp和搜索永远都能解决你意想不到且看起来很不可思议的一些问题</p>
<p>比如一道区间dp</p>
<p><a href="https://www.luogu.com.cn/problem/P2470">亚索</a></p>
<p>一道水水的紫题</p>
]]></content>
      <categories>
        <category>暑假日常</category>
      </categories>
      <tags>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title>7.22集训</title>
    <url>/2020/07/22/7-22%E9%9B%86%E8%AE%AD/</url>
    <content><![CDATA[<h1 id="上午">上午</h1>
<p><span class="math inline">\(cjh\)</span>学长讲课了,主要讲的动规
<span id="more"></span> <strong>1.线性dp</strong></p>
<p>典型例题</p>
<p><a href="https://www.luogu.com.cn/problem/P1077">摆花</a></p>
<p>不会这个题<span class="math inline">\(....!!!!!!\)</span></p>
<p><a href="https://www.luogu.com.cn/problem/P1541">王八棋</a></p>
<p>四个<span class="math inline">\(if\)</span>四个<span
class="math inline">\(for\)</span> 注意计数器从<span
class="math inline">\(0\)</span>还是<span
class="math inline">\(1\)</span>开始的</p>
<p><strong>2.背包（他没讲）</strong></p>
<p><strong>3.区间dp</strong></p>
<p>典型例题</p>
<p><a href="https://www.luogu.com.cn/problem/P1063">能量项链</a></p>
<p><a href="https://www.luogu.com.cn/problem/P1880">石子合并</a></p>
<p>两个题几乎都一样</p>
<p>给出区间dp的板子:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">初始化balbalbala.....</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; ++ len)</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n-len+<span class="number">1</span>; ++ i) &#123;</span><br><span class="line">      <span class="type">int</span> j = i+len<span class="number">-1</span>;</span><br><span class="line">	 <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; j; ++ k)</span><br><span class="line">	    f[i][j] = max/<span class="built_in">min</span>(f[i][j],f[i][k]+f[k+<span class="number">1</span>][j]*sth..)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>其中</p>
<p><span class="math inline">\(f[i][j] = max/min(f[i][j],
f[i][k]+f[k+1][j]*sth..)\)</span></p>
<p><strong>4.状压dp</strong></p>
<p>典型例题</p>
<p><a href="https://www.luogu.com.cn/problem/P3052">奶牛进电梯</a></p>
<p>学长说题解第一种做法不太好</p>
<p>最好是枚举子集 那样比较好 <strong>PS</strong></p>
<p>枚举子集</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> S = <span class="number">233333</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = S; i; i = (i<span class="number">-1</span>)&amp;S)</span><br><span class="line">   cout &lt;&lt;<span class="built_in">bitset</span>&lt;<span class="number">10</span>&gt;(i)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>还有比较操蛋的插头dp</p>
<p>甩个比较好的链接</p>
<p><a
href="https://www.cnblogs.com/dedicatus545/p/8638869.html">插头DP</a></p>
<p>讲了到题 <a
href="https://www.luogu.com.cn/problem/P3272">铺地板</a></p>
<p>对于此题
我们枚举三个状态，但是这个题有点难，对于我这种初学者不太合适</p>
<p>我们考虑一种简单的题:</p>
<p>还是铺地板，不过没有障碍物，我们铺的都是直线，并且，直线都是长至少为2，宽固定为1</p>
<p>对于这个题 我们规定 能继续延伸无论是横着或者竖着都是1</p>
<p>如果不能继续延伸 规定为0</p>
<p>然后每一行都是<span class="math inline">\(2^{n}\)</span>,有<span
class="math inline">\(n\)</span>行，所以复杂度为<span
class="math inline">\(n*2^{n}\)</span></p>
<p><strong>5.期望dp（他没讲）</strong></p>
<p><strong>6.树形dp（他说是重点）</strong></p>
<p><a href="https://www.luogu.com.cn/problem/P1352">有上司的舞会</a></p>
<p><a href="https://www.luogu.com.cn/problem/P2016">战略游戏</a></p>
<p>前两个题目都差不多，主要是我们开个<span
class="math inline">\(f\)</span>数组，<span
class="math inline">\(0\)</span>表示这个点没来（或者是不选），<span
class="math inline">\(1\)</span>表示来（或者是选）:<span
class="math inline">\(f[i][0/1]\)</span></p>
<p>然后我们就可以根据他们的儿子来转移</p>
<p>对于上面那道题</p>
<p><span class="math inline">\(f[i][0] = \sum{max(f[son][0],
f[son][1])}\)</span></p>
<p><span class="math inline">\(f[i][1] =
\sum{f[son][0]}+v[i]\)</span></p>
<p>其中<span class="math inline">\(v[i]\)</span>表示<span
class="math inline">\(i\)</span>这个节点的快乐指数</p>
<p>对于下面那道题</p>
<p><span class="math inline">\(f[i][0] += f[son][1]\)</span></p>
<p><span class="math inline">\(f[i][1] += min(f[son][0],
f[son][1])\)</span></p>
<p><a href="https://www.luogu.com.cn/problem/P3177">树上染色</a></p>
<p><img
src="https://img2020.cnblogs.com/blog/1307264/202009/1307264-20200904103846810-752601148.png" /></p>
<p>如图，我们假设节点<span class="math inline">\(1\)</span>的下面有<span
class="math inline">\(k\)</span>个黑点，<span
class="math inline">\(x--&gt;1\)</span>这条边为<span
class="math inline">\(val\)</span></p>
<p>我们考虑<span class="math inline">\(val\)</span>对整个图形的影响</p>
<p>设一共有<span class="math inline">\(B\)</span>个黑点，<span
class="math inline">\(W\)</span>个白点</p>
<p>顾<span class="math inline">\(val\)</span>对整个图形的影响为：</p>
<p><span
class="math inline">\((k*(B-k)+(s[1]-k)*(w-(s[1]-k))*val\)</span></p>
<p>其中<span class="math inline">\(s[1]\)</span>表示以<span
class="math inline">\(1\)</span>为祖先的子树的大小(<span
class="math inline">\(size\)</span>)</p>
<hr />
<h1 id="下午">下午</h1>
<p>一开始讲了一会，后来就做题了</p>
<p>讲了一个<a href="https://www.luogu.com.cn/problem/P2495">虚树</a></p>
<p>还有两个动规优化</p>
<p><a href="https://www.luogu.com.cn/problem/P3195">玩玩具的</a> <a
href="https://www.luogu.com.cn/problem/P2569">玩股票的</a></p>
<p>对于玩玩具的那个:</p>
<ul>
<li><p>1找出<span class="math inline">\(dp\)</span>式子</p></li>
<li><p>2魔改</p></li>
<li><p>3运用线性规划的知识与凸包的知识</p></li>
<li><p>4用斜率优化来做他</p></li>
</ul>
<p>对于玩股票的那个:</p>
<p>我们设<span class="math inline">\(f[i][j]\)</span>在第<span
class="math inline">\(i\)</span>天有<span
class="math inline">\(j\)</span>支股票能获得的最大价值</p>
<ul>
<li>1 凭空买</li>
</ul>
<p><span class="math inline">\(f[i][j] = -ap_{i}*j\)</span> 其中(<span
class="math inline">\(0\leq j \leq as_{i}\)</span>)</p>
<ul>
<li>2 不买也不买</li>
</ul>
<p><span class="math inline">\(f[i][j] = max(f[i-1][j],
f[i][j]\)</span></p>
<ul>
<li>3 在之前的基础上买</li>
</ul>
<p><span class="math inline">\(f[i][j] = max(f[i][j],
f[i-(w+1)][k]-(j-k)*ap{i}\)</span></p>
<p>其中(<span class="math inline">\(j-as_{i}\leq k &lt;j\)</span>)</p>
<ul>
<li>4在之前的基础上卖</li>
</ul>
<p><span class="math inline">\(f[i][j] = max(f[i][j],
f[i-(w+1)][k]+(k-j)*bp_{i}\)</span></p>
<p>其中(<span class="math inline">\(j&lt;k \leq j+bs_{i}\)</span>)</p>
<p>然后经过一系列<span
class="math inline">\(nb\)</span>操作就可以用单调队列来优化了...</p>
<p><strong>但是我既不会写代码也不会写优化</strong></p>
<p><strong>连这些状态都是从题解看过来的</strong></p>
<h1 id="晚上">晚上</h1>
<p>关于插头<span
class="math inline">\(dp\)</span>上午说的那个简单例题，学长给出了代码实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> int64;</span><br><span class="line"><span class="type">const</span> int64 p = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   unordered_map&lt;<span class="type">int</span>, int64&gt; dp[<span class="number">2</span>];</span><br><span class="line">   <span class="type">int</span> numnow = <span class="number">0</span>, numnext = <span class="number">1</span>;</span><br><span class="line">   dp[numnow][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> line = <span class="number">1</span>; line &lt;= n; ++line)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">      &#123;</span><br><span class="line">         dp[numnext].<span class="built_in">clear</span>();</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">auto</span> s = dp[numnow].<span class="built_in">begin</span>(); s != dp[numnow].<span class="built_in">end</span>(); ++s)</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="type">int</span> nowst = s-&gt;first, nowval = s-&gt;second;</span><br><span class="line">            <span class="type">int</span> u = (nowst &gt;&gt; i) &amp; <span class="number">1</span>, l = (nowst &gt;&gt; (i - <span class="number">1</span>)) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(u == <span class="number">0</span> &amp;&amp; l == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">               (dp[numnext][nowst ^ (<span class="number">1</span> &lt;&lt; i)] += nowval) %= p;</span><br><span class="line">               (dp[numnext][nowst ^ (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))] += nowval) %= p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(u == <span class="number">1</span> &amp;&amp; l == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">               (dp[numnext][nowst ^ (<span class="number">1</span> &lt;&lt; i)] += nowval) %= p;</span><br><span class="line">               (dp[numnext][nowst ^ (<span class="number">1</span> &lt;&lt; i) ^ (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))] += nowval) %= p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(u == <span class="number">0</span> &amp;&amp; l == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">               (dp[numnext][nowst ^ (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))] += nowval) %= p;</span><br><span class="line">               (dp[numnext][nowst ^ (<span class="number">1</span> &lt;&lt; i) ^ (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))] += nowval) %= p;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">swap</span>(numnow, numnext);</span><br><span class="line">      &#125;</span><br><span class="line">      dp[numnext].<span class="built_in">clear</span>();</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">auto</span> s = dp[numnow].<span class="built_in">begin</span>(); s != dp[numnow].<span class="built_in">end</span>(); ++s)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">if</span>(((s-&gt;first &gt;&gt; m) &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">            dp[numnext][s-&gt;first &lt;&lt; <span class="number">1</span>] = s-&gt;second;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">swap</span>(numnow, numnext);</span><br><span class="line">   &#125;</span><br><span class="line">   cout &lt;&lt; dp[numnext][<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> n, m;</span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">   <span class="built_in">work</span>(n, m);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于这份代码</p>
<p>其中<span class="math inline">\(u\)</span>为<span
class="math inline">\(up\)</span>，<span
class="math inline">\(l\)</span>为<span
class="math inline">\(left\)</span> 分别代表上边和左边来的数字</p>
<p><span
class="math inline">\(nowst,nowval\)</span>分别代表当前这一行的状态，当前及以前已经拥有的方案数</p>
<p>(从左往右更新的,因此<span
class="math inline">\(i\)</span>在右边，<span
class="math inline">\(i-1\)</span>在左边)</p>
<p>对于特娘的三种<span
class="math inline">\(if\)</span>我们来画几个图</p>
<p><img
src="https://cdn.luogu.com.cn/upload/image_hosting/hib7hlt3.png" /></p>
<p>对于这个图
我们u和l都为0也就是说，当前状态我们只能再向下或者右转移</p>
<p>上图是<span class="math inline">\(nowst\)</span>^<span
class="math inline">\(1&lt;&lt;(i-1)\)</span>的情况 即向下开始直线</p>
<p><img
src="https://cdn.luogu.com.cn/upload/image_hosting/wvonod5r.png" /></p>
<p>向右延伸的直线，即<span class="math inline">\(nowst\)</span>^<span
class="math inline">\(1&lt;&lt;i\)</span></p>
<p>至此<span class="math inline">\(u = 0, l =
0\)</span>的情况结束。来看<span class="math inline">\(u = 1, l =
0\)</span>的情况!</p>
<p><img
src="https://cdn.luogu.com.cn/upload/image_hosting/rnm1g9pj.png" /></p>
<p>当<span class="math inline">\(nowst\)</span>异或两次，即把第<span
class="math inline">\(i\)</span>位与第<span
class="math inline">\((i-1)\)</span>位都取反了</p>
<p>对于取反两次的情况，就是顺着原来的方向走，原来是竖着，现在还是竖着</p>
<p>而上图右边的那个情况是 <span
class="math inline">\(nowst\)</span>^<span
class="math inline">\((1&lt;&lt;i)\)</span>，即停止下渗</p>
<p>至此<span class="math inline">\(u = 1, l =
0\)</span>的情况结束。来看<span class="math inline">\(u = 0, l =
1\)</span>的情况！</p>
<p><img
src="https://cdn.luogu.com.cn/upload/image_hosting/w0lx3cup.png" /></p>
<p>当<span class="math inline">\(nowst\)</span>异或两次，即把第<span
class="math inline">\(i\)</span>位与第<span
class="math inline">\((i-1)\)</span>位都取反了</p>
<p>对于取反两次的情况，就是顺着原来的方向走，原来是<strong>横着</strong>着，现在还是<strong>横着</strong></p>
<p>而上图右边的那个情况是 <span
class="math inline">\(nowst\)</span>^<span
class="math inline">\((1&lt;&lt;(i-1)\)</span>，即停止继续向左</p>
<hr />
<p><span class="math inline">\(End...\)</span></p>
]]></content>
      <categories>
        <category>暑假日常</category>
      </categories>
      <tags>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title>7.26集训</title>
    <url>/2020/07/26/7.26%E9%9B%86%E8%AE%AD/</url>
    <content><![CDATA[<p>#上午</p>
<p>考试 <span id="more"></span> #下午</p>
<p>讲题讲课</p>
<p>以下有的东西是粘的</p>
<h4 id="同余定理">同余定理</h4>
<p>若<span class="math inline">\(a \% b == c \% b\)</span>,
我们称之为<span class="math inline">\(a\equiv c (\mod b)\)</span></p>
<p>在四则运算中，我们需要知道</p>
<p>在做题时，我们经常会遇到对一个数取模的运算</p>
<p>我们需要知道</p>
<p><span class="math inline">\((a+b)\%c=((a\%c)+(b\%c))\%c\)</span></p>
<p><span class="math inline">\((a-b)\%c=(((a-b)\%c)+c)\%c\)</span></p>
<p><span class="math inline">\((a\times
b)\%c=((a\%c)\times(b\%c))\%c\)</span></p>
<p>对于除法的处理参见下面的逆元</p>
<p>回归正题</p>
<p>快速幂的作用就是以<span
class="math inline">\(O(\log{b})\)</span>的时间复杂度解决<span
class="math inline">\(a^b\%c\)</span>的问题</p>
<p>正常暴力的话我们只能<span class="math inline">\(O(b)\)</span></p>
<p>这里用到的是二分的思想</p>
<p>根据上面的同余定理，显然我们可以将问题二分</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">ksm</span><span class="params">(LL a, LL n, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">if</span> (n &amp; <span class="number">1</span>) <span class="keyword">return</span> (LL)<span class="built_in">ksm</span>(a, n - <span class="number">1</span>, c) * a % c;</span><br><span class="line">   <span class="type">int</span> res = <span class="built_in">ksm</span>(a, n &gt;&gt; <span class="number">1</span>, c);</span><br><span class="line">   <span class="keyword">return</span> (LL)res * res % c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的是递归式的，我们也有非递归式的</p>
<p>不妨换个角度思考一下</p>
<p>我们把指数换成二进制</p>
<p>比如我们求<span class="math inline">\(7^{10}\)</span></p>
<p>在二进制的角度，也就是<span
class="math inline">\(7^{(1010)_2}\)</span></p>
<p>所以呢，我们很自然的联想到把它拆分成<span
class="math inline">\(7^{(1000)2}\)</span>和<span
class="math inline">\(7^{(10)2}\)</span></p>
<p>将上面的方法推广，所有的这样的问题我们都可以将指数拆开，分开计算</p>
<p>这样我们需要指数的二进制的每一位，因此，复杂度同上</p>
<p>下面的快速幂也是最常用的快速幂</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">ksm</span><span class="params">(LL a, LL b, <span class="type">int</span> mod)</span> </span>&#123;</span><br><span class="line">   LL res = <span class="number">1LL</span>; </span><br><span class="line">   <span class="keyword">while</span>(b) &#123;</span><br><span class="line">      <span class="keyword">if</span>(b &amp; <span class="number">1</span>) res = (LL)res * a % mod;</span><br><span class="line">      a = a * a % mod;</span><br><span class="line">      b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="逆元">逆元</h4>
<p>由费马小定理</p>
<p><span class="math inline">\(a^p\equiv a (\mod p)\)</span></p>
<p><span class="math inline">\(a^{p-1}\equiv 1 (\mod p)\)</span></p>
<p><span class="math inline">\(a\times a^{p-2}\equiv 1 (\mod
p)\)</span></p>
<p><span class="math inline">\(a^{p-2}\equiv \frac{1}{a} (\mod
p)\)</span></p>
<p>因此，a在模c意义下的乘法逆元为<span class="math inline">\(ksm(a, c -
2, c)\)</span></p>
<p>还有一种<span class="math inline">\(O(n)\)</span>线性求逆元的方法</p>
<p>推荐记住推导过程，当然要是直接记住结论也没问题</p>
<p>对于<span class="math inline">\(i\)</span>在mod
p意义下的逆元,我们可以</p>
<p>令<span class="math inline">\(a=\frac p i, b=p \% i\)</span></p>
<p>显然p可以表示为<span class="math inline">\(i\times a + b\)</span></p>
<p>于是，<span class="math inline">\(i\times a + b \equiv 0 (\mod
p)\)</span></p>
<p><span class="math inline">\(i\times a \equiv -b (\mod p)\)</span></p>
<p><span class="math inline">\(i^{-1} \equiv -\frac a b (\mod
p)\)</span></p>
<p>于是，i的逆元就是<span class="math inline">\(-a\times
b^{-1}\)</span></p>
<p>即<span class="math inline">\(-\frac p i \times
(p\%i)^{-1}\)</span></p>
<p>可能你会问，那<span
class="math inline">\(p\%i\)</span>的逆元咋求，用ksm的结论吗？</p>
<p>不难发现，<span class="math inline">\(p \%
i\)</span>肯定比当前的i要小，因此我们再求i的逆元的时候<span
class="math inline">\(p\%i\)</span>的逆元是已知的！ <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mutl</span><span class="params">(<span class="type">int</span> mod)</span> </span>&#123;</span><br><span class="line">   inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= M; i++) </span><br><span class="line">   inv[i] = (((mod-mod/i)*inv[mod % i])%mod+mod)%mod; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure> ####
慢速乘（龟速乘） 感觉比较简单 直接贴代码吧 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">msc</span><span class="params">(LL a, LL b, LL c)</span> </span>&#123;</span><br><span class="line">   LL ans = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>(b) &#123;</span><br><span class="line">      <span class="keyword">if</span>(b &amp; <span class="number">1</span>) ans = (ans + a) % c;</span><br><span class="line">      a = (a + a) % c;</span><br><span class="line">      b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="矩阵加速">矩阵加速</h4>
<p>比如，以斐波那契数列为例</p>
<p><span class="math inline">\(f[n] = f[n - 1] + f[n - 2]\)</span></p>
<p>不妨构造矩阵 <span class="math inline">\(\left[\begin{matrix}  f[n]
&amp; f[n + 1] &amp; f[n + 2] \
0 &amp; 0 &amp; 0 \
0 &amp; 0 &amp; 0 \end{matrix}\right]\)</span></p>
<p>如果我们称上面的矩阵为第n个矩阵</p>
<p>那么显然第一个矩阵就是 <span
class="math inline">\(\left[\begin{matrix}  f[1] &amp; f[2] &amp; f[3] \
0 &amp; 0 &amp; 0 \
0 &amp; 0 &amp; 0 \end{matrix}\right]\)</span></p>
<p>也即 <span class="math inline">\(\left[\begin{matrix}  1 &amp; 1
&amp; 2 \
0 &amp; 0 &amp; 0 \
0 &amp; 0 &amp; 0 \end{matrix}\right]\)</span></p>
<p>我们现在的任务便是构造一个矩阵B，使得 $&amp; f[n + 1] &amp; f[n +
2]<br />
0 &amp; 0 &amp; 0<br />
0 &amp; 0 &amp; 0 \end{matrix}]B = &amp; f[n + 2] &amp; f[n + 3]<br />
0 &amp; 0 &amp; 0<br />
0 &amp; 0 &amp; 0 \end{matrix}] $</p>
<p>根据矩阵乘法的方式，我们成功获得矩阵B <span
class="math inline">\(\left[\begin{matrix} 0 &amp; 0 &amp; 0 \
1 &amp; 0 &amp; 1 \
0 &amp; 1 &amp; 1 \end{matrix}\right]\)</span></p>
<p>贴上代码 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">matrix</span> &#123; </span><br><span class="line">   LL a[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">   <span class="built_in">matrix</span>() &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">2</span>; i++)</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">2</span>; j++)</span><br><span class="line">           	a[i][j] = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">friend</span> matrix <span class="keyword">operator</span> * (<span class="type">const</span> matrix &amp;b, <span class="type">const</span> matrix &amp;c) &#123;</span><br><span class="line">      matrix d;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">2</span>; i++)</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">2</span>; j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">2</span>; k++)</span><br><span class="line">               (d.a[i][j] += ((LL)b.a[i][k] * c.a[k][j])) %= mod;</span><br><span class="line">      <span class="keyword">return</span> d;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">rec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">2</span>; i++)</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">2</span>; j++)</span><br><span class="line">            <span class="keyword">this</span>-&gt;a[i][j] = (i == j);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function">matrix <span class="title">ksm</span><span class="params">(LL t)</span> </span>&#123;</span><br><span class="line">      matrix c;</span><br><span class="line">      c.<span class="built_in">rec</span>();</span><br><span class="line">      <span class="keyword">while</span>(t) &#123;</span><br><span class="line">         <span class="keyword">if</span>(t &amp; <span class="number">1LL</span>) c = c * (*<span class="keyword">this</span>);</span><br><span class="line">         (*<span class="keyword">this</span>) = (*<span class="keyword">this</span>) * (*<span class="keyword">this</span>);</span><br><span class="line">         t &gt;&gt;= <span class="number">1LL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> *<span class="keyword">this</span> = c;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;A, B;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   A.a[<span class="number">1</span>][<span class="number">0</span>] = A.a[<span class="number">2</span>][<span class="number">1</span>] = A.a[<span class="number">2</span>][<span class="number">2</span>] = A.a[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1LL</span>;</span><br><span class="line">   B.a[<span class="number">0</span>][<span class="number">0</span>] = B.a[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">   B.a[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, (B * A.<span class="built_in">ksm</span>(<span class="built_in">in</span>() - <span class="number">1</span>)).a[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> #### STL 一大堆东西 <span
class="math inline">\(queue,vector,map,set,priority_queue\)</span>
都是基操，虽然可能大概有的我还不会.....</p>
<p>甩甩链接：</p>
<p><a href="https://www.jianshu.com/p/7d32176033ed">vector</a></p>
<p><a href="https://www.cnblogs.com/zyxStar/p/4542835.html">set</a></p>
<p><a
href="https://blog.csdn.net/qq_33375598/article/details/88041633">map</a></p>
<p><a
href="https://www.cnblogs.com/LjwCarrot/p/9050623.html">queue</a></p>
<p><a
href="https://blog.csdn.net/hellokandy/article/details/81458663">priority_queue</a></p>
<p><a
href="https://blog.csdn.net/sevenjoin/article/details/81937695">pair</a></p>
<p>关于迭代器的使用： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(STL::iterator it = STL.<span class="built_in">begin</span>(); it != STL.<span class="built_in">end</span>(); it++)</span><br></pre></td></tr></table></figure> #### 卡特兰数 公式：<span
class="math inline">\(C_{2n}^{n} - C_{2n}^{n-1}\)</span></p>
<p>可以推出来：<span class="math inline">\(\dfrac {C_{2n}^{n}}
{n+1}\)</span></p>
<p>这玩意应用多</p>
<p>通过一群数的进zhan出zhan顺序可以得到，设<span
class="math inline">\(h[i]\)</span>表示以<span
class="math inline">\(i\)</span>为结尾的数的总出栈方案</p>
<p>显然<span class="math inline">\(h[i] = \sum
{h[j-1]*h[i-(j+1)-1]}\)</span> 其中 <span class="math inline">\(1 \leq j
\leq i\)</span></p>
<p>#晚上</p>
<p>改题</p>
<p><a href="https://www.luogu.com.cn/problem/P4145">药神</a></p>
<p>写个线段树维护一下标记，其中，如果一个数被干了五次以上，就为1了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span>+<span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N], b[N&lt;&lt;<span class="number">2</span>], d[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span> <span class="params">(<span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (s == t) &#123;</span><br><span class="line">      d[p] = a[s];</span><br><span class="line">      b[p] = a[s];</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">int</span> m = (s + t) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">   <span class="built_in">build</span> (s, m, p&lt;&lt;<span class="number">1</span>), <span class="built_in">build</span> (m+<span class="number">1</span>, t, (p&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>);</span><br><span class="line">   d[p] = d[p&lt;&lt;<span class="number">1</span>] + d[(p&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>];</span><br><span class="line">   b[p] = <span class="built_in">max</span>(b[p&lt;&lt;<span class="number">1</span>], b[(p&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">update</span> <span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (s == t) &#123;</span><br><span class="line">      d[p] = <span class="built_in">sqrt</span>(d[p]);</span><br><span class="line">      b[p] = <span class="built_in">sqrt</span>(b[p]);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (b[p] &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">   <span class="type">int</span> m = (s + t) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">if</span> (l &lt;= m) <span class="built_in">update</span> (l, r, s, m, p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">if</span> (r &gt; m) <span class="built_in">update</span> (l, r, m+<span class="number">1</span>, t, (p&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>);</span><br><span class="line">   d[p] = (d[p&lt;&lt;<span class="number">1</span>] + d[(p&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>]);</span><br><span class="line">   b[p] = <span class="built_in">max</span>(b[p&lt;&lt;<span class="number">1</span>], b[(p&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getsum</span> <span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (l &lt;= s &amp;&amp; t &lt;= r) <span class="keyword">return</span> d[p];</span><br><span class="line">   <span class="type">int</span> m = (s + t) &gt;&gt; <span class="number">1</span>, sum = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">if</span> (l &lt;= m) sum += <span class="built_in">getsum</span> (l, r, s, m, p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">if</span> (r &gt; m) sum += <span class="built_in">getsum</span> (l, r, m+<span class="number">1</span>, t, (p&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">scanf</span> (<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) </span><br><span class="line">      <span class="built_in">scanf</span> (<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">      <span class="built_in">build</span> (<span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">      cin &gt;&gt; m;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">	 <span class="type">int</span> opt, x, y;</span><br><span class="line">	 cin &gt;&gt; opt &gt;&gt; x &gt;&gt; y;</span><br><span class="line">	 <span class="keyword">if</span> (x &gt; y) <span class="built_in">swap</span>(x, y);</span><br><span class="line">	 <span class="keyword">if</span> (opt == <span class="number">0</span>) <span class="built_in">update</span> (x, y, <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">	 <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">getsum</span> (x, y, <span class="number">1</span>, n, <span class="number">1</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a
href="https://www.luogu.com.cn/problem/P3800">单调队列优化dp</a></p>
<p>别人一眼<span class="math inline">\(dp\)</span>，我也一眼<span
class="math inline">\(dp\)</span>，但是别人写<span
class="math inline">\(dp\)</span>，我却在写搜索，全<span
class="math inline">\(T\)</span>了....</p>
<p>我们设<span class="math inline">\(f[i][j]\)</span>为到达<span
class="math inline">\(i,j\)</span>这个点所能获得的最大价值</p>
<p>显然：<span class="math inline">\(f[i][j] = max(f[i-1][k] +
val[i][j]\)</span>其中<span class="math inline">\(j-t \leq k \leq
j+t\)</span></p>
<p>显然：我们只需要在<span
class="math inline">\(i\)</span>的上一层，维护一个长度为<span
class="math inline">\(2*t\)</span>的<a
href="https://www.luogu.com.cn/problem/P1886">滑动窗口</a>就可以了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">4e3</span>+<span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, k, t;</span><br><span class="line"><span class="type">int</span> head = <span class="number">1</span>, tail = <span class="number">0</span>, res;</span><br><span class="line"><span class="type">int</span> f[N][N], q[N], a[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= t; ++ i) &#123;</span><br><span class="line">      <span class="keyword">while</span> (f[x][i] &gt; f[x][q[tail]] &amp;&amp; tail &gt;= head)</span><br><span class="line">	 -- tail;</span><br><span class="line">	 q[++tail] = i;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> last)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (x+t &lt;= m) &#123;</span><br><span class="line">      <span class="keyword">while</span> (f[last][x+t]&gt;f[last][q[tail]] &amp;&amp; tail &gt;= head)</span><br><span class="line">	 -- tail;</span><br><span class="line">         q[++tail] = x+t;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">while</span> (q[head]+t &lt; x) ++ head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">   cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; t;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; ++ i) &#123;</span><br><span class="line">      <span class="type">int</span> x, y, v;</span><br><span class="line">      cin &gt;&gt; x &gt;&gt; y &gt;&gt; v;</span><br><span class="line">      a[x][y] = v;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) f[<span class="number">1</span>][i] = a[<span class="number">1</span>][i];</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">      <span class="built_in">calc</span>(i<span class="number">-1</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)&#123;</span><br><span class="line">	 <span class="built_in">Insert</span>(j, i<span class="number">-1</span>);</span><br><span class="line">	 f[i][j] = f[i - <span class="number">1</span>][q[head]]+a[i][j];</span><br><span class="line">      &#125;</span><br><span class="line">      head = <span class="number">1</span>, tail = <span class="number">0</span>;</span><br><span class="line">   &#125;	</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) res = (res&lt;f[n][i])?f[n][i]:res;</span><br><span class="line">   cout &lt;&lt; res;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a
href="">一群操蛋的奶牛</a>https://www.luogu.com.cn/problem/P2344</p>
<p>不会</p>
<p>埋个坑</p>
<p>日后补</p>
<hr />
<p><span class="math inline">\(7.28update\)</span></p>
<p>正解是维护前缀和与树状数组</p>
<p>我写了个搜索在某谷就过去了，但是<a
href="https://home.cnblogs.com/u/yzzy/">HEZG</a>给的数据过不去</p>
<p>某谷数据太水了！！！</p>
<p>给出能在某谷AC的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt; &gt;q;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">66</span>, mod = <span class="number">1e9</span>+<span class="number">9</span>;</span><br><span class="line">	</span><br><span class="line"><span class="type">int</span> n, m, res;</span><br><span class="line"><span class="type">int</span> yhm[N], a[N];</span><br><span class="line"><span class="type">bool</span> v[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">xieruyijichushihua</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   yhm[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">   cin &gt;&gt; n;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">jiejuewenti</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">   <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">   <span class="type">int</span> now = q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">   res = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = now+<span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">          res += a[i];</span><br><span class="line">          <span class="keyword">if</span> (res &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">	     yhm[i] += yhm[now];</span><br><span class="line">             yhm[i] %= mod;</span><br><span class="line">             <span class="keyword">if</span> (!v[i]) q.<span class="built_in">push</span>(i), v[i] = <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">xieruyijichushihua</span>();</span><br><span class="line">   <span class="built_in">jiejuewenti</span>();</span><br><span class="line">   cout &lt;&lt; yhm[n];</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写入以及初始化：<span
class="math inline">\(xieruyijichushihua\)</span></p>
<p>解决问题:<span class="math inline">\(jiejuewenti\)</span></p>
<p>拿了五十分，准备拍拍屁股走人</p>
]]></content>
      <categories>
        <category>暑假日常</category>
      </categories>
      <tags>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title>7.29集训</title>
    <url>/2020/07/29/7.29%E9%9B%86%E8%AE%AD/</url>
    <content><![CDATA[<h1 id="上午">上午</h1>
<p><del>(睡觉ing)</del> <span id="more"></span> 主要也就是讲了数据结构</p>
<p>讲了树状数组，线段树的相关操作（貌似没有提到分块）</p>
<p>###单改区查</p>
<p><a href="https://loj.ac/problem/130">click</a></p>
<p>秒切</p>
<p>###区改单查</p>
<p><a href="https://loj.ac/problem/131">click</a></p>
<p>搞个差分数组，还是切</p>
<h3 id="区改区查">区改区查</h3>
<p><a href="https://loj.ac/problem/132">click</a></p>
<p>推式子....</p>
p的前缀和=
<span class="math display">\[\begin{aligned}\sum_{i=1}^p a[i] =
\sum_{i=1}^p\sum_{j=1}^i d[j]\end{aligned}\]</span>
<p>其中d数组为差分数组</p>
<p>在等式最右侧的式子<span
class="math inline">\(\begin{aligned}\sum_{i=1}^p\sum_{j=1}^id[j]\end{aligned}\)</span>
中，<span class="math inline">\(d[1]\)</span>被利用了<span
class="math inline">\(p\)</span>次，<span
class="math inline">\(d[2]\)</span><span
class="math inline">\(被利用了\)</span><span
class="math inline">\(p-1\)</span>次…….,因此我们可以推出</p>
p的前缀和=
<span class="math display">\[\begin{aligned}\sum_{i=1}^p\sum_{j=1}^id[j]
= \sum_{i=1}^pd[i]*(p-i+1)\end{aligned}\]</span>
<p>然后我们考虑将<span class="math inline">\(p+1​\)</span>与<span
class="math inline">\(-i​\)</span> 提出来</p>
<p>p的前缀和=<span
class="math display">\[\begin{aligned}(p+1)*\sum_{i=1}^pd[i]-\sum_{i=1}^pd[i]*i\end{aligned}\]</span></p>
<p>那么我们考虑维护两个数组的前缀和：一个数组是<span
class="math inline">\(sum1[i] = d[i]​\)</span>,另一个是<span
class="math inline">\(sum2[i] = d[i]*i​\)</span></p>
<p>查询的时候位置p的前缀和为：<span
class="math inline">\((p+1)*sum1\)</span>数组中p的前缀和-<span
class="math inline">\(sum2\)</span>数组中p的前缀和</p>
<p>区间[<span class="math inline">\(l,r]\)</span>的和即：位置<span
class="math inline">\(r\)</span>的前缀和 - 位置<span
class="math inline">\(l-1\)</span>的前缀和。</p>
<p>修改的时候对sum1数组正常差分</p>
<p>对<span class="math inline">\(sum2\)</span>数组类似，对<span
class="math inline">\(sum2[i]\)</span>加上$ lx <span
class="math inline">\(，给\)</span> sum2[r+1] <span
class="math inline">\(减去\)</span>(r-1)x$</p>
<details>
<summary>
Code
</summary>
<pre><code>inline void jia (int x, int val) &#123;
   for (int i = x; i <= n; i += lowbit(i))
      sum1[i] += val, sum2[i] += val*x;
&#125;
inline void qujianjia (int l, int r, int val) &#123;jia(l, val), jia(r+1, -val);&#125;
inline int chaxun(int x) &#123;
   int res(0);
   for (int i = x; i; i -= lowbit(i))
      res += (x + 1)*sum1[i] - sum2[i];
   return res;
&#125;
inline int qujianchaxun(int l, int r) &#123;return chaxun(r) - chaxun(l-1);&#125;
</code></pre>
</details>
<h3 id="逆序对">逆序对</h3>
<p><a href="https://www.luogu.com.cn/problem/P1908">click</a></p>
<p>way1.我们可以用归并排序来求</p>
<p>如果我们想将一个序列拍成有序的，那么每次合并的时候，左右两边的序列一定是有序的</p>
<p>我们每次只需要考虑右边的数能与左边的数分别构成多少个逆序对</p>
<p>看个例子左区间<span class="math inline">\(a = \left\{5,6,7
\right\}\)</span>右区间 <span class="math inline">\(b = \left\{1, 2,
9\right\}\)</span></p>
<p><em>1</em>. 5 &gt; 1, 发现产生了逆序对，
此时做区间没有合并的数都要比1大，所以1与左边区间共产生了三个逆序对</p>
<p><em>2.</em> 5 &gt; 2, 由上文可知产生了产生了三对逆序对</p>
<p>….</p>
<p>所以：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">tot += (LL)mid - i + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>复杂度<span class="math inline">\(nlogn\)</span></p>
<p>way2.用树状数组<del>当然是建立权值树状数组</del></p>
<p>我们考虑逆序对的定义，首先是<span
class="math inline">\(i&gt;j\)</span>，其次是<span
class="math inline">\(a[i] &lt; a[j]\)</span></p>
<p>在树状数组里面，对于权值树状数组，我们肯定考虑离散化</p>
<p>对于每次新进的数x，我们考虑在树状数组上在下标为x的地方加1，代表这个数存在过</p>
<p>而我们再来思考逆序对的定义，说白了就是在当前这个数的前面，有多少个比ta大的</p>
<p>求一遍<span class="math inline">\(1\)</span> ~ <span
class="math inline">\(x\)</span>这个数的前缀和，再用一共输入的点的个数前去这部分，不就剩下了比x大的部分？</p>
<p><strong>PS</strong>:<span
class="math inline">\(rank[i]\)</span>表示原序列中第<span
class="math inline">\(i\)</span>个数目前的排名（大小）是多少</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x&amp;-x)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span>+<span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, tot;</span><br><span class="line"><span class="type">int</span> rank[N], tree[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;<span class="type">int</span> val, id;&#125;a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">cmp</span> <span class="params">(node x, node y)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> (x.val&lt;y.val)||(x.val == y.val &amp;&amp; x.id &lt; y.id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">charu</span> <span class="params">(<span class="type">int</span> x, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt;= n; i += <span class="built_in">lowbit</span>(i))</span><br><span class="line">      tree[i] += val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">chaxun</span> <span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">   <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> (x) &#123;</span><br><span class="line">      res += tree[x];</span><br><span class="line">      x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">   cin &gt;&gt; n;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">      cin &gt;&gt; a[i].val;</span><br><span class="line">      a[i].id = i;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">sort</span> (a + <span class="number">1</span>, a + n + <span class="number">1</span>, cmp);</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) rank[a[i].id] = i;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">      <span class="built_in">charu</span>(rank[i], <span class="number">1</span>);</span><br><span class="line">      tot += i-<span class="built_in">chaxun</span>(rank[i]);</span><br><span class="line">   &#125;</span><br><span class="line">   cout &lt;&lt; tot;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="小火柴">小火柴</h3>
<p><a href="https://www.luogu.com.cn/problem/P1966">click</a></p>
<p>考虑，我们需要保证的是，a序列的第k大数对应着b序列中第k大的数</p>
<p>所以在离散化完成后的数组内，我们假设<span class="math inline">\(a =
\left\{ 4,3,1,2 \right\}\)</span>,<span class="math inline">\(b =
\left\{ 1,3,2,4 \right\}\)</span></p>
<p>令<span class="math inline">\(q[a[i]] = b[i]\)</span>，相当于以<span
class="math inline">\(a[i]\)</span>为关键字对<span
class="math inline">\(b[i]\)</span>进行排序</p>
<p>得到<span class="math inline">\(q[1] = 2, q[2] = 4, q[3] = 3, q[4] =
1\)</span>，意味着，a中的1对应着b中的2，a中的2对应着b中的4</p>
<p>若序列a与序列b相等，也就是说<span class="math inline">\(q[i] =
i\)</span></p>
<p>我们想让<span
class="math inline">\(a,b\)</span>序列相等，就要保证q数组单调递增</p>
<p>所以原来问题转化为：将原来凌乱的q数组转化为一个升序数组需要的最小次数，且每一次只能交换相邻的两个数</p>
<p>这不是逆序对这是啥？</p>
<h3 id="项链">项链</h3>
<p><a href="https://www.luogu.com.cn/problem/P1972">click</a></p>
<p>用<span
class="math inline">\(nlogn\)</span>离线树状数组才能做，莫队会被卡</p>
<p>我们首先肯定要把询问按照右端点从小到大排序，这样保证我们不会来回跳转</p>
<p>然后我们考虑当前这个颜色是否出现过，如果发现没有出现过，那么就令他为<span
class="math inline">\(1\)</span>，如果出现过，就令前面出现的那次<span
class="math inline">\(+(-1)\)</span>，这次为<span
class="math inline">\(1\)</span></p>
<p>此时我们考虑两种情况，</p>
<p>第一种：上次出现的颜色在当前查询的区间内，那么我们新规定的颜色，完全可以取代上一次的，题目在询问我们有多少种颜色，并不在乎出现次数</p>
<p>第二种，上次出现的颜色不在当前查询的区间内，那更好，我们之前的修改完毕之后，我们以后肯定不会再用它，因为我们的r是从前往后扫的</p>
<p>每次查询的时候，我们就查询这个区间的l与r之间存在多少个1，利用树状数组可以很好的完成</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define debug</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x&amp;-x)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e6</span>+<span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N], ans[N];</span><br><span class="line"><span class="type">int</span> vis[N], tree[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;<span class="type">int</span> l, r, id;&#125;q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">cmp</span> <span class="params">(node x, node y)</span> </span>&#123;<span class="keyword">return</span> x.r &lt; y.r;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">charu</span> <span class="params">(<span class="type">int</span> x, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt;= n; i += <span class="built_in">lowbit</span>(i))</span><br><span class="line">      tree[i] += val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">chaxun</span> <span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">   <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> (x) &#123;</span><br><span class="line">      res += tree[x];</span><br><span class="line">      x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">   <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">      <span class="type">int</span> l, r;</span><br><span class="line">      <span class="built_in">scanf</span> (<span class="string">&quot;%d%d&quot;</span>, &amp;q[i].l, &amp;q[i].r);</span><br><span class="line">      q[i].id = i;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">sort</span>(q+<span class="number">1</span>, q+m+<span class="number">1</span>, cmp);</span><br><span class="line">   <span class="type">int</span> now = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!vis[a[i]]) &#123;</span><br><span class="line">	 vis[a[i]] = i;</span><br><span class="line">	 <span class="built_in">charu</span>(i, <span class="number">1</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="built_in">charu</span>(vis[a[i]], <span class="number">-1</span>);</span><br><span class="line">         <span class="built_in">charu</span>(i, <span class="number">1</span>);</span><br><span class="line">         vis[a[i]] = i;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (q[now].r == i) &#123;</span><br><span class="line">      	 ans[q[now].id] = <span class="built_in">chaxun</span>(q[now].r) - <span class="built_in">chaxun</span>(q[now].l<span class="number">-1</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> debug</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;now:--&gt;&quot;</span> &lt;&lt; now &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line">         ++ now;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> debug</span></span><br><span class="line"><span class="built_in">printf</span> (<span class="string">&quot;\n\n\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="异或和">异或和</h3>
<p><a href="https://www.luogu.com.cn/problem/P3760">click</a></p>
<p>题目是在求所有连续和的异或之和，即：<span
class="math inline">\(\oplus
\sum_\limits{i=1}^n\sum_\limits{j=0}^{i-1}sum(i)-sum(j)\)</span></p>
<p>观察数据范围，<span class="math inline">\(\sum_\limits{i=1}^{n}a[i]
\leq 1e6\)</span> --&gt; 考虑前缀和</p>
<p>考虑二进制下每一位对答案的影响，所以分四种情况</p>
<p>设第一个数<span class="math inline">\(A\)</span>，第二个数为<span
class="math inline">\(B\)</span>，所以分为<span
class="math inline">\(A=1\)</span><span
class="math inline">\(B=1\)</span><span
class="math inline">\(A=1\)</span><span
class="math inline">\(B=0\)</span>的情况</p>
<p><span class="math inline">\(1 - 1 = 1\)</span></p>
<p>说明第一个数的第<span class="math inline">\(k\)</span>位为<span
class="math inline">\(1\)</span>的时候，前<span
class="math inline">\(k-1\)</span>位要比<span
class="math inline">\(B\)</span>的前<span
class="math inline">\(k-1\)</span>位小</p>
<p><span class="math inline">\(1 - 0 = 1\)</span></p>
<p>说明第一个数的第<span class="math inline">\(k\)</span>位为<span
class="math inline">\(1\)</span>的时候，前<span
class="math inline">\(k-1\)</span>位要比<span
class="math inline">\(B\)</span>的前<span
class="math inline">\(k-1\)</span>位大</p>
<p><span class="math inline">\(0 - 1 = 0\)</span></p>
<p>说明第一个数的第<span class="math inline">\(k\)</span>位为<span
class="math inline">\(0\)</span>的时候，前<span
class="math inline">\(k-1\)</span>位要比<span
class="math inline">\(B\)</span>的前<span
class="math inline">\(k-1\)</span>位小</p>
<p><span class="math inline">\(0 - 1 = 1\)</span></p>
<p>说明第一个数的第<span class="math inline">\(k\)</span>位为<span
class="math inline">\(0\)</span>的时候，前<span
class="math inline">\(k-1\)</span>位要比<span
class="math inline">\(B\)</span>的前<span
class="math inline">\(k-1\)</span>位大</p>
<p>然后埋坑.....</p>
<h3 id="附近公园">附近公园</h3>
<p><a href="https://www.luogu.com.cn/problem/P3616">click</a></p>
<p>先把这个序列大于等于水面的取为1，否则为0</p>
<p>考虑每一位置对他左边的取一个min和max，考虑min与max序列中，“1”的那些位置有几个不一样</p>
<p>就相当于存在了几对区间，所以 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ans = differt &gt;&gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>然后我们考虑用min和max来围护一个什么东西，用离散化加树状数组就好</p>
<p>关于可持久化线段树</p>
<p>考虑对每一个状态都开一个线段树，为了使其优化，我们尝试当前树连之前树的边，这样会优化空间</p>
<p>单点修改的话，可以简单一些</p>
<p>对于区间修改的东西，我们得边读入边建树</p>
<p>而对于可持久化权值线段树，也就是主席树（jmh树）</p>
<p>我不会...</p>
<p><strong>不会就要学啊！等我回头补上！！！</strong></p>
<h1 id="下午">下午</h1>
<p>讲了一下午树剖，不懂..... <a
href="https://www.cnblogs.com/ivanovcraft/p/9019090.html">click</a></p>
<h1 id="晚上">晚上</h1>
<p>写博客 补坑</p>
]]></content>
      <categories>
        <category>暑假日常</category>
      </categories>
      <tags>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title>7.30集训</title>
    <url>/2020/07/30/7.30%E9%9B%86%E8%AE%AD/</url>
    <content><![CDATA[<p>#上午</p>
<h3 id="第一题">第一题</h3>
<span id="more"></span>
<p><a href="https://www.luogu.com.cn/problem/P3173">巧克力</a></p>
<p>这题某谷数据水，<span
class="math inline">\(int\)</span>就过了，因为以前做过，所以这次理所当然的<strong>切了</strong></p>
<p>切了之后我还仔细查看是否需要LL，检查无误后，没开LL</p>
<p>但是教练的数据强，卡我50分，上次因为LL卡我100分</p>
<p>出题人学长<a
href="https://youngscc.github.io/">Youngsc</a>的题是真的强.....</p>
<p>这题贪心做，把权值从小到大排序，排完之后干就完了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define debug</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">in</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   LL x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="type">char</span> ch;</span><br><span class="line">   <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = <span class="built_in">getchar</span>()))(ch == <span class="string">&#x27;-&#x27;</span>) &amp;&amp; (f = -f);</span><br><span class="line">   <span class="keyword">for</span>(x = ch^<span class="number">48</span>;<span class="built_in">isdigit</span>(ch = <span class="built_in">getchar</span>()); x = (x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>) + (ch^<span class="number">48</span>));</span><br><span class="line">   <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, res;</span><br><span class="line"><span class="type">int</span> sum1 = <span class="number">1</span>, sum2 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;<span class="type">int</span> val, tag;&#125;a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">cmp</span> <span class="params">(node x, node y)</span> </span>&#123;<span class="keyword">return</span> x.val &gt; y.val;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">   n = <span class="built_in">in</span>(), m = <span class="built_in">in</span>();</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n<span class="number">-1</span>; ++ i) a[i].val = <span class="built_in">in</span>(), a[i].tag = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = n; i &lt;= n+m<span class="number">-2</span>; ++ i) a[i].val = <span class="built_in">in</span>(), a[i].tag = <span class="number">2</span>;</span><br><span class="line">   <span class="built_in">sort</span> (a+<span class="number">1</span>, a+n+m<span class="number">-1</span>, cmp);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> debug</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n+m<span class="number">-2</span>; ++ i)</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;val--&gt;&quot;</span> &lt;&lt; a[i].val &lt;&lt; <span class="string">&quot;tag--&gt;&quot;</span> &lt;&lt; a[i].tag &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n+m<span class="number">-2</span>; ++ i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[i].tag == <span class="number">1</span>) res += a[i].val*sum2, ++ sum1;</span><br><span class="line">      <span class="keyword">else</span> res += a[i].val*sum1, ++ sum2;</span><br><span class="line">   &#125;</span><br><span class="line">   cout &lt;&lt; res;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第二题">第二题</h3>
<p><img
src="https://pic.imgdb.cn/item/6327e36216f2c2beb13ca619.png" /></p>
<details>
<summary>
Sample input
</summary>
<pre><code>5 6
7 2 3 1 1
5 0 6 0 0
8 6 6 5 3
4 3 7 8 2
4 0 0 6 9
</code></pre>
</details>
<details>
<summary>
Sample output
</summary>
<pre><code>20
</code></pre>
</details>
<p>样例解释: 分别以<span
class="math inline">\((2,1)\)</span>为左上角<span
class="math inline">\((5,2)\)</span>为右下角和以<span
class="math inline">\((1,3)\)</span>为左上角以<span
class="math inline">\((4,5)\)</span>为右下角的两个矩阵。</p>
<p>数据范围:</p>
<p>对于<span class="math inline">\(20%\)</span>的数据<span
class="math inline">\(n \leq 5\)</span></p>
<p>对于<span class="math inline">\(50%\)</span>的数据<span
class="math inline">\(n \leq 50\)</span></p>
<p>另有<span
class="math inline">\(5%\)</span>的数据满足所有电脑的便利值均为<span
class="math inline">\(1\)</span></p>
<p>另另有<span
class="math inline">\(25%\)</span>的数据满足所有的电脑便利值相同</p>
<p>对于<span class="math inline">\(100%\)</span>的数据满足<span
class="math inline">\(n \leq 300\)</span>，<span class="math inline">\(p
\leq 50\)</span>，<span class="math inline">\(0 \leq a[i][j] \leq
65536\)</span></p>
<hr />
<p><strong>特别鸣谢<a
href="https://home.cnblogs.com/u/kagula/">lpj</a>大佬，在我写完代码之后依旧迷迷糊糊的时候，帮我理清了思路</strong></p>
<p>首先对于这个题，观察数据范围发现<span
class="math inline">\(n\leq300,p\leq50,0\leq
a[i][j]\leq65536\)</span></p>
<p>我们可以考虑一个<span
class="math inline">\(n^4\)</span>的dp暴力，直接搞</p>
<p>但是这样是过不了全部数据的</p>
<p><span class="math inline">\(n \leq
300\)</span>我们考虑如何来优化一维</p>
<p>我们考虑用<span class="math inline">\(l\)</span>和<span
class="math inline">\(r\)</span>这两维来搞那个矩形长度，对于每一行，我们把那一行看成一个元素，对那一行求一个前缀和</p>
<p>这样再从纵列枚举一个<span
class="math inline">\(t\)</span>这样就转化成了三维</p>
我们来考虑主函数中的三个函数
<details>
<summary>
function
</summary>
<pre><code>shuruyijichushihua()
jiejuewenti()
shuchudaan()
</code></pre>
</details>
<p>其中第一个与第三个函数很简单</p>
我们来看jiejuewenti的函数
<details>
<summary>
function
</summary>
<pre><code>dodododo()
fanzhuan()
dododo()
</code></pre>
</details>
<p>先说明一下fanzhuan()，对于矩形一上一下的情况，我们必须将矩阵翻转过来，再干一遍</p>
<p>翻转可以有两种写法：</p>
way1:
<details>
<summary>
Code
</summary>
<pre><code>a[i][j] ^= a[j][i] ^= a[i][j] ^= a[j][i];
</code></pre>
</details>
<p>way2:</p>
<details>
<summary>
Code
</summary>
<pre><code>int x = a[i][j], y = a[j][i];
x ^= y;
y ^= x;
x ^= y;
a[i][j] = x;
a[j][i] = y;
</code></pre>
</details>
<p>表达意思是一样的</p>
<p>来看dodododo的函数</p>
<p>首先我们需要对每一行都搞一个前缀和，</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j) &#123;</span><br><span class="line">      sum[i][j] = a[i][j], sum[i][j] += sum[i][j<span class="number">-1</span>];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考虑用<span class="math inline">\(l,
r\)</span>来枚举当前这个矩形的长，枚举一个<span
class="math inline">\(i\)</span>来搞矩形的宽</p>
<p>这样我们就很好的可以枚举到每一个矩形的面积</p>
<p>对于当前枚举到的矩形的面积（<span class="math inline">\(zonghe +=
sum[i][r] - sum[i][l-1]\)</span>）</p>
<p>我们再来考虑搞一个记忆化的数组<span
class="math inline">\(t\)</span>，我们给p以内的数字都打上标记-1，</p>
<p>设k为当前总和模p之后的数字，考虑<span
class="math inline">\(t[k]\)</span>是否为-1</p>
<p>如果发现为-1，那就是以前没有出现过，我们更新标记<span
class="math inline">\(t[k] =
i\)</span>,表示上一次出现模p得到k的情况是i</p>
<p>如果发现<span
class="math inline">\(t[k]\)</span>不为-1，那么会有两种情况，</p>
<p>第一种：模p为0，是p的倍数</p>
<p>第二种：以前出现过模p得到k的情况</p>
<p>所以我们对于上面两种情况都可以更新答案</p>
<p>那么如何更新答案？</p>
<p>我们定义两个数组<span class="math inline">\(f,g\)</span>其中<span
class="math inline">\(f[i]\)</span>表示<strong>紧贴</strong>着<span
class="math inline">\(i\)</span>这条直线的左边的最大矩形</p>
<p><span class="math inline">\(g[i]\)</span>表示<span
class="math inline">\(i\)</span>这条直线的右边的最大矩形（不一定紧贴）</p>
<p><span class="math inline">\(f[r]\)</span>是紧贴着<span
class="math inline">\(r\)</span>这条线的左边的矩形的最大面积，<span
class="math inline">\((r-l+1)*(i-t[k])\)</span>不就是当前枚举到的最大面积吗？</p>
<p>更新就完事了</p>
<p><span class="math inline">\(g[l]\)</span>是<span
class="math inline">\(l\)</span>这条线右边的矩形的最大面积，和f数组一样，<span
class="math inline">\((r-l+1)*(i-t[k])\)</span>更新就完事了（注意当前还是紧贴着的，而我们<span
class="math inline">\(g[i]\)</span>的定义是贴不贴着i这条线都可以，所以我们的g数组一定还会更新）</p>
<p>当我们所有矩形都查找完毕之后，考虑再次更新<span
class="math inline">\(g\)</span>数组，至于为什么更新上文提到了已经</p>
<p>务必要倒序枚举，因为你如果顺序枚举的话，当前的答案可能会受到之后的答案的影响，所以当前答案就不是最优的</p>
<p>对于整体的真正答案，<span class="math inline">\(res = max(res,
f[i]+g[i+1])\)</span>，为什么要<span
class="math inline">\(i+1\)</span>？</p>
<p>再次考虑<span class="math inline">\(g\)</span>数组定义：表示<span
class="math inline">\(i\)</span>这条直线的右边的最大矩形（不一定紧贴）</p>
<p>不一定紧贴，万一紧贴了呢？两条边有重叠不就不满足题意了吗？所以要用<span
class="math inline">\(g[i+1]\)</span>。</p>
<p><strong>PS</strong>:</p>
<p>对于为什么在“第二种：以前出现过模p得到k的情况”的时候也要更新答案？“</p>
<p>我们重新考虑题意：一块矩形的和是p的倍数，也就是模p为零</p>
<p>可以用式子表示为：</p>
<p><span class="math inline">\(s_{当前} - s_{上一次} \equiv 0 (mod
p)\)</span></p>
<p>进一步转化为：</p>
<p><span class="math inline">\(s_{当前} \equiv s_{上一次} (mod
p)\)</span></p>
<p>所以可理解为，只要上一次和这一次在模p意义的数字一样，就可以更新答案了，因为他们相减之后一定是p的倍数，可手跑几组例子</p>
<p>至此，关于“第二种：以前出现过模p得到k的情况”的时候也要更新答案？”这句话，也就不难理解了</p>
<p>给出<span class="math inline">\(youngsc\)</span>的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> R register</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,p,a[<span class="number">310</span>][<span class="number">310</span>],f[<span class="number">310</span>],g[<span class="number">310</span>],ans,t[<span class="number">60</span>],x[<span class="number">310</span>][<span class="number">310</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">in</span><span class="params">(R T&amp; a)</span></span>&#123;</span><br><span class="line">   R <span class="type">char</span> c=<span class="built_in">getchar</span>(); R T x=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>; c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">   <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+c-<span class="string">&#x27;0&#x27;</span>,c=<span class="built_in">getchar</span>();</span><br><span class="line">   a=x*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">maxx</span><span class="params">(R T&amp;a,R T b)</span></span>&#123;a&lt;b? a=b:<span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (R <span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; ++i) f[i]=g[i]=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (R <span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">      <span class="keyword">for</span> (R <span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; ++j)</span><br><span class="line">         a[i][j]=x[i][j],a[i][j]+=a[i][j<span class="number">-1</span>];</span><br><span class="line">   <span class="keyword">for</span> (R <span class="type">int</span> l=<span class="number">1</span>; l&lt;=n; ++l) &#123;</span><br><span class="line">      <span class="keyword">for</span> (R <span class="type">int</span> r=l; r&lt;=n; ++r) &#123;</span><br><span class="line">         R <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">	 <span class="keyword">for</span> (R <span class="type">int</span> i=<span class="number">1</span>; i&lt;p; ++i) t[i]=<span class="number">-1</span>;</span><br><span class="line">	 <span class="keyword">for</span> (R <span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; ++i) &#123;</span><br><span class="line">	    sum += a[i][r]-a[i][l<span class="number">-1</span>];</span><br><span class="line">	    sum %= p;</span><br><span class="line">	    <span class="keyword">if</span> (t[sum]!=<span class="number">-1</span>) <span class="built_in">maxx</span>(f[r],(r-l+<span class="number">1</span>)*(i-t[sum])),<span class="built_in">maxx</span>(g[l],(r-l+<span class="number">1</span>)*(i-t[sum]));</span><br><span class="line">	    <span class="keyword">else</span> t[sum] = i;</span><br><span class="line">	 &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (R <span class="type">int</span> i=n<span class="number">-1</span>; i; --i) <span class="built_in">maxx</span>(g[i],g[i+<span class="number">1</span>]);</span><br><span class="line">   <span class="keyword">for</span> (R <span class="type">int</span> i=<span class="number">1</span>; i&lt;n; ++i) <span class="built_in">maxx</span>(ans,f[i]+g[i+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="built_in">in</span>(n),<span class="built_in">in</span>(p);</span><br><span class="line">   <span class="keyword">for</span> (R <span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">      <span class="keyword">for</span> (R <span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; ++j)</span><br><span class="line">         <span class="built_in">in</span>(x[i][j]);</span><br><span class="line">   <span class="built_in">solve</span>();</span><br><span class="line">   <span class="keyword">for</span> (R <span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">      <span class="keyword">for</span> (R <span class="type">int</span> j=i+<span class="number">1</span>; j&lt;=n; ++j) </span><br><span class="line">	 x[i][j] ^= x[j][i] ^= x[i][j] ^= x[j][i];</span><br><span class="line">   <span class="built_in">solve</span>();</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math inline">\(7.31update\)</span></p>
<p>自己写了一遍，给出自己的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">321</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, p, res;</span><br><span class="line"><span class="type">int</span> f[N], g[N], t[N];</span><br><span class="line"><span class="type">int</span> a[N][N], sum[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">shuruyijichushihua</span><span class="params">()</span></span>&#123;</span><br><span class="line">   cin &gt;&gt; n &gt;&gt; p;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j) &#123;</span><br><span class="line">         cin &gt;&gt; a[i][j];</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dododo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) f[i] = g[i] = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j) &#123;</span><br><span class="line">          sum[i][j] = a[i][j], sum[i][j] += sum[i][j<span class="number">-1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>; l &lt;= n; ++ l) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> r = l; r &lt;= n; ++ r) &#123;</span><br><span class="line">         <span class="type">int</span> zonghe = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; p; ++ i) t[i] = <span class="number">-1</span>;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">            zonghe += sum[i][r] - sum[i][l<span class="number">-1</span>];</span><br><span class="line">	    zonghe %= p;</span><br><span class="line">            <span class="keyword">if</span> (t[zonghe] != <span class="number">-1</span>) &#123;</span><br><span class="line">	       f[r] = <span class="built_in">max</span>(f[r], (r-l+<span class="number">1</span>)*(i-t[zonghe]));</span><br><span class="line">	       g[l] = <span class="built_in">max</span>(g[l], (r-l+<span class="number">1</span>)*(i-t[zonghe]));</span><br><span class="line">            &#125; <span class="keyword">else</span> t[zonghe] = i;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = n<span class="number">-1</span>; i; -- i) g[i] = <span class="built_in">max</span>(g[i], g[i+<span class="number">1</span>]);</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i != n<span class="number">-1</span>; ++ i) res = <span class="built_in">max</span>(res, f[i]+g[i+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fanzhuan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = i+<span class="number">1</span>; j &lt;= n; ++ j) &#123;</span><br><span class="line">	 <span class="comment">// a[i][j] ^= a[j][i] ^= a[i][j] ^= a[j][i];</span></span><br><span class="line">         <span class="type">int</span> x = a[i][j], y = a[j][i];</span><br><span class="line">         x ^= y;</span><br><span class="line">	 y ^= x;</span><br><span class="line">	 x ^= y;</span><br><span class="line">	 a[i][j] = x;</span><br><span class="line">	 a[j][i] = y;</span><br><span class="line">      &#125; </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">jiejuewenti</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">dododo</span>();</span><br><span class="line">   <span class="built_in">fanzhuan</span>();</span><br><span class="line">   <span class="built_in">dododo</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">shuchudaan</span><span class="params">()</span></span>&#123;cout &lt;&lt; res;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// freopen (&quot;matrix.in&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line"><span class="comment">// freopen (&quot;matrix.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">   <span class="built_in">shuruyijichushihua</span>();</span><br><span class="line">   <span class="built_in">jiejuewenti</span>();</span><br><span class="line">   <span class="built_in">shuchudaan</span>();</span><br><span class="line">   <span class="built_in">fclose</span> (stdin), <span class="built_in">fclose</span> (stdout);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><span class="math inline">\(8.3update\)</span></p>
<p>给出<span class="math inline">\(youngsc\)</span>的题解：</p>
<hr />
<p>20pts:暴力枚举矩阵</p>
<p>50pts:可以采用正解中的部分做法优化暴力枚举的做法</p>
<p>Special
5pts:这部分其实就相当于数学题了，与形状无关，只需考虑是不是存在最大的矩阵使得面积是p的倍数就可以了</p>
<p>Special 25pts:同上</p>
<p>100 pts:</p>
<p>首先我们考虑一个弱化版的问题，如果我们只需要选择一块区域使得电脑台数最多该怎么办？</p>
<p>首先我们对矩阵中的每一行都做一个前缀和，那么对于任意单独一行的任意一个区间都可以在的时间内求出区间内的数字之和。</p>
<p>那么我们就可以先 <span class="math inline">\(a_i\)</span>
枚举所求矩阵的左右边界，当左右边界确定后，我们可以在每一行的前缀和的辅助下快速求出每一行在这个边界限制下的区间和，即将其变成一个数字，便可以将矩阵压缩为一个纵向的一维数组</p>
<p><img
src="https://pic.imgdb.cn/item/6327e39016f2c2beb13cd7ee.png" /></p>
<p>紧接着我们需要做的就是找到一个在这个一维数组中找到一个尽可能大的区间使得区间和是𝑝的倍数。我们依然考虑前缀和，定义𝑓𝑖表示数组中前𝑖项和对𝑝取模之后的值，由此我们可知，如果存在𝑥和𝑦使得𝑓𝑥=𝑓𝑦且𝑥&lt;𝑦，则由前缀和定义以及取模性质可知<span
class="math inline">\(\begin{aligned}\sum_{x+1} ^ y a_i\% p =
0\end{aligned}\)</span>，即该区间和为𝑝的倍数。那么我们可以想到对于每一个固定的𝑦，我们只需要找到最小的𝑥使得𝑥&lt;𝑦且𝑓𝑥=𝑓𝑦，那么这个区间就是以𝑦为右边界且区间和为𝑝的倍数的最大区间。而这个过程我没只需要从前往后扫一遍，维护一下对于𝑝取模后的每一个值在𝑓𝑖中出现的最早位置，同时查找一下与当前𝑓𝑖相等的最早出现的位置，二者做差即可，这个过程是𝑂(𝑛)的，这样我们便可以<span
class="math inline">\(𝑂(𝑛^3)\)</span>地求出面积最大的满足和是𝑝地倍数地矩阵。</p>
<p>当我们需要找到两个互不重叠的矩阵时该怎么办呢？首先我们可以想到，这两个矩阵地位置关系一定是上下或者左右，即必然存在一条竖直或者水平的分界线将这两个矩阵分隔开。对于左右地情况，我们维护两个数组𝑓和𝑔，𝑓𝑖表示以𝒊为右边界的符合条件的最大矩阵，𝑔𝑖表示以𝒊或者大于𝒊为左边界的符合条件的最大矩阵，注意二者定义有所不同。𝑓𝑖的求法很简单，只需要在上述预处理的过程中维护就行了，𝑔𝑖也和𝑓𝑖求法一样，只需要对这个数组再维护一下最大后缀和就可以了。有了这两个数组，我们只要枚举𝑖求出𝑓𝑖+𝑔𝑖的最大值就可以了，这个值时左右布局时候的答案，上下布局的话，我们将整个矩阵关于主对角线对称一下，然后从头开始重新进行一边这样的操作，最后两种情况取最大值。</p>
<p>End.</p>
<hr />
<h3 id="第三题">第三题</h3>
<p><img
src="https://pic.imgdb.cn/item/6327e3ae16f2c2beb13cf3ac.png" /></p>
<details>
<summary>
Sample input
</summary>
<pre><code>6 12
0 1 1 1 1 0
2 4 0
1 3 0
1 6 3
4 5 2
3 4 6
2 5 4
4 3 9
3 1 3
2 5 5
6 1 9
1 2 7
2 1 8
</code></pre>
</details>
<details>
<summary>
Sample input
</summary>
<pre><code>3 0
0 8
6 3
2 12
-1 -1
9 9
</code></pre>
</details>
<p>给出<span class="math inline">\(Youngsc\)</span>的代码：
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> R register</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> inf 200000000</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> N 50010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,x,y,z,e,h[N],t[N],f[N],ans[N][<span class="number">2</span>],dis[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">zx</span>&#123;<span class="type">int</span> v,w,pre;&#125; ed[N*<span class="number">7</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yy</span>&#123;</span><br><span class="line">   <span class="type">int</span> x,w;</span><br><span class="line">   <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> yy y) <span class="type">const</span> &#123;<span class="keyword">return</span> w&gt;y.w;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="comment">//priority_queue &lt;yy&gt; q;</span></span><br><span class="line">queue &lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">in</span><span class="params">(R T&amp; a)</span></span>&#123;</span><br><span class="line">   R <span class="type">char</span> c=<span class="built_in">getchar</span>(); R T x=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(c)) &#123;<span class="keyword">if</span> (c==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>; c=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">   <span class="keyword">while</span> (<span class="built_in">isdigit</span>(c)) x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+c-<span class="string">&#x27;0&#x27;</span>,c=<span class="built_in">getchar</span>();</span><br><span class="line">   a=x*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">maxx</span><span class="params">(R T&amp;a,R T b)</span></span>&#123;a&lt;b? a=b:<span class="number">0</span>;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">minn</span><span class="params">(R T&amp;a,R T b)</span></span>&#123;a&gt;b? a=b:<span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(R <span class="type">int</span> x,R <span class="type">int</span> y,R <span class="type">int</span> z)</span></span>&#123;</span><br><span class="line">   ed[++e] = (zx)&#123;y,z,h[x]&#125;;</span><br><span class="line">   h[x] = e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dij</span><span class="params">(R <span class="type">int</span> a,R <span class="type">int</span> b,R <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (R <span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; ++i) <span class="keyword">if</span> (t[i]==a&amp;&amp;f[i]==b) dis[i]=<span class="number">0</span>,q.<span class="built_in">push</span>(i); <span class="keyword">else</span> dis[i]=inf;</span><br><span class="line">   <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">      R <span class="type">int</span> x=q.<span class="built_in">front</span>();</span><br><span class="line">      q.<span class="built_in">pop</span>();</span><br><span class="line">      <span class="keyword">for</span> (R <span class="type">int</span> i=h[x]; i; i=ed[i].pre) &#123;</span><br><span class="line">         R <span class="type">int</span> v=ed[i].v;</span><br><span class="line">         <span class="keyword">if</span> (dis[v] &gt; dis[x]+ed[i].w) &#123;</span><br><span class="line">            dis[v]=dis[x]+ed[i].w;</span><br><span class="line">            <span class="keyword">if</span> (!vis[v]) vis[v]=<span class="number">1</span>,q.<span class="built_in">push</span>(v);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      vis[x]=<span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (R <span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; ++i) <span class="keyword">if</span> (t[i]==c&amp;&amp;f[i]!=b) <span class="built_in">minn</span>(ans[i][a^c],dis[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="built_in">in</span>(n),<span class="built_in">in</span>(m);</span><br><span class="line">   <span class="keyword">for</span> (R <span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; ++i) <span class="built_in">in</span>(t[i]),ans[i][<span class="number">0</span>]=ans[i][<span class="number">1</span>]=inf;</span><br><span class="line">   <span class="keyword">for</span> (R <span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; ++i) <span class="built_in">in</span>(x),<span class="built_in">in</span>(y),<span class="built_in">in</span>(z),<span class="built_in">add</span>(y,x,z);</span><br><span class="line">   <span class="keyword">for</span> (R <span class="type">int</span> p=<span class="number">0</span>; p&lt;=<span class="number">15</span>; ++p) &#123;</span><br><span class="line">      <span class="keyword">for</span> (R <span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; ++i) <span class="keyword">if</span> ((i&gt;&gt;p)&amp;<span class="number">1</span>) f[i]=<span class="number">1</span>; <span class="keyword">else</span> f[i]=<span class="number">0</span>;</span><br><span class="line">	 <span class="built_in">dij</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>); <span class="built_in">dij</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">	 <span class="built_in">dij</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>); <span class="built_in">dij</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">	 <span class="built_in">dij</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>); <span class="built_in">dij</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">	 <span class="built_in">dij</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>); <span class="built_in">dij</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (R <span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; ++i,<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ans[i][<span class="number">0</span>] == inf) <span class="built_in">printf</span>(<span class="string">&quot;-1 &quot;</span>); <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ans[i][<span class="number">0</span>]);</span><br><span class="line">      <span class="keyword">if</span> (ans[i][<span class="number">1</span>] == inf) <span class="built_in">printf</span>(<span class="string">&quot;-1&quot;</span>); <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans[i][<span class="number">1</span>]);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></p>
<p>下面给出自己八十分的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">66</span>, INF = <span class="number">214748364</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, a[N];</span><br><span class="line"><span class="type">int</span> vis[N], dis[N], tot[N];</span><br><span class="line"><span class="type">int</span> ans[N][<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;<span class="type">int</span> to, val, nxt;&#125;e[N]; <span class="type">int</span> cnt, head[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">jiabian</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">   ++ cnt;</span><br><span class="line">   e[cnt].to = v, e[cnt].val = c;</span><br><span class="line">   e[cnt].nxt = head[u], head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">shuruyijichushihua</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">      <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">      ans[i][<span class="number">0</span>] = ans[i][<span class="number">1</span>] = INF;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">      <span class="type">int</span> x, y, z;</span><br><span class="line">      cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">      <span class="built_in">jiabian</span> (x, y, z);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">zuiduanlusuanfa</span><span class="params">(<span class="type">int</span> t, <span class="type">int</span> b, <span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">      dis[i] = INF;</span><br><span class="line">      <span class="keyword">if</span> (a[i] == t &amp;&amp; tot[i] == b)  &#123;</span><br><span class="line">      	 q.<span class="built_in">push</span>(i);</span><br><span class="line">	 vis[i] = <span class="literal">true</span>;</span><br><span class="line">	 dis[i] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">while</span>(q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      <span class="type">int</span> x = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">      vis[x] = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = e[i].nxt) &#123;</span><br><span class="line">         <span class="type">int</span> y = e[i].to;</span><br><span class="line">	 <span class="keyword">if</span> (dis[x]+e[i].val&lt;dis[y]) &#123;</span><br><span class="line">	    dis[y] = dis[x]+e[i].val;</span><br><span class="line">	    <span class="keyword">if</span> (!vis[y]) &#123;</span><br><span class="line">	   	vis[y] = <span class="number">1</span>;</span><br><span class="line">	   	q.<span class="built_in">push</span>(y);</span><br><span class="line">	    &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[i] == s &amp;&amp; tot[i] != b) &#123;</span><br><span class="line">	 <span class="keyword">if</span> (ans[i][t^s] &gt; dis[i])</span><br><span class="line">	    ans[i][t^s] = dis[i];</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dodododo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">zuiduanlusuanfa</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="built_in">zuiduanlusuanfa</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">   <span class="built_in">zuiduanlusuanfa</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>); <span class="built_in">zuiduanlusuanfa</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">   <span class="built_in">zuiduanlusuanfa</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="built_in">zuiduanlusuanfa</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">   <span class="built_in">zuiduanlusuanfa</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>); <span class="built_in">zuiduanlusuanfa</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">jiejuewenti</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; ++ i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j) &#123;</span><br><span class="line">	 tot[j] = (j&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">dodododo</span>();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">shuchudaan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ans[i][<span class="number">0</span>] == INF) cout &lt;&lt; <span class="string">&quot;-1 &quot;</span>;</span><br><span class="line">      <span class="keyword">else</span> cout &lt;&lt; ans[i][<span class="number">0</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">      <span class="keyword">if</span> (ans[i][<span class="number">1</span>] == INF) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">      <span class="keyword">else</span> cout &lt;&lt; ans[i][<span class="number">1</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">shuruyijichushihua</span>();</span><br><span class="line">   <span class="built_in">jiejuewenti</span>();</span><br><span class="line">   <span class="built_in">shuchudaan</span>();</span><br><span class="line">   <span class="built_in">fclose</span> (stdin), <span class="built_in">fclose</span> (stdout);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
<p>给出<span class="math inline">\(youngsc\)</span>的题解：</p>
<hr />
<p>可以创建一个虚点A，A指向所有A党城市，边权为0，其它正常边反着连，从这个虚点A跑一个最短路dij，到其它B党城市的距离，就是B党城市到最近A党城市的距离。</p>
<p>求B党城市到A党同理。</p>
<p>但是你发现他还要求你求出友好城市的距离，由于不能把自己算进去，所以这个不能直接搞出来。注意到n只开到五万而时限有2秒，所以两个log没问题。注意到每个点都有个编号，我们考虑按位选点进行多源最短路。还是反着建边，因为正着建边的最短路是一到多，而反着建边的最短路就是多到一的最短了，符合题目要求。</p>
<p>例如，将第?位为0的所有A阵营的点作为源扔进去跑最短路（可以理解为从一个超级源向这些点连了长度为0的边）然后用它更新所有第?位为1的点。这样能保证不会用自己求自己。</p>
<p>复杂度为<span class="math inline">\(O(nlog^2n)\)</span>，其中<span
class="math inline">\(nlogn\)</span>是<span
class="math inline">\(dij\)</span>，另外<span
class="math inline">\(logn\)</span>是按位给点分拨</p>
<p>End.</p>
<hr />
<hr />
<h1 id="下午">下午</h1>
<p>讲了分块莫队</p>
<p>分块大致思想：说白了就是一种暴力，一种温文尔雅的暴力</p>
<p>我们正常对序列进行某种操作，假如你不会什么线段树猫树树状数组，反正一堆树与数</p>
<p>我们貌似就只能<span
class="math inline">\(O(n^2)\)</span>了，给你个<span
class="math inline">\(1e5\)</span>的数据不<span
class="math inline">\(T\)</span>飞才怪</p>
<p>我们考虑如何来优化，首先对一个整体区间进行分块，块长<span
class="math inline">\(len\)</span> = <span
class="math inline">\(\sqrt{n}\)</span>，所以块的数量为<span
class="math inline">\(\sqrt{n}\)</span></p>
<p>对于一个极大的区间，我们将他们分块对待，对左半部分的残缺，我们暴力修改</p>
<p>对于右半部分的残缺，我们暴力修改，而对于中间部分的整块，我们特殊对待，打上<span
class="math inline">\(tag\)</span></p>
<p>本质上是基于暴力的，所以很好理解</p>
<p>给出大致代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">xiugai</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (pos[L] == pos[R]) &#123;</span><br><span class="line">      <span class="comment">//do do do..</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = L; i &lt;= pos[L]*len; ++ i) <span class="comment">//do do do...</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = pos[L]+<span class="number">1</span>; i &lt;= pos[R]<span class="number">-1</span>; ++ i)<span class="comment">//do do do...</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = (pos[R]<span class="number">-1</span>)*len+<span class="number">1</span>; i &lt;= R; ++ i)<span class="comment">//do do do...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">chaxun</span><span class="params">(<span class="type">int</span> now)</span> </span>&#123;cout &lt;&lt; a[now]+tag[pos[now]];&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   cin &gt;&gt; n;</span><br><span class="line">   len = <span class="built_in">sqrt</span>(n);</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">      cin &gt;&gt; a[i];</span><br><span class="line">      pos[i] = (i<span class="number">-1</span>)/len+<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">xiugai</span>(l, r, c);</span><br><span class="line">   <span class="built_in">chaxun</span>(x);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析代码：</p>
<p>修改的时候首先对于两个端点，如果发现首尾在一个块内，暴力干就完了</p>
<p>如果不在一个块内，左-中-右，开始干，期间维护标记啥的</p>
<p>查询的时候输出要查询的键值，然后加上标记之类的</p>
<p>分块例题：数列分块入门<span class="math inline">\(1\)</span>~<span
class="math inline">\(9\)</span></p>
<p>下面来例个分析：</p>
<h3 id="第一个">第一个</h3>
<p><a href="https://loj.ac/problem/6277">click</a></p>
<p>区间加，单点查，秒切</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 600000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">signed</span> n, len;</span><br><span class="line"><span class="type">int</span> pos[N], tag[N], a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span> <span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (pos[L] == pos[R]) &#123;</span><br><span class="line">      <span class="keyword">for</span> ( <span class="type">int</span> i = L;i&lt;=R;++i) a[i] += val;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> ( <span class="type">int</span> i = L;i&lt;=pos[L]*len;++i) a[i] += val;</span><br><span class="line">   <span class="keyword">for</span> ( <span class="type">int</span> i = pos[L]+<span class="number">1</span>;i&lt;=pos[R]<span class="number">-1</span>;++i) tag[i] += val;</span><br><span class="line">   <span class="keyword">for</span> ( <span class="type">int</span> i = (pos[R]<span class="number">-1</span>)*len+<span class="number">1</span>;i&lt;=R;++i) a[i] += val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">   n = <span class="built_in">Read</span> (), len = <span class="built_in">sqrt</span>(n);</span><br><span class="line">   <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;++i) a[i] = <span class="built_in">Read</span> (), pos[i] = (i - <span class="number">1</span>)/len + <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">      <span class="type">int</span> opt, l, r, c;</span><br><span class="line">      opt = <span class="built_in">Read</span> (), l = <span class="built_in">Read</span> (), r = <span class="built_in">Read</span> (), c = <span class="built_in">Read</span> ();</span><br><span class="line">      <span class="keyword">if</span> (!opt) <span class="built_in">add</span> (l, r, c);</span><br><span class="line">      <span class="keyword">else</span> <span class="built_in">Put</span> (a[r] + tag[pos[r]]);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第二个">第二个</h3>
<p><a href="https://loj.ac/problem/6278">click</a></p>
<p>我们考虑对原数组再开一个新数组来维护，</p>
<p><strong>查询的时候</strong></p>
<p>对于整块，我们给他排序，然后在排完序的序列里面二分查找小于val的数的个数</p>
<p>对于散块，暴力找</p>
<p><strong>修改的时候</strong></p>
<p>对于整块，我们给原数组和排完序之后的数组都要加上tag标记</p>
<p>对于散块，暴力加，加完之后，再排完序赋给排序数组</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, len, a[N];</span><br><span class="line"><span class="type">int</span> pos[N], paixu[N];</span><br><span class="line"><span class="type">int</span> tag[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">shuruyijichushihua</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    len = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        paixu[i] = a[i];</span><br><span class="line">        pos[i] = (i - <span class="number">1</span>) / len + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= pos[n]; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> s = (i - <span class="number">1</span>) * len + <span class="number">1</span>, t = i * len;</span><br><span class="line">        <span class="built_in">sort</span>(paixu + s, paixu + t + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> now = (pos[n] - <span class="number">1</span>) * len + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">sort</span>(paixu + now, paixu + n + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">zaimougequjianjiashangyigeshu</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> s = <span class="number">0</span>, t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (pos[L] == pos[R]) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = L; i &lt;= R; ++i) a[i] += val;</span><br><span class="line">        s = (pos[L] - <span class="number">1</span>) * len + <span class="number">1</span>, t = pos[L] * len;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = s; i &lt;= t; ++i) paixu[i] = a[i];</span><br><span class="line">        <span class="built_in">sort</span>(paixu + s, paixu + t + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = L; i &lt;= pos[L] * len; ++i) a[i] += val;</span><br><span class="line">    s = (pos[L] - <span class="number">1</span>) * len + <span class="number">1</span>, t = (pos[L] * len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = s; i &lt;= t; ++i) paixu[i] = a[i];</span><br><span class="line">    <span class="built_in">sort</span>(paixu + s, paixu + t + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = pos[L] + <span class="number">1</span>; i &lt;= pos[R] - <span class="number">1</span>; ++i) tag[i] += val;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = (pos[R] - <span class="number">1</span>) * len + <span class="number">1</span>; i &lt;= R; ++i) a[i] += val;</span><br><span class="line">    s = (pos[R] - <span class="number">1</span>) * len + <span class="number">1</span>, t = pos[R] * len;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = s; i &lt;= t; ++i) paixu[i] = a[i];</span><br><span class="line">    <span class="built_in">sort</span>(paixu + s, paixu + t + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">xiaoyumougeshudegeshu</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> who)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">res</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (pos[L] == pos[R]) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = L; i &lt;= R; ++i)</span><br><span class="line">            <span class="keyword">if</span> (a[i] + tag[pos[R]] &lt; who)</span><br><span class="line">                ++res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = L; i &lt;= pos[L] * len; ++i)</span><br><span class="line">        <span class="keyword">if</span> (a[i] + tag[pos[L]] &lt; who)</span><br><span class="line">            ++res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = pos[L] + <span class="number">1</span>; i &lt;= pos[R] - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> now = (i - <span class="number">1</span>) * len + <span class="number">1</span>, to = i * len;</span><br><span class="line">        <span class="type">int</span> chazhao = <span class="built_in">lower_bound</span>(paixu + now, paixu + to + <span class="number">1</span>, (who - tag[i])) - paixu;</span><br><span class="line">        res += chazhao - now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = (pos[R] - <span class="number">1</span>) * len + <span class="number">1</span>; i &lt;= R; ++i)</span><br><span class="line">        <span class="keyword">if</span> (a[i] + tag[pos[R]] &lt; who)</span><br><span class="line">            ++res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">jiejuewentiyijishuchu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> opt, l, r, c;</span><br><span class="line">        cin &gt;&gt; opt &gt;&gt; l &gt;&gt; r &gt;&gt; c;</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">zaimougequjianjiashangyigeshu</span>(l, r, c);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="built_in">xiaoyumougeshudegeshu</span>(l, r, c * c) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">shuruyijichushihua</span>();</span><br><span class="line">    <span class="built_in">jiejuewentiyijishuchu</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123; ; &#125;</span><br></pre></td></tr></table></figure>
<p>自己写了一遍，坑很多，比如，我们排序的时候的数组，还有我们<strong>必须给原数组修改，然后赋值给那一段区间，再排序</strong>
建议以后把每个块的左右端点都开个数组就好了</p>
<h3 id="第三个">第三个</h3>
<p><a href="https://loj.ac/problem/6279">click</a></p>
<p>前驱：比ta小的最大的元素</p>
<p>感觉和第二个一样，维护两个数组就好</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, len, a[N];</span><br><span class="line"><span class="type">int</span> pos[N], paixu[N];</span><br><span class="line"><span class="type">int</span> tag[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">shuruyijichushihua</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   cin &gt;&gt; n;</span><br><span class="line">   len = <span class="built_in">sqrt</span>(n);</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">      cin &gt;&gt; a[i];</span><br><span class="line">      paixu[i] = a[i];</span><br><span class="line">      pos[i] = (i - <span class="number">1</span>) / len + <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; pos[n]; ++i) &#123;</span><br><span class="line">      <span class="type">int</span> s = (i - <span class="number">1</span>) * len + <span class="number">1</span>, t = i * len;</span><br><span class="line">      <span class="built_in">sort</span>(paixu + s, paixu + t + <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">int</span> now = (pos[n] - <span class="number">1</span>) * len + <span class="number">1</span>;</span><br><span class="line">   <span class="built_in">sort</span>(paixu + now, paixu + n + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">zaimougequjianjiashangyigeshu</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">   <span class="type">int</span> s = <span class="number">0</span>, t = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">if</span> (pos[L] == pos[R]) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = L; i &lt;= R; ++i) a[i] += val;</span><br><span class="line">      s = (pos[L] - <span class="number">1</span>) * len + <span class="number">1</span>, t = pos[L] * len;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = s; i &lt;= t; ++i) paixu[i] = a[i];</span><br><span class="line">      <span class="built_in">sort</span>(paixu + s, paixu + t + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = L; i &lt;= pos[L] * len; ++i) a[i] += val;</span><br><span class="line">   s = (pos[L] - <span class="number">1</span>) * len + <span class="number">1</span>, t = (pos[L] * len);</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = s; i &lt;= t; ++i) paixu[i] = a[i];</span><br><span class="line">   <span class="built_in">sort</span>(paixu + s, paixu + t + <span class="number">1</span>);</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = pos[L] + <span class="number">1</span>; i &lt;= pos[R] - <span class="number">1</span>; ++i) tag[i] += val;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = (pos[R] - <span class="number">1</span>) * len + <span class="number">1</span>; i &lt;= R; ++i) a[i] += val;</span><br><span class="line">   s = (pos[R] - <span class="number">1</span>) * len + <span class="number">1</span>, t = pos[R] * len;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = s; i &lt;= t; ++i) paixu[i] = a[i];</span><br><span class="line">   <span class="built_in">sort</span>(paixu + s, paixu + t + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">xiaoyumougeshudegeshu</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> who)</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="type">int</span> <span class="title">res</span><span class="params">(<span class="number">-1</span>)</span>, <span class="title">s</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">t</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">   <span class="keyword">if</span> (pos[L] == pos[R]) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = L; i &lt;= R; ++i)</span><br><span class="line">         <span class="keyword">if</span> (a[i]+tag[pos[L]] &lt; who) res = <span class="built_in">max</span>(res, a[i]+tag[pos[L]]);</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line">   s = L, t = pos[L]*len;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = s; i &lt;= t; ++i)</span><br><span class="line">      <span class="keyword">if</span> (a[i]+tag[pos[L]] &lt; who) res = <span class="built_in">max</span>(res, a[i]+tag[pos[L]]);</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = pos[L] + <span class="number">1</span>; i &lt;= pos[R] - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">      s = (i - <span class="number">1</span>) * len + <span class="number">1</span>, t = i * len;</span><br><span class="line">      <span class="type">int</span> now = <span class="built_in">lower_bound</span>(paixu+s, paixu+t+<span class="number">1</span>, (who-tag[i])) - paixu;</span><br><span class="line">      -- now;</span><br><span class="line">      res = (now==s<span class="number">-1</span>)?res:(res&gt;paixu[now]+tag[i])?res:paixu[now]+tag[i];</span><br><span class="line">   &#125;</span><br><span class="line">   s = (pos[R]<span class="number">-1</span>)*len+<span class="number">1</span>, t = R;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = s; i &lt;= t; ++i)</span><br><span class="line">      <span class="keyword">if</span> (a[i]+tag[pos[R]] &lt; who) res = <span class="built_in">max</span>(res, a[i]+tag[pos[R]]);</span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">jiejuewentiyijishuchu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">      <span class="type">int</span> opt, l, r, c;</span><br><span class="line">      cin &gt;&gt; opt &gt;&gt; l &gt;&gt; r &gt;&gt; c;</span><br><span class="line">      <span class="keyword">if</span> (opt == <span class="number">0</span>) <span class="built_in">zaimougequjianjiashangyigeshu</span>(l, r, c);</span><br><span class="line">      <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">xiaoyumougeshudegeshu</span>(l, r, c) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">shuruyijichushihua</span>();</span><br><span class="line">   <span class="built_in">jiejuewentiyijishuchu</span>();</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123; ; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><span class="math inline">\(8.2update\)</span>:</p>
<p>自己打了一遍，靠，真的细节真多：</p>
<p>1.在块里面更新答案的时候，必须加上tag标记</p>
<p>2.<span class="math inline">\(sort\)</span>，<span
class="math inline">\(lower\)</span>_<span
class="math inline">\(bound\)</span>都是左闭右开的</p>
<h3 id="第四个">第四个</h3>
<p><a href="https://loj.ac/problem/6280">click</a></p>
<p>一眼板子，模的时候最后进行</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="comment">// #define debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, len, a[N];</span><br><span class="line"><span class="type">int</span> pos[N], sum[N], tag[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">   <span class="type">int</span> x = pos[L], y = pos[R];</span><br><span class="line">   <span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = L; i &lt;= R; ++ i) a[i] += val;</span><br><span class="line">      sum[x] += val*(R-L+<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = L; i &lt;= x*len; ++ i) a[i] += val;</span><br><span class="line">   sum[x] += val*(x*len-L+<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = x+<span class="number">1</span>; i &lt;= y<span class="number">-1</span>; ++ i) tag[i] += val;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = (y<span class="number">-1</span>)*len+<span class="number">1</span>; i &lt;= R; ++ i) a[i] += val;</span><br><span class="line">   sum[y] += val*(R-((y<span class="number">-1</span>)*len+<span class="number">1</span>)+<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">get_sum</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> mod)</span> </span>&#123;</span><br><span class="line">   <span class="type">int</span> x = pos[L], y = pos[R], <span class="built_in">res</span>(<span class="number">0</span>);</span><br><span class="line">   <span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">res</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = L; i &lt;= R; ++ i) res += (tag[pos[i]]+a[i]);</span><br><span class="line">      <span class="keyword">return</span> res%mod;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = L; i &lt;= x*len; ++ i) res += (tag[pos[i]]+a[i]);</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = x+<span class="number">1</span>; i &lt;= y<span class="number">-1</span>; ++ i) res += sum[i] + tag[i]*len;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = (y<span class="number">-1</span>)*len+<span class="number">1</span>; i &lt;= R; ++ i) res += (tag[pos[i]]+a[i]);</span><br><span class="line">   <span class="keyword">return</span> res%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">shuru</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   cin &gt;&gt; n;</span><br><span class="line">   len = <span class="built_in">sqrt</span>(n);</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">      <span class="built_in">scanf</span> (<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">      pos[i] = (i<span class="number">-1</span>)/len+<span class="number">1</span>;</span><br><span class="line">      sum[pos[i]] += a[i];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">jiejue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">      <span class="type">int</span> opt, l, r, c;</span><br><span class="line">      <span class="built_in">scanf</span> (<span class="string">&quot;%lld%lld%lld%lld&quot;</span>, &amp;opt, &amp;l, &amp;r, &amp;c);</span><br><span class="line">      <span class="keyword">if</span> (!opt) <span class="built_in">add</span>(l, r, c);</span><br><span class="line">      <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">get_sum</span>(l, r, c+<span class="number">1</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">shuru</span>();</span><br><span class="line">   <span class="built_in">jiejue</span>();</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
<p><span class="math inline">\(8.2update\)</span>:</p>
<p>时隔半年，重新手写了一遍，发现几个问题：</p>
<p>1.在区间修改的时候，<span
class="math inline">\(tag\)</span>数组进行维护，但是不用动<span
class="math inline">\(sum\)</span>数组（维护整块的时候）</p>
<p>2.查询整块的时候，输出<span
class="math inline">\(sum+tag*len\)</span></p>
<h3 id="第五个">第五个</h3>
<p><a href="https://loj.ac/problem/6281">click</a></p>
<p>显然，一个数开方不会超过六次就会变成1</p>
<p>如果每次区间开方的数不涉及完整块，意味着不超过<span
class="math inline">\(2\sqrt{n}\)</span>个元素，直接暴力</p>
<p>如果涉及了完整的块，这些块经过几次操作之后，都会变成1，所以我们需要记录这些块经过每次操作之后，区间里面是不是都变成了1，如果是的话，那么我们以后需要查询这些块，只需要加上<span
class="math inline">\(1*len\)</span>就可以了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// by hzw</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 998244353</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pi acos(-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">ll <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,blo;</span><br><span class="line"><span class="type">int</span> bl[<span class="number">50005</span>];</span><br><span class="line"><span class="type">int</span> v[<span class="number">50005</span>],sum[<span class="number">50005</span>],flag[<span class="number">50005</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve_sqrt</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag[x])<span class="keyword">return</span>;</span><br><span class="line">    flag[x]=<span class="number">1</span>;</span><br><span class="line">    sum[x]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=(x<span class="number">-1</span>)*blo+<span class="number">1</span>;i&lt;=x*blo;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v[i]=<span class="built_in">sqrt</span>(v[i]),sum[x]+=v[i];</span><br><span class="line">        <span class="keyword">if</span>(v[i]&gt;<span class="number">1</span>)flag[x]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=a;i&lt;=<span class="built_in">min</span>(bl[a]*blo,b);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum[bl[a]]-=v[i];</span><br><span class="line">        v[i]=<span class="built_in">sqrt</span>(v[i]);</span><br><span class="line">        sum[bl[a]]+=v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(bl[a]!=bl[b])</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=(bl[b]<span class="number">-1</span>)*blo+<span class="number">1</span>;i&lt;=b;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum[bl[b]]-=v[i];</span><br><span class="line">            v[i]=<span class="built_in">sqrt</span>(v[i]);</span><br><span class="line">            sum[bl[b]]+=v[i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=bl[a]+<span class="number">1</span>;i&lt;=bl[b]<span class="number">-1</span>;i++)</span><br><span class="line">        <span class="built_in">solve_sqrt</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=a;i&lt;=<span class="built_in">min</span>(bl[a]*blo,b);i++)</span><br><span class="line">        ans+=v[i];</span><br><span class="line">    <span class="keyword">if</span>(bl[a]!=bl[b])</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=(bl[b]<span class="number">-1</span>)*blo+<span class="number">1</span>;i&lt;=b;i++)</span><br><span class="line">            ans+=v[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=bl[a]+<span class="number">1</span>;i&lt;=bl[b]<span class="number">-1</span>;i++)</span><br><span class="line">        ans+=sum[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>();blo=<span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)v[i]=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        bl[i]=(i<span class="number">-1</span>)/blo+<span class="number">1</span>;</span><br><span class="line">        sum[bl[i]]+=v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> f=<span class="built_in">read</span>(),a=<span class="built_in">read</span>(),b=<span class="built_in">read</span>(),c=<span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span>(f==<span class="number">0</span>)<span class="built_in">add</span>(a,b,c);</span><br><span class="line">        <span class="keyword">if</span>(f==<span class="number">1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query</span>(a,b));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第六个">第六个</h3>
<p><a href="https://loj.ac/problem/6282">click</a></p>
<p>考虑，插入一个数的话，分块需要<span
class="math inline">\(O(n)\)</span>，而对于链表来说的话，只需要<span
class="math inline">\(O(1)\)</span></p>
<p>考虑，查询一个数的话，分块只需要<span
class="math inline">\(O(1)\)</span>，而对于链表来说的话，需要<span
class="math inline">\(O(n)\)</span></p>
<p>考虑，将分块与链表结合起来，----&gt;块状链表</p>
<p>块状链表应该至少支持：分裂、插入、查找。
什么是分裂？分裂就是分裂一个<span class="math inline">\(node\)</span>
，变成两个小的 <span class="math inline">\(node\)</span> ，以保证每个
<span class="math inline">\(node\)</span> 的大小都接近 <span
class="math inline">\(O(\sqrt{n})\)</span>（否则可能退化成普通数组）。当一个
<span class="math inline">\(node\)</span>的大小超过<span
class="math inline">\(2*\sqrt{n}\)</span> 时执行分裂操作。</p>
<p>块状链表即插入<span
class="math inline">\(O(\sqrt{n})\)</span>，查询<span
class="math inline">\(O(\sqrt{n})\)</span>，将链表与分块的优缺点融合了一下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">  node* nxt;</span><br><span class="line">  <span class="type">int</span> size;</span><br><span class="line">  <span class="type">char</span> d[(sqn &lt;&lt; <span class="number">1</span>) + <span class="number">5</span>];</span><br><span class="line">  <span class="built_in">node</span>() &#123; size = <span class="number">0</span>, nxt = <span class="literal">NULL</span>, <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="built_in">sizeof</span>(d)); &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">pb</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123; d[size++] = c; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>查询的时候，挨个块的找，最多<span
class="math inline">\(O(\sqrt{n})\)</span>，插入的时候<span
class="math inline">\(O(\sqrt{n})\)</span></p>
<p>分裂操作怎么做呢？先新建一个节点，再把被分裂的节点的后<span
class="math inline">\(O(\sqrt{n})\)</span>个值复制到新节点，然后把被分裂的节点的后<span
class="math inline">\(O(\sqrt{n})\)</span>个值删掉（ <span
class="math inline">\(--
size\)</span>），最后把新节点插入到被分裂节点的后面即可</p>
<p>块状链表的所有操作的复杂度都是<span
class="math inline">\(O(\sqrt{n})\)</span>的。</p>
<h3 id="第七个">第七个</h3>
<p><a href="https://loj.ac/problem/6283">click</a></p>
<p>一眼线段树，维护一个乘法标记和一个加法标记，下放标记的时候先下放乘法再下放加法</p>
<p>线段树会写，分块不会写</p>
<p>若当前的一个块乘以<span class="math inline">\(m_1\)</span>后加上<span
class="math inline">\(a_1\)</span>，这时进行一个乘<span
class="math inline">\(m_2\)</span>的操作，则原来的标记变成<span
class="math inline">\(m_1*m_2\)</span>，<span
class="math inline">\(a_1*m_2\)</span></p>
<p>若当前的一个块乘以<span class="math inline">\(m_1\)</span>后加上<span
class="math inline">\(a_1\)</span>，这时进行一个加<span
class="math inline">\(a_2\)</span>的操作，则原来的标记变成<span
class="math inline">\(m_1\)</span>，<span
class="math inline">\(a_1+a_1\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//by hzw</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 10007</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pi acos(-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">ll <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,blo;</span><br><span class="line"><span class="type">int</span> v[<span class="number">100005</span>],bl[<span class="number">100005</span>],atag[<span class="number">1005</span>],mtag[<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=(x<span class="number">-1</span>)*blo+<span class="number">1</span>;i&lt;=<span class="built_in">min</span>(n,x*blo);i++)</span><br><span class="line">        v[i]=(v[i]*mtag[x]+atag[x])%mod;</span><br><span class="line">    atag[x]=<span class="number">0</span>;mtag[x]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> f,<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">reset</span>(bl[a]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=a;i&lt;=<span class="built_in">min</span>(bl[a]*blo,b);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(f==<span class="number">0</span>)v[i]+=c;</span><br><span class="line">        <span class="keyword">else</span> v[i]*=c;</span><br><span class="line">        v[i]%=mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(bl[a]!=bl[b])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">reset</span>(bl[b]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=(bl[b]<span class="number">-1</span>)*blo+<span class="number">1</span>;i&lt;=b;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(f==<span class="number">0</span>)v[i]+=c;</span><br><span class="line">            <span class="keyword">else</span> v[i]*=c;</span><br><span class="line">            v[i]%=mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=bl[a]+<span class="number">1</span>;i&lt;=bl[b]<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(f==<span class="number">0</span>)atag[i]=(atag[i]+c)%mod;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            atag[i]=(atag[i]*c)%mod;</span><br><span class="line">            mtag[i]=(mtag[i]*c)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>();blo=<span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)v[i]=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)bl[i]=(i<span class="number">-1</span>)/blo+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=bl[n];i++)mtag[i]=<span class="number">1</span>;        </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> f=<span class="built_in">read</span>(),a=<span class="built_in">read</span>(),b=<span class="built_in">read</span>(),c=<span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span>(f==<span class="number">2</span>)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,(v[b]*mtag[bl[b]]+atag[bl[b]])%mod);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">solve</span>(f,a,b,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第八个">第八个</h3>
<p><a href="https://loj.ac/problem/6284">click</a></p>
<p>区间变成问题，对于一个区间，我们维护一个标记，如果一个区间的标记是c，我们之间不查询这一段，直接加上这一段的长度就可以了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//by hzw</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 998244353</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pi acos(-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">ll <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,blo;</span><br><span class="line"><span class="type">int</span> v[<span class="number">100005</span>],bl[<span class="number">100005</span>],tag[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tag[x]==<span class="number">-1</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=(x<span class="number">-1</span>)*blo+<span class="number">1</span>;i&lt;=blo*x;i++)</span><br><span class="line">        v[i]=tag[x];</span><br><span class="line">    tag[x]=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">reset</span>(bl[a]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=a;i&lt;=<span class="built_in">min</span>(bl[a]*blo,b);i++)</span><br><span class="line">        <span class="keyword">if</span>(v[i]!=c)v[i]=c;</span><br><span class="line">        <span class="keyword">else</span> ans++;</span><br><span class="line">    <span class="keyword">if</span>(bl[a]!=bl[b])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">reset</span>(bl[b]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=(bl[b]<span class="number">-1</span>)*blo+<span class="number">1</span>;i&lt;=b;i++)</span><br><span class="line">            <span class="keyword">if</span>(v[i]!=c)v[i]=c;</span><br><span class="line">            <span class="keyword">else</span> ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=bl[a]+<span class="number">1</span>;i&lt;=bl[b]<span class="number">-1</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(tag[i]!=<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(tag[i]!=c)tag[i]=c;</span><br><span class="line">            <span class="keyword">else</span> ans+=blo;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=(i<span class="number">-1</span>)*blo+<span class="number">1</span>;j&lt;=i*blo;j++)</span><br><span class="line">                <span class="keyword">if</span>(v[j]!=c)v[j]=c;</span><br><span class="line">                <span class="keyword">else</span> ans++;</span><br><span class="line">            tag[i]=c;</span><br><span class="line">        &#125;    </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(tag,<span class="number">-1</span>,<span class="built_in">sizeof</span>(tag));</span><br><span class="line">    n=<span class="built_in">read</span>();blo=<span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)v[i]=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)bl[i]=(i<span class="number">-1</span>)/blo+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a=<span class="built_in">read</span>(),b=<span class="built_in">read</span>(),c=<span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">solve</span>(a,b,c));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第九个">第九个</h3>
<p><a href="https://loj.ac/problem/6285">click</a>&amp;&amp;<a
href="https://www.luogu.com.cn/problem/P4168">click</a></p>
<p>找众数问题，自古以来众数就是个毒瘤</p>
<p>考虑答案的来源：1.所有完整快的最小众数。2.来自不完整块的某个数</p>
<p>我们可以预先处理好<span class="math inline">\(i_块\)</span>到<span
class="math inline">\(j_块\)</span>的所有数的最小众数，以便处理第一种情况的时候<span
class="math inline">\(O(1)\)</span>得到</p>
<p>我们定义两个数组：</p>
<p><span class="math inline">\(p[i][j]\)</span>：表示<span
class="math inline">\(i_块\)</span>到<span
class="math inline">\(j_块\)</span>的所有数的最小众数</p>
<p><span class="math inline">\(s[i][j]\)</span>：类似前缀和，表示前<span
class="math inline">\(i\)</span>个块中<span
class="math inline">\(j\)</span>（离散化）出现了几次</p>
<p>对于<span
class="math inline">\(s\)</span>数组，我们枚举到每一个块的时候，都要从前往后扫一遍，时间复杂度<span
class="math inline">\(O(n\sqrt{n})\)</span></p>
<p>对于<span class="math inline">\(p\)</span>数组，我们肯定要枚举<span
class="math inline">\(n^2\)</span>,然后在每一个块内，我们都要去判断，所以总复杂度：<span
class="math inline">\(O(\sqrt{n}\sqrt{n}\sqrt{n})\)</span>，总时间复杂度为<span
class="math inline">\(O(n\sqrt{n})\)</span></p>
<p>考虑<span class="math inline">\(p, s\)</span>有何用处，对于一个<span
class="math inline">\([l, r]\)</span>，设<span
class="math inline">\(l\)</span>在<span
class="math inline">\(posl\)</span>块中，设<span
class="math inline">\(r\)</span>在<span
class="math inline">\(posr\)</span>块中</p>
<p>此时我们会出现两种情况：</p>
<ol type="1">
<li><span class="math inline">\(posr - posl \leq 1\)</span>
此时暴力修改就可以了，复杂度<span
class="math inline">\(O(\sqrt{n})\)</span></li>
<li><span class="math inline">\(posr - posl \geq 2\)</span>如图：<img
src="https://cdn.luogu.com.cn/upload/pic/33249.png" alt="img" /></li>
</ol>
<p>红线是<span class="math inline">\(l\)</span>, 蓝线是<span
class="math inline">\(r\)</span>，绿线就是他们之间的块</p>
<p>所以此时的<span class="math inline">\(ans \in 元素_{yellow} \bigcup
众数_{green}\)</span></p>
<p>显然，对于绿线中的众数，我们是提前预处理出来的，而对于黄线中每个元素出现的次数就是你左右两边暴力求出来的，加上绿线中这个元素出现的个数</p>
<p>这样的话，对于每次询问，我们就可以在<span
class="math inline">\(O(\sqrt{n})\)</span>的时间内求出答案（不考虑预处理）</p>
<p><strong>我的分析已经超出了LOJ那道题，那道题并没有强制要求在线，莫队就可以完美解决那个问题，更多的分析，是针对蒲公英那道题</strong></p>
<p><strong>一般对于代码，我都会手动格式化，但是hzw的代码，我始终怀着一种敬畏尊重而神圣的感情，我没有修改他的码风</strong></p>
<p><strong>因为我知道他一定会是我的学长</strong></p>
<hr />
<p>通过学习数列简单分块，我们可以总结出，我们对于一个分块要维护什么：</p>
<ol type="1">
<li>不完整的块怎么处理？</li>
<li>完整的块怎么处理？</li>
<li>预处理什么？</li>
</ol>
<p>下面是莫队的相关操蛋操作</p>
<p>给出几个例题</p>
<h3 id="项链">项链</h3>
<p><a href="https://www.luogu.com.cn/problem/P1972">click</a></p>
<p>莫队入门板子题正解是离线树状数组</p>
<h3 id="小b">小B</h3>
<p><a href="https://www.luogu.com.cn/problem/P2709">click</a></p>
<p>遇到一个数，先减去他的贡献，在加上他的贡献</p>
<h3 id="小z">小Z</h3>
<p><a href="https://www.luogu.com.cn/problem/P1494">click</a></p>
<p>埋坑....,我也不知道为什么我的代码能过</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">By TheStars</span></span><br><span class="line"><span class="comment">Time:2020.02.02</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500009</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//燕园情 千千结 </span></span><br><span class="line"><span class="type">int</span> n, m, col[N], ans[N][<span class="number">3</span>], cnt[N];</span><br><span class="line"><span class="type">int</span> fz, fm, block, len;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">   <span class="type">int</span> l, r;</span><br><span class="line">   <span class="type">int</span> ord;</span><br><span class="line">&#125;e[N]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">cmp</span> <span class="params">(Node x, Node y)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (x.l/block == y.l/block) <span class="keyword">return</span> x.r &lt; y.r;</span><br><span class="line">   <span class="keyword">return</span> x.l &lt; y.l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span> <span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">   fz += cnt[x];</span><br><span class="line">   ++ cnt[x];</span><br><span class="line">   fm += len;</span><br><span class="line">   ++ len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">del</span> <span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">   -- cnt[x];</span><br><span class="line">   fz -= cnt[x];</span><br><span class="line">   -- len;</span><br><span class="line">   fm -= len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">gcd</span> <span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;<span class="keyword">return</span> !y ? x : <span class="built_in">gcd</span>(y, x%y);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="type">int</span> <span class="title">l</span><span class="params">(<span class="number">1</span>)</span>, <span class="title">r</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">   <span class="built_in">scanf</span> (<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">   block = n/<span class="built_in">sqrt</span>(m);</span><br><span class="line">   <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;++i) <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;col[i]);</span><br><span class="line">   <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">1</span>;i&lt;=m;++i) <span class="built_in">scanf</span> (<span class="string">&quot;%d%d&quot;</span>, &amp;e[i].l, &amp;e[i].r), e[i].ord = i;</span><br><span class="line">   <span class="built_in">sort</span> (e+<span class="number">1</span>, e+n+<span class="number">1</span>, cmp);</span><br><span class="line">   <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">1</span>;i&lt;=m;++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (e[i].l == e[i].r) &#123;</span><br><span class="line">         ans[e[i].ord][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	 ans[e[i].ord][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	 <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (l &gt; e[i].l) <span class="built_in">add</span> (col[--l]);</span><br><span class="line">      <span class="keyword">while</span> (r &gt; e[i].r) <span class="built_in">del</span> (col[r--]);</span><br><span class="line">      <span class="keyword">while</span> (l &lt; e[i].l) <span class="built_in">del</span> (col[l++]);</span><br><span class="line">      <span class="keyword">while</span> (r &lt; e[i].r) <span class="built_in">add</span> (col[++r]);</span><br><span class="line">      <span class="type">int</span> g = <span class="built_in">gcd</span>(fz, fm);</span><br><span class="line">      ans[e[i].ord][<span class="number">0</span>] = fz/g;</span><br><span class="line">      ans[e[i].ord][<span class="number">1</span>] = fm/g;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">1</span>;i&lt;=m;++i) cout &lt;&lt; ans[i][<span class="number">0</span>] &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; ans[i][<span class="number">1</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="待修改莫队">待修改莫队</h3>
<p><a href="https://www.luogu.com.cn/problem/P1903">click</a></p>
<p>正常莫队都是离线的，不支持修改，对于这种待修改的，我们需要在原来<span
class="math inline">\(l, r\)</span>的基础上加上一维<span
class="math inline">\(t\)</span></p>
<p>称为<strong>时间戳</strong>，查询操作的时间戳，沿用最近一次修改的时间戳</p>
<p>跑主算法时定义当前时间戳为<span
class="math inline">\(t\)</span>，对于每个查询操作，如果当前时间戳相对太大了，说明已进行的修改操作比要求的多，就把之前改的改回来，反之往后改。</p>
<p>只有当当前区间和查询区间左右端点、时间戳均重合时，才认定区间完全重合，此时的答案才是本次查询的最终答案。</p>
<p><strong>通俗地讲，就是再弄一指针，在修改操作上跳来跳去，如果当前修改多了就改回来，改少了就改过去，直到次数恰当为止。</strong></p>
<p>这样，我们当前区间的移动方向从四个（<span
class="math inline">\([l−1,r]、[l+1,r]、[l,r−1]、[l,r+1]\)</span>）</p>
<p>变成了六个（<span
class="math inline">\([l−1,r,t]、[l+1,r,t]、[l,r−1,t]、[l,r+1,t]、[l,r,t−1]、[l,r,t+1]\)</span>）</p>
<p>嫖了一份代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 50500</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxc 1001000</span></span><br><span class="line"><span class="type">int</span> a[maxn], cnt[maxc], ans[maxn], belong[maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">query</span> &#123;</span><br><span class="line">	<span class="type">int</span> l, r, time, id;</span><br><span class="line">&#125; q[maxn];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">modify</span> &#123;</span><br><span class="line">	<span class="type">int</span> pos, color, last;</span><br><span class="line">&#125; c[maxn];</span><br><span class="line"><span class="type">int</span> cntq, cntc, n, m, size, bnum;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp</span><span class="params">(query a, query b)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> (belong[a.l] ^ belong[b.l]) ? belong[a.l] &lt; belong[b.l] : ((belong[a.r] ^ belong[b.r]) ? belong[a.r] &lt; belong[b.r] : a.time &lt; b.time);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> isdigit(x) ((x) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; (x) &lt;= <span class="string">&#x27;9&#x27;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">   <span class="type">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) c = <span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) res = (res &lt;&lt; <span class="number">1</span>) + (res &lt;&lt; <span class="number">3</span>) + (c ^ <span class="number">48</span>), c = <span class="built_in">getchar</span>();</span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">   size = <span class="built_in">pow</span>(n, <span class="number">2.0</span> / <span class="number">3.0</span>);</span><br><span class="line">   bnum = <span class="built_in">ceil</span>((<span class="type">double</span>)n / size);</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= bnum; ++i) </span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j = (i - <span class="number">1</span>) * size + <span class="number">1</span>; j &lt;= i * size; ++j) belong[j] = i;</span><br><span class="line">	 <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">	    a[i] = <span class="built_in">read</span>();</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">      <span class="type">char</span> opt[<span class="number">100</span>];</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, opt);</span><br><span class="line">      <span class="keyword">if</span>(opt[<span class="number">0</span>] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">         q[++cntq].l = <span class="built_in">read</span>();</span><br><span class="line">	 q[cntq].r = <span class="built_in">read</span>();</span><br><span class="line">	 q[cntq].time = cntc;</span><br><span class="line">	 q[cntq].id = cntq;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(opt[<span class="number">0</span>] == <span class="string">&#x27;R&#x27;</span>) &#123;</span><br><span class="line">         c[++cntc].pos = <span class="built_in">read</span>();</span><br><span class="line">	 c[cntc].color = <span class="built_in">read</span>();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">sort</span>(q + <span class="number">1</span>, q + cntq + <span class="number">1</span>, cmp);</span><br><span class="line">   <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>, time = <span class="number">0</span>, now = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cntq; ++i) &#123;</span><br><span class="line">      <span class="type">int</span> ql = q[i].l, qr = q[i].r, qt = q[i].time;</span><br><span class="line">      <span class="keyword">while</span>(l &lt; ql) now -= !--cnt[a[l++]];</span><br><span class="line">      <span class="keyword">while</span>(l &gt; ql) now += !cnt[a[--l]]++;</span><br><span class="line">      <span class="keyword">while</span>(r &lt; qr) now += !cnt[a[++r]]++;</span><br><span class="line">      <span class="keyword">while</span>(r &gt; qr) now -= !--cnt[a[r--]];</span><br><span class="line">      <span class="keyword">while</span>(time &lt; qt) &#123;</span><br><span class="line">	 ++time;</span><br><span class="line">	 <span class="keyword">if</span>(ql &lt;= c[time].pos &amp;&amp; c[time].pos &lt;= qr) now -= !--cnt[a[c[time].pos]] - !cnt[c[time].color]++;</span><br><span class="line">	    <span class="built_in">swap</span>(a[c[time].pos], c[time].color);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span>(time &gt; qt) &#123;</span><br><span class="line">	 <span class="keyword">if</span>(ql &lt;= c[time].pos &amp;&amp; c[time].pos &lt;= qr) now -= !--cnt[a[c[time].pos]] - !cnt[c[time].color]++;</span><br><span class="line">	    <span class="built_in">swap</span>(a[c[time].pos], c[time].color);</span><br><span class="line">	    --time;</span><br><span class="line">      &#125;</span><br><span class="line">      ans[q[i].id] = now;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cntq; ++i) </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>#晚上</p>
<p>写博客 补坑</p>
]]></content>
      <categories>
        <category>暑假日常</category>
      </categories>
      <tags>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title>7.27集训</title>
    <url>/2020/07/27/7.27%E9%9B%86%E8%AE%AD/</url>
    <content><![CDATA[<p>#上午</p>
<p>讲了搜索，最短路，最小生成树 <span id="more"></span> ### 关于搜索</p>
<p>首先是bfs一些走迷宫问题</p>
<p>基本框架如下: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>入队，打上标记</span><br><span class="line"><span class="number">2.</span>队列不空&#123;</span><br><span class="line">  取出当前队首节点，接近着pop</span><br><span class="line">  一般都是对队首枚举四个方向&#123;</span><br><span class="line">     对于每个方向拓展出来的点</span><br><span class="line">     进行一大堆特判</span><br><span class="line">     留下经过挑选的数 &#123;</span><br><span class="line">         入队</span><br><span class="line">         打上标记</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">3.</span>善后</span><br></pre></td></tr></table></figure> 一般而言 bfs比较好理解也好实现</p>
<p>对于dfs，dfs就比较操蛋一些，因为掺杂了递归</p>
<p>我依稀记得一个名人沃乱硕得曾经说过：对于任何一个算法，掺杂了递归，就不是一个好算法</p>
<p>dfs基本框架如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">到达了边界 返回</span><br><span class="line">一些操蛋剪枝优化包括什么A*IDA*</span><br><span class="line">一般到了这里都会有一些条件，比如在一个<span class="keyword">for</span>里去搜索，或者在<span class="keyword">if</span>里去搜索</span><br><span class="line">直接来裸搜索的不太多</span><br></pre></td></tr></table></figure>
<p>搜索有好多可做题呢，<a
href="https://www.luogu.com.cn/problem/P1034">矩形覆盖</a> <a
href="https://www.luogu.com.cn/problem/P1074">数独</a>
还没接到例题，等收到了再补上吧</p>
<h3 id="最短路">最短路</h3>
<p>首先是弗洛伊德 三个for</p>
<p>就很nb....</p>
<p>其中k必须在外边，因为我们必须要用已经更新过的点去更新别的，我们不可能用一个未更新的点去更新别人</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; ++ k)</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">	 f[i][j] = <span class="built_in">min</span>(f[i][j], f[i][k]+f[k][j]);</span><br></pre></td></tr></table></figure>
<p>dij与SPFA 回头补上</p>
<p>以后尽量用堆优化的dij因为spfa已经死了</p>
<h1 id="下午">下午</h1>
<p>讲了讲图论，主要是关于<span
class="math inline">\(Tarjan\)</span>的相关知识</p>
<h3 id="tarjan与有向图"><span
class="math inline">\(Tarjan\)</span>与有向图</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dfn[x] = low[x] = ++ tot;</span><br><span class="line">sta[++tp] = x, in[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = e[i].nxt) &#123;</span><br><span class="line">   <span class="type">int</span> y = e[i].to;</span><br><span class="line">   <span class="keyword">if</span> (!dfn[y]) <span class="built_in">tarian</span> (y), low[x] = <span class="built_in">min</span> (low[x], low[y]);</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (in[y]) low[x] = <span class="built_in">min</span> (low[x], dfn[y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dfn[x] == low[x]) &#123;</span><br><span class="line">   <span class="type">int</span> y; ++ res;</span><br><span class="line">   <span class="keyword">do</span> &#123;</span><br><span class="line">      y = sta[tp--], in[y] = <span class="number">0</span>;</span><br><span class="line">      tar[y] = cnt, scc[cnt].<span class="built_in">push_back</span>(y);</span><br><span class="line">   &#125;<span class="keyword">while</span> (x != y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的<span class="math inline">\(else\)</span>里面的<span
class="math inline">\(low[x] = min (low[x],
dfn[y])\)</span>引起了争议，因为我交了好几道题，把里面的<span
class="math inline">\(dfs\)</span>改成<span
class="math inline">\(low\)</span>，是没有问题的，但是定义上应该是不相符的</p>
<p>但是学长依然建议我们写<span
class="math inline">\(dfn\)</span>不写<span
class="math inline">\(low\)</span></p>
<h3 id="tarjan与无向图"><span
class="math inline">\(Tarjan\)</span>与无向图</h3>
<p>割点割桥</p>
<p>求割点与割桥的方法</p>
<p><strong>其中割边判定法则为：无向边<span
class="math inline">\((x,y)\)</span>是桥，当且仅当搜索树上存在<span
class="math inline">\(x\)</span>的一个子节点y满足：<span
class="math inline">\(dfn[x] &lt; low[y]\)</span></strong></p>
<p><strong>其中割点判定法则为：若<span
class="math inline">\(x\)</span>不是搜索树的根节点（深度优先遍历的起点），则<span
class="math inline">\(x\)</span>是割点当且仅当搜索树上存在<span
class="math inline">\(x\)</span>的一个子节点<span
class="math inline">\(y\)</span>，满足<span class="math inline">\(dfn[x]
\leq low[y]\)</span></strong></p>
<p>以及边双联通分量 与点双</p>
<p>lyd算法竞赛进阶指南P404有，读者亦可自证</p>
<h1 id="晚上">晚上</h1>
<h3 id="lca与倍增">LCA与倍增</h3>
<p>lca可以用倍增来求，也可以用树剖来求，但是树剖常数更小</p>
<p>甩两道比较好的LCA例题</p>
<p><a href="https://www.luogu.com.cn/problem/P1967">大货车</a></p>
<p><a href="https://www.luogu.com.cn/problem/P3398">小仓鼠</a></p>
<p>好像还做了一些<span class="math inline">\(Tarjan\)</span>的题</p>
<p><a href="https://www.luogu.com.cn/problem/P4180">生成树</a></p>
<p><a href="https://www.luogu.com.cn/problem/P2783">化学考试之神</a></p>
<p>只敲了个别几个，好几个没敲</p>
<p>然后就是改题了......</p>
]]></content>
      <categories>
        <category>暑假日常</category>
      </categories>
      <tags>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title>7.28集训</title>
    <url>/2020/07/28/7.28%E9%9B%86%E8%AE%AD/</url>
    <content><![CDATA[<p>#上午</p>
<p>教练让补补坑 <span id="more"></span> 先改了改以前的题，然后开始透彻几道题</p>
<p>1.<a href="https://www.luogu.com.cn/problem/P1886">滑稽窗口</a></p>
<p>以前总是感觉迷迷糊糊不太透彻，今天tmd终于搞明白了</p>
<p>我们维护一个希望维护一个长度为m的队列，对于求最小值的时候，我们维护单增队列，所以队尾一定要保证是最大的</p>
<p>所以对于当前的<span
class="math inline">\(a[i]\)</span>，我们必须保证<span
class="math inline">\(a[i] &gt;
a[q[t]]\)</span>才能使其入队，否则就一直让队尾缩短</p>
<p>对于求最大值的时候，我们希望维护一个递减队列，保证队尾最小</p>
<p>所以同理，对于当前的<span
class="math inline">\(a[i]\)</span>，我们保证<span
class="math inline">\(a[i] &gt;
a[q[t]]\)</span>才能使其入队，否则一直使得t自减</p>
<p>（最近超喜欢写han yu pin yin 的函数） <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> ~~(<span class="number">0</span>^_^<span class="number">0</span>);</span><br></pre></td></tr></table></figure> 其中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">define _ <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>下面给出漂亮的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ 0</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>+<span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N], q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">shuruyijichushihua</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">   cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">caozuoyifan</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="type">int</span> h = <span class="number">1</span>, t = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">      <span class="keyword">while</span> (h &lt;= t &amp;&amp; q[h] + m &lt;= i) ++ h;</span><br><span class="line">      <span class="keyword">while</span> (h &lt;= t &amp;&amp; a[i] &lt; a[q[t]]) -- t;</span><br><span class="line">      q[++ t] = i;</span><br><span class="line">      <span class="keyword">if</span> (i &gt;= m) cout &lt;&lt; a[q[h]] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">   <span class="built_in">memset</span>(q, <span class="number">0</span>, <span class="keyword">sizeof</span> q);</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">      <span class="keyword">while</span> (h &lt;= t &amp;&amp; q[h] + m &lt;= i) ++ h;</span><br><span class="line">      <span class="keyword">while</span> (h &lt;= t &amp;&amp; a[i] &gt; a[q[t]]) -- t;</span><br><span class="line">      q[++ t] = i;</span><br><span class="line">      <span class="keyword">if</span> (i &gt;= m) cout &lt;&lt; a[q[h]] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">shuruyijichushihua</span>();</span><br><span class="line">   <span class="built_in">caozuoyifan</span>();</span><br><span class="line">   <span class="keyword">return</span> ~~(<span class="number">0</span>^_^<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="下午">下午</h1>
讲了拓扑排序，寻找入度为零的点，从那些点开始搜索，一般用队列实现
给出常见代码：
<details>
<summary>
Code
</summary>
<pre><code>for (int i = 1; i <= n; ++ i) if (!rudu[i]) q.push(i);
while(q.size()) &#123;
   int now = q.front(); q.pop();
   for (int i = head[now]; i; i = e[i].nxt) &#123;
      int y = e[i].to;
      -- rudu[y];
      if (!rudu[y]) q.push(y);
   &#125;
&#125;
</code></pre>
</details>
<p>典型的tuopupaixu例题：</p>
<h3 id="我去你家"><a
href="https://vjudge.net/problem/POJ-2762">我去你家</a></h3>
<p>题目：原文叽哩哇啦的看不懂</p>
<p>翻译：balabala的一堆废话，我默然...</p>
<p>说人话：给你个有向图，判断是否存在任意两点<span
class="math inline">\(u,v\)</span>，存在<span class="math inline">\(u
-&gt; v\)</span> <span class="math inline">\(or\)</span> <span
class="math inline">\(v-&gt;u\)</span></p>
<p>大体思路：扫一遍图，缩点，对于缩点完毕的强连通分量，我们考虑将其tuo
pu pai xu，无论哪一阶段只要入度大于1就是false</p>
<h3 id="变态覆盖矩形"><a
href="https://vjudge.net/problem/POJ-1128">变态覆盖矩形</a></h3>
<p>开篇得图，给你一个很大大大大大大的字母矩阵，说白了就是几个矩形套在一起，让你求最底下到最底层的顺序（保证字典序）</p>
<p>我们首先得用结构体，其次我们对于每一个矩形，扫描它的上下左右四条边，有不同的，就记录下来，最后向覆盖他的矩形连边</p>
<p>关于输出的时候，我们考虑用dfs版本的tuopupaixu，只要搜到解，立刻输出停止，这样就是字典序最小的了</p>
<h3 id="变态排序"><a
href="https://vjudge.net/problem/POJ-1094#author=TIMEpings">变态排序</a></h3>
<p>不会，-----&gt;<a
href="https://blog.csdn.net/qq_41280600/article/details/104132961">题解</a></p>
<p>下面是ufs的典型例题</p>
<p>###<a
href="https://vjudge.net/problem/ZOJ-3261#author=lbsdxq">小仙女</a></p>
<p><strong>不会</strong>：</p>
<p>很容易看出这是一道并查集的题，可是与并查集不同的是，这道题不仅要建立联系还要删除联系，如果这样想是很复杂的，但是如果将所有请求保存起来，然后反向请求，离线来做的话，就很简单了，如果遇到query就查询与该星球有联系且power值最大的，如果遇到destory就把两个星球建立联系，最后将答案反向输出。</p>
<p>如果把power值大的作为父亲，则查询起来更加方便了</p>
<p>------&gt;</p>
<p>把destory边，看成合并。初始化的时候，对给定的边进行并集操作（除去将会被destory的边），然后把问题逆向依次考虑，遇到destory的时候就把边加入集合。最后把答案输出即可。</p>
<p>注意：相邻的case之间要输出空行，路径压缩的时候，相同的power值时，编号小的作为祖先。</p>
<p>下面给出别人代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span> + <span class="number">10</span>, M = <span class="number">2e4</span> + <span class="number">10</span>, Q = <span class="number">5e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> fa[N],power[N],ans[Q];</span><br><span class="line">map&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, <span class="type">int</span>&gt; mp;	<span class="comment">//离散存储</span></span><br><span class="line"><span class="type">int</span> n, m, q;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">   <span class="type">int</span> flag;	<span class="comment">//0表示query u,1表示destory u-v</span></span><br><span class="line">   <span class="type">int</span> u, v;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">setNode</span><span class="params">(<span class="type">int</span> flag, <span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123; <span class="keyword">this</span>-&gt;flag = flag, <span class="keyword">this</span>-&gt;u = u, <span class="keyword">this</span>-&gt;v = v; &#125;</span><br><span class="line">&#125;ques[Q];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node2</span> &#123;</span><br><span class="line">   <span class="type">int</span> flag;</span><br><span class="line">   <span class="type">int</span> u, v;</span><br><span class="line">&#125;edg[M];	<span class="comment">//保存两星球中的通道，flag表示存在否</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (fa[x] == <span class="number">-1</span>) <span class="keyword">return</span> x;</span><br><span class="line">   <span class="keyword">return</span> fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unite</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> fu = <span class="built_in">find</span>(u);</span><br><span class="line">   <span class="type">int</span> fv = <span class="built_in">find</span>(v);</span><br><span class="line">   <span class="keyword">if</span> (fu == fv)<span class="keyword">return</span>;</span><br><span class="line">   <span class="keyword">if</span> (power[fu] &gt; power[fv] || power[fu] == power[fv] &amp;&amp; fu&lt;fv)</span><br><span class="line">      fa[fv] = fu;</span><br><span class="line">   <span class="keyword">else</span> fa[fu] = fv;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">memset</span>(fa, <span class="number">-1</span>, <span class="built_in">sizeof</span>(fa));</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">      <span class="keyword">if</span> (edg[i].flag) <span class="built_in">unite</span>(edg[i].u, edg[i].v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> flag = <span class="number">0</span>;	<span class="comment">//控制连续的测试数据间隔空行</span></span><br><span class="line">   <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n))</span><br><span class="line">   &#123;</span><br><span class="line">      mp.<span class="built_in">clear</span>();</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;power[i]);</span><br><span class="line">	 <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">      &#123;</span><br><span class="line">	 <span class="type">int</span> u, v;</span><br><span class="line">	 <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">	 <span class="keyword">if</span> (u &gt; v)<span class="built_in">swap</span>(u, v);</span><br><span class="line">	 mp[<span class="built_in">make_pair</span>(u, v)] = i;</span><br><span class="line">	 edg[i].flag = <span class="number">1</span>;	<span class="comment">//存在边</span></span><br><span class="line">	 edg[i].u = u, edg[i].v = v;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">int</span> q;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; q; i++)</span><br><span class="line">      &#123;</span><br><span class="line">	 <span class="type">char</span> str[<span class="number">10</span>];</span><br><span class="line">	 <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">	 <span class="keyword">if</span> (str[<span class="number">0</span>] == <span class="string">&#x27;q&#x27;</span>) &#123;</span><br><span class="line">	    <span class="type">int</span> s;</span><br><span class="line">	    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s);</span><br><span class="line">	    ques[i].<span class="built_in">setNode</span>(<span class="number">0</span>, s, <span class="number">-1</span>);</span><br><span class="line">	 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    <span class="type">int</span> u, v;</span><br><span class="line">	    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">            <span class="keyword">if</span> (u &gt; v)<span class="built_in">swap</span>(u, v);</span><br><span class="line">            ques[i].<span class="built_in">setNode</span>(<span class="number">1</span>, u, v);</span><br><span class="line">            <span class="type">int</span> tmp = mp[<span class="built_in">make_pair</span>(ques[i].u, ques[i].v)];</span><br><span class="line">            edg[tmp].flag = <span class="number">0</span>;	<span class="comment">//逆过来看，该边不存在</span></span><br><span class="line">	 &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">init</span>();	<span class="comment">//初始化边集</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = q<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">if</span> (ques[i].flag)	<span class="comment">//destory</span></span><br><span class="line">	    <span class="built_in">unite</span>(ques[i].u, ques[i].v);</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">	   <span class="type">int</span> tmp = <span class="built_in">find</span>(ques[i].u);</span><br><span class="line">	   <span class="keyword">if</span> (power[tmp] &gt; power[ques[i].u]) ans[i] = tmp;</span><br><span class="line">           <span class="keyword">else</span> ans[i] = <span class="number">-1</span>;</span><br><span class="line">	 &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (flag) <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">      <span class="keyword">else</span> flag = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;q;i++)</span><br><span class="line">         <span class="keyword">if</span>(ques[i].flag==<span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="晚上">晚上</h1>
<p>主要讲的单调队列，栈
其实这也仅仅是一种思想，主要是多做题，这种题就是模拟，没多少技术含量，都是在O(n)的时间内，几乎线性的扫上一遍，然后得出答案</p>
<p>还有左偏树</p>
<h3 id="滑稽窗口"><a
href="https://www.luogu.com.cn/problem/P1886">滑稽窗口</a></h3>
再次不多赘述
<details>
<summary>
Code
</summary>
<pre><code>h = 1, t = 0;
for (int i = 1; i <= n; ++ i) &#123;
   while (h <= t && h+k <= i) ++ h;
   while (h <= t && a[i] < a[q[t]]) -- t;
   q[++ t] = i;
   if (i >= k) cout << a[q[h]] << ' ';
&#125;
puts("");
h = 1, t = 0;
memset (q, 0, sizeof q);
for (int i = 1; i <= n; ++ i) &#123;
   while (h <= t && h+k <= i) ++ h;
   while (h <= t && a[i] > a[q[t]]) -- t;
   q[++ t] = i;
   if (i >= k) cout << a[q[h]] << ' ';
&#125;
</code></pre>
</details>
<h3 id="发射站"><a
href="https://www.luogu.com.cn/problem/P1901">发射站</a></h3>
<p>维护一个单调栈，每次弹出的时候更新答案，并且正反跑一次，可分别求出两边</p>
<h3 id="正方形"><a
href="https://www.luogu.com.cn/problem/P2216">正方形</a></h3>
<p>二维的滑动窗口</p>
<p>首先我们考虑行，我们对每一行都维护一个hdck，并把维护的最大值或者是最小值记在那个窗口的最右边（开个新数组）</p>
<p>这样每一行就一定会有k个数（k为hdck的长度）</p>
<p>同理我们再对列维护滑动窗口，并且</p>
<p><a href="https://www.luogu.com.cn/problem/P3871">中位数</a></p>
<p>考虑用堆来维护，先排序，然后对于前一半的数考虑维护一个大根堆，对后一半的数维护一个小根堆</p>
<p>如果n为偶数，那么答案就为大根堆的堆顶，如果n为奇数，我们还是强制让<span
class="math inline">\(size_{bigdui}\)</span> <span
class="math inline">\(\leq\)</span> <span
class="math inline">\(size_{smalldui}\)</span> <span
class="math inline">\(\leq\)</span> <span
class="math inline">\(size_{bigdui} + 1\)</span></p>
<p>这样答案还是大根堆的堆顶</p>
<p>每次插入的时候，两个堆来回倒腾，反正你多一个，我就少一个</p>
<h3 id="单调队列优化"><a
href="https://www.luogu.com.cn/problem/P2627">单调队列优化</a></h3>
<p>dp式子不难看出：..........</p>
<hr />
<p>不写了，以后补</p>
]]></content>
      <categories>
        <category>暑假日常</category>
      </categories>
      <tags>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title>8.13集训</title>
    <url>/2020/08/13/8.13%E9%9B%86%E8%AE%AD/</url>
    <content><![CDATA[<h1 id="上午">上午</h1>
<p>考试 <span id="more"></span> # 下午</p>
<p>改题</p>
<h3 id="第一题">第一题</h3>
<p>给出一颗n个点的树，从1号点出发走m步，每步一条边，最多可以经过多少点？点和边均可以重复经过，但重复的点只计算一次。</p>
<p>显然，我们需要找出距离1号点最远的边，这些边都只走一次，别的边走两次</p>
<p>考虑三种情况：</p>
<ul>
<li>1，m过于大，即使把整个图都跑完也用不完m</li>
<li>2，m刚好可以跑完那个距离1号点的最长链</li>
<li>3，m可以跑完那个链，还有剩余</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//东方之珠 整夜未眠！</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span>+<span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;<span class="type">int</span> to, nex;&#125;e[N&lt;&lt;<span class="number">1</span>]; <span class="type">int</span> head[N], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">jiabian</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">   e[++ cnt].to = v;</span><br><span class="line">   e[cnt].nex = head[u];</span><br><span class="line">   head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line">   <span class="keyword">for</span> (i = head[x]; i; i = e[i].nex) &#123;</span><br><span class="line">      <span class="type">int</span> y = e[i].to;</span><br><span class="line">      <span class="keyword">if</span> (y == fa) <span class="keyword">continue</span>;</span><br><span class="line">      d[y] = d[x] + <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">dfs</span>(y, x);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="type">int</span> i, j, k, n, m, <span class="built_in">res</span>(<span class="number">0</span>);</span><br><span class="line">   cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">      <span class="type">int</span> x, y;</span><br><span class="line">      cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">      <span class="built_in">jiabian</span>(x, y);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (res &lt; d[i]) &#123;</span><br><span class="line">         res = d[i];</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (m &lt;= res) cout &lt;&lt; m + <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (m &gt;= res + <span class="number">2</span> * (n - res - <span class="number">1</span>)) cout &lt;&lt; n;</span><br><span class="line">   <span class="keyword">else</span> cout &lt;&lt; res + (m - res)/<span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第二题">第二题</h3>
<p>给出一棵n个点的树，第i个点的权值为<span
class="math inline">\(a_i\)</span>，现在你可以进行如下操作：</p>
<ul>
<li>1，选择一个包含1号点的连通子图，使其中所有点权值+1</li>
<li>2，选择一个包含1号点的连通子图，使其中所有点权值-1</li>
</ul>
<p>求最小的操作次数，使得所有点的权值都变为0</p>
<p>第一次看见我以为是关于差分的题，就像<a
href="http://noi-test.zzstep.com/contest/0x00%E3%80%8C%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95%E3%80%8D%E4%BE%8B%E9%A2%98/0304%20IncDec%20Sequence">这道</a>一样</p>
<p>于是我一直在想树上差分，一直在想，一直在想，可是考完试我才发现，跟tm差分没一点关系，</p>
<p>如果我没有一直往差分那里钻，或许我还能想到一些暴力的做法，</p>
<p>想到差分，注定了我只能拿零分</p>
<p>给出gxz的题解：</p>
<p>设<span
class="math inline">\(f[i]\)</span>表示以i为根的子树需要进行-1操作的次数，则需要进行+1操作的次数为<span
class="math inline">\(f[i]-a[i]\)</span></p>
<p>考虑一个点，不考虑自身的话，需要进行的<span
class="math inline">\(-1\)</span>和<span
class="math inline">\(+1\)</span>操作都是所有子节点的最大值。</p>
<p>故记<span class="math inline">\(M = Max(f[son]),N =
Max(f[son]-a[son])\)</span>,子树至少要减<span
class="math inline">\(M\)</span>次，自己至少要减<span
class="math inline">\(N+a_i\)</span>次</p>
<p>得到<span class="math inline">\(f[i] =Max(M, N+a[i])\)</span></p>
<p>最终答案为<span class="math inline">\(f[1]+(f[1]+a[1])\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//东方之珠 整夜未眠！</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span>+<span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N], a[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;<span class="type">int</span> to, nex;&#125;e[N&lt;&lt;<span class="number">1</span>]; <span class="type">int</span> head[N&lt;&lt;<span class="number">1</span>], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">   e[++ cnt].to = v;</span><br><span class="line">   e[cnt].nex = head[u];</span><br><span class="line">   head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">   <span class="type">int</span> i, <span class="built_in">M</span>(<span class="number">0</span>), <span class="built_in">N</span>(<span class="number">0</span>);</span><br><span class="line">   <span class="keyword">for</span> (i = head[x]; i; i = e[i].nex) &#123;</span><br><span class="line">      <span class="type">int</span> y = e[i].to;</span><br><span class="line">      <span class="keyword">if</span> (y == fa) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="built_in">dfs</span>(y, x);</span><br><span class="line">      M = <span class="built_in">max</span>(M, f[y]);</span><br><span class="line">      N = <span class="built_in">max</span>(N, f[y] - a[y]);</span><br><span class="line">   &#125;</span><br><span class="line">   f[x] = <span class="built_in">max</span>(M, N + a[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="type">int</span> i, j, k, n, m, <span class="built_in">res</span>(<span class="number">0</span>);</span><br><span class="line">   cin &gt;&gt; n;</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">      <span class="type">int</span> x, y;</span><br><span class="line">      cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">      <span class="built_in">add</span>(x, y);</span><br><span class="line">      <span class="built_in">add</span>(y, x);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span> (<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">   <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">   cout &lt;&lt; (f[<span class="number">1</span>] + f[<span class="number">1</span>] - a[<span class="number">1</span>]);</span><br><span class="line">   <span class="built_in">fclose</span> (stdin), <span class="built_in">fclose</span> (stdout);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
<p>注意开LL</p>
<h3 id="第三题">第三题</h3>
<p><a href="https://www.luogu.com.cn/problem/P4284">click</a></p>
<p>给出gxz题解：</p>
<p><img
src="https://img2020.cnblogs.com/blog/1307264/202008/1307264-20200813164406486-1829265663.png" /></p>
<p>发誓再也tm不用cin了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//东方之珠 整夜未眠！</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span>+<span class="number">66</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> w[N], f[N], g[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;<span class="type">int</span> to, nex; <span class="type">double</span> val;&#125;e[N&lt;&lt;<span class="number">1</span>]; <span class="type">int</span> head[N&lt;&lt;<span class="number">1</span>], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">double</span> z)</span> </span>&#123;</span><br><span class="line">   e[++ cnt].to = y;</span><br><span class="line">   e[cnt].val = z;</span><br><span class="line">   e[cnt].nex = head[x];</span><br><span class="line">   head[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line">   f[x] = <span class="number">1</span> - w[x];</span><br><span class="line">   <span class="keyword">for</span> (i = head[x]; i; i = e[i].nex) &#123;</span><br><span class="line">      <span class="type">int</span> y = e[i].to;</span><br><span class="line">      <span class="keyword">if</span> (y == fa) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="built_in">dfs1</span>(y, x);</span><br><span class="line">      f[x] *= <span class="number">1</span> - f[y] * e[i].val;<span class="comment">//cong 0 tui dao 1</span></span><br><span class="line">   &#125;</span><br><span class="line">   f[x] = <span class="number">1</span> - f[x]; <span class="comment">//f[x] cong biao shi 0 bian cheng le biao shi 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line">   <span class="keyword">for</span> (i = head[x]; i; i = e[i].nex) &#123;</span><br><span class="line">      <span class="type">int</span> y = e[i].to;</span><br><span class="line">      <span class="keyword">if</span> (y == fa) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="number">1</span> - f[y] * e[i].val &lt; eps) g[y] = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">else</span> g[y] = <span class="number">1</span> - (<span class="number">1</span> - f[y]) * (<span class="number">1</span> - (<span class="number">1</span> - (<span class="number">1</span> - g[x]) / (<span class="number">1</span> - f[y] * e[i].val)) * e[i].val);</span><br><span class="line">      <span class="built_in">dfs2</span>(y, x);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="type">int</span> i, j, k, x, y, n;</span><br><span class="line">   <span class="type">double</span> z, <span class="built_in">res</span>(<span class="number">0</span>);</span><br><span class="line">   cin &gt;&gt; n;</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">      <span class="built_in">scanf</span> (<span class="string">&quot;%d%d%lf&quot;</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">      <span class="built_in">add</span>(x, y, z/<span class="number">100</span>);</span><br><span class="line">      <span class="built_in">add</span>(y, x, z/<span class="number">100</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= n ; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span> , &amp;w[i]) , w[i] /= <span class="number">100</span>;</span><br><span class="line">   <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">   g[<span class="number">1</span>] = f[<span class="number">1</span>];</span><br><span class="line">   <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) res += g[i];</span><br><span class="line">   <span class="built_in">printf</span> (<span class="string">&quot;%.6lf\n&quot;</span> , res);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>暑假日常</category>
      </categories>
      <tags>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title>8.11集训</title>
    <url>/2020/08/11/8.11%E9%9B%86%E8%AE%AD/</url>
    <content><![CDATA[<span id="more"></span>
<p>弄了一天动态规划</p>
]]></content>
      <categories>
        <category>暑假日常</category>
      </categories>
      <tags>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title>7.31集训</title>
    <url>/2020/07/31/7.31%E9%9B%86%E8%AE%AD/</url>
    <content><![CDATA[<p>改题 <span id="more"></span> 补坑 写博客</p>
]]></content>
      <categories>
        <category>暑假日常</category>
      </categories>
      <tags>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title>8.14集训</title>
    <url>/2020/08/14/8.14%E9%9B%86%E8%AE%AD/</url>
    <content><![CDATA[<p>做题做题做题</p>
<p><strong>PS</strong>:时间紧，码风没时间调,题解稍后补上 <span id="more"></span> ###
生成树</p>
<p><a href="https://www.luogu.com.cn/problem/P4821">click</a></p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//东方之珠 整夜未眠！</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">2007</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">ksm</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res = res * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">work</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span> * x * <span class="built_in">ksm</span>(<span class="number">5</span>, x - <span class="number">1</span>)%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x, T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">work</span>(x) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="硬币购物">硬币购物</h3>
<p><a href="https://www.luogu.com.cn/problem/P1450">click</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100001</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//男儿有胆气 仗剑走天涯</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i, j, T, sum;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> res, dp[N+<span class="number">10</span>], t;</span><br><span class="line"><span class="type">int</span> c[<span class="number">5</span>], d[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; ++ i) cin &gt;&gt; c[i];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (j = c[i]; j &lt;= N; ++ j)</span><br><span class="line">            dp[j] += dp[j-c[i]];</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T --&gt; <span class="number">0</span>) &#123;</span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; ++ i) cin &gt;&gt; d[i];</span><br><span class="line">        cin &gt;&gt; sum;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">15</span>; ++ i) &#123;</span><br><span class="line">            t = sum;</span><br><span class="line">            <span class="function"><span class="type">int</span> <span class="title">cnt</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= <span class="number">4</span>; ++ j) <span class="keyword">if</span> ((i&gt;&gt;(j<span class="number">-1</span>))&amp;<span class="number">1</span>) t -= c[j]*(d[j]+<span class="number">1</span>), cnt^=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (t&lt;<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!cnt) res += dp[t];</span><br><span class="line">            <span class="keyword">else</span> res -= dp[t];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="玉蟾宫">玉蟾宫</h3>
<p><a href="https://www.luogu.com.cn/problem/P4147">click</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//东方之珠 整夜未眠！</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N][N], sta[N], lp[N], rp[N];</span><br><span class="line"><span class="type">char</span> str[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, n, m, <span class="built_in">res</span>(<span class="number">0</span>), <span class="built_in">dadada</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= m; ++ j) &#123;</span><br><span class="line">            <span class="built_in">scanf</span> (<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">            <span class="keyword">if</span> (str[<span class="number">0</span>] == <span class="string">&#x27;F&#x27;</span>) &#123;</span><br><span class="line">                a[i][j] = a[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="number">0</span>, sta[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= m; ++ j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (res &amp;&amp; a[i][j] &lt;= a[i][sta[res]]) -- res;</span><br><span class="line">            lp[j] = sta[res], sta[++ res] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="number">0</span>, sta[res] = m + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = m; j; -- j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (res &amp;&amp; a[i][j] &lt;= a[i][sta[res]]) -- res;</span><br><span class="line">            rp[j] = sta[res], sta[++ res] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= m; ++ j) &#123;</span><br><span class="line">            dadada = <span class="built_in">max</span>(dadada, a[i][j]*(rp[j] - lp[j] - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dadada*<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最大数">最大数</h3>
<p><a href="https://www.luogu.com.cn/problem/P1198">click</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//东方之珠 整夜未眠！</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;<span class="type">int</span> num, pos;&#125;sta[N]; <span class="type">int</span> top;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">int</span> x, node y) &#123;<span class="keyword">return</span> x &lt; y.pos;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    node x;</span><br><span class="line">    x.num = num, x.pos = pos;</span><br><span class="line">    <span class="keyword">while</span> (top &amp;&amp; num &gt; sta[top].num) sta[top --] = sta[<span class="number">0</span>];</span><br><span class="line">    sta[++ top] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, M, D, <span class="built_in">res</span>(<span class="number">0</span>), <span class="built_in">t</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; M &gt;&gt; D;</span><br><span class="line">    <span class="keyword">while</span> (M --) &#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%s%d&quot;</span>, str, &amp;n);</span><br><span class="line">        <span class="keyword">if</span> (str[<span class="number">0</span>] == <span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">            n += t, n %= D;</span><br><span class="line">            <span class="built_in">Insert</span>(n, ++ res);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            t = <span class="built_in">upper_bound</span>(sta + <span class="number">1</span>, sta + top + <span class="number">1</span>, res - n) -&gt; num;</span><br><span class="line">            cout &lt;&lt; t &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="矩阵">矩阵</h3>
<p><a href="https://darkbzoj.tk/problem/4500">click</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//东方之珠 整夜未眠！</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x[N], y[N], z[N], f[N], r[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">fin</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="type">int</span> t = f[x];</span><br><span class="line">    f[x] = <span class="built_in">fin</span>(t);</span><br><span class="line">    r[x] += r[t];</span><br><span class="line">    <span class="keyword">return</span> f[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T; cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">        <span class="type">int</span> i, j, n, m, k;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= k; ++ i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span> (<span class="string">&quot;%d%d%d&quot;</span>, x + i, y + i, z + i);</span><br><span class="line">            y[i] += n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n+m; ++ i) f[i] = i, r[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> fx, fy;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= k; ++ i) &#123;</span><br><span class="line">            fx = <span class="built_in">fin</span>(x[i]), fy = <span class="built_in">fin</span>(y[i]);</span><br><span class="line">            <span class="keyword">if</span> (fx != fy) f[fx] = fy, r[fx] = z[i] + r[y[i]] - r[x[i]];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (r[x[i]] - r[y[i]] != z[i]) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; k) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="管农场">管农场</h3>
<p><a href="https://darkbzoj.tk/problem/4579">click</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//东方之珠 整夜未眠！</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span>+<span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N], f[N], ans[N], pd[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> to, nex;&#125;e[N&lt;&lt;<span class="number">1</span>]; <span class="type">int</span> head[N&lt;&lt;<span class="number">1</span>], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    e[++ cnt].to = y;</span><br><span class="line">    e[cnt].nex = head[x];</span><br><span class="line">    head[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">fin</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">return</span> f[x] == x ? x : f[x] = <span class="built_in">fin</span>(f[x]);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, k, n, m, <span class="built_in">res</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//res shi lian tong kuai de shu liang</span></span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="built_in">add</span>(x, y), <span class="built_in">add</span>(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, a+i);</span><br><span class="line">        f[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (k = n; k &gt;= <span class="number">1</span>; -- k) &#123;</span><br><span class="line">        x = a[k], pd[x] = <span class="number">1</span>;</span><br><span class="line">        ++ res;</span><br><span class="line">        <span class="keyword">for</span> (i = head[x]; i; i = e[i].nex) &#123;</span><br><span class="line">            y = e[i].to;</span><br><span class="line">            <span class="keyword">if</span> (pd[y]) &#123;</span><br><span class="line">                <span class="type">int</span> fx = <span class="built_in">fin</span>(x), fy = <span class="built_in">fin</span>(y);</span><br><span class="line">                <span class="keyword">if</span> (fx != fy) &#123;</span><br><span class="line">                    f[fx] = fy;</span><br><span class="line">                    -- res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[k] = (res == <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        cout &lt;&lt; (ans[i] ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;NO&quot;</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="小白逛公园">小白逛公园</h3>
<p><a href="https://www.luogu.com.cn/problem/P4513">click</a></p>
<p>数组版本！！！！,特别鸣谢gzh大佬</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span>+<span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, ans;</span><br><span class="line"><span class="type">int</span> a[N], d[N&lt;&lt;<span class="number">6</span>], zuo[N&lt;&lt;<span class="number">6</span>], you[N&lt;&lt;<span class="number">6</span>], duo[N&lt;&lt;<span class="number">6</span>],tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span> <span class="params">(<span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == t) &#123;</span><br><span class="line">        d[p] = zuo[p] = you[p] = duo[p] = a[s];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m = (s+t)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span> (s, m, p&lt;&lt;<span class="number">1</span>), <span class="built_in">build</span> (m+<span class="number">1</span>, t, (p&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>);</span><br><span class="line">    d[p] = (d[p&lt;&lt;<span class="number">1</span>] + d[(p&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>]);</span><br><span class="line">    zuo[p] = <span class="built_in">max</span> (zuo[p&lt;&lt;<span class="number">1</span>], d[p&lt;&lt;<span class="number">1</span>]+zuo[(p&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>]);</span><br><span class="line">    you[p] = <span class="built_in">max</span> (you[(p&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>], d[(p&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>]+you[p&lt;&lt;<span class="number">1</span>]);</span><br><span class="line">    duo[p] = <span class="built_in">max</span> (<span class="built_in">max</span>(duo[p&lt;&lt;<span class="number">1</span>], duo[(p&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>]), you[p&lt;&lt;<span class="number">1</span>]+zuo[(p&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">chenge</span> <span class="params">(<span class="type">int</span> x, <span class="type">int</span> c, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == t) &#123;</span><br><span class="line">        d[p] = zuo[p] = you[p] = duo[p] = c;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m = (s+t)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= m) <span class="built_in">chenge</span> (x, c, s, m, p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (x &gt; m) <span class="built_in">chenge</span> (x, c, m+<span class="number">1</span>, t, (p&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>);</span><br><span class="line">    d[p] = (d[p&lt;&lt;<span class="number">1</span>] + d[(p&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>]);</span><br><span class="line">    zuo[p] = <span class="built_in">max</span> (zuo[p&lt;&lt;<span class="number">1</span>], d[p&lt;&lt;<span class="number">1</span>]+zuo[(p&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>]);</span><br><span class="line">    you[p] = <span class="built_in">max</span> (you[(p&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>], d[(p&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>]+you[p&lt;&lt;<span class="number">1</span>]);</span><br><span class="line">    duo[p] = <span class="built_in">max</span> (<span class="built_in">max</span>(duo[p&lt;&lt;<span class="number">1</span>], duo[(p&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>]), you[p&lt;&lt;<span class="number">1</span>]+zuo[(p&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">get_sum</span> <span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &lt;= s &amp;&amp; t &lt;= r) <span class="keyword">return</span> p;</span><br><span class="line">    <span class="type">int</span> m = (s + t)&gt;&gt;<span class="number">1</span>, <span class="built_in">sum</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(r &lt;= m) <span class="keyword">return</span> <span class="built_in">get_sum</span> (l, r, s, m, p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(l &gt; m) <span class="keyword">return</span> <span class="built_in">get_sum</span> (l, r, m+<span class="number">1</span>, t, (p&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> t1 = <span class="built_in">get_sum</span> (l, r, s, m, p&lt;&lt;<span class="number">1</span>), t2 = <span class="built_in">get_sum</span> (l, r, m+<span class="number">1</span>,t, (p&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> ans = ++ tot;</span><br><span class="line">    d[ans] = d[t1] + d[t2];</span><br><span class="line">    zuo[ans] = <span class="built_in">max</span> (zuo[t1], d[t1] + zuo[t2]);</span><br><span class="line">    you[ans] = <span class="built_in">max</span> (you[t2], d[t2] + you[t1]);</span><br><span class="line">    duo[ans] = <span class="built_in">max</span> (<span class="built_in">max</span> (duo[t1], duo[t2]), you[t1] + zuo[t2]);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">main</span> () &#123;</span><br><span class="line">    <span class="comment">// freopen(&quot;test.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    tot=(n&lt;&lt;<span class="number">3</span>)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">build</span> (<span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">        <span class="type">int</span> opt, x, y;</span><br><span class="line">        cin &gt;&gt; opt &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &gt; y) <span class="built_in">swap</span> (x, y);</span><br><span class="line">            cout &lt;&lt; duo[<span class="built_in">get_sum</span>(x, y, <span class="number">1</span>, n, <span class="number">1</span>)] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="built_in">chenge</span> (x, y, <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>暑假日常</category>
      </categories>
      <tags>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title>8.10集训</title>
    <url>/2020/08/10/8.10%E9%9B%86%E8%AE%AD/</url>
    <content><![CDATA[<h1 id="一天">一天</h1>
<p>补坑 <span id="more"></span> 详见<a
href="https://www.cnblogs.com/yszhyhm/p/13425599.html">8.3</a></p>
<p>基本上都补了，不过还剩下一个BZOJ的题<a
href="https://darkbzoj.tk/problem/4245">OR-XOR</a></p>
]]></content>
      <categories>
        <category>暑假日常</category>
      </categories>
      <tags>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title>8.15集训</title>
    <url>/2020/08/15/8.15%E9%9B%86%E8%AE%AD/</url>
    <content><![CDATA[<p>做题</p>
<p>码风没调，题解没写，日后补 <span id="more"></span> ### 魔法少女</p>
<p><a href="https://darkbzoj.tk/problem/4399">click</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson l, mid, ls[x]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson mid+1, r, rs[x]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//东方之珠 整夜未眠！</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">4e5</span>+<span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ls[N * <span class="number">19</span>], rs[N * <span class="number">19</span>], si[N * <span class="number">19</span>];</span><br><span class="line"><span class="type">int</span> n, tot, f[N], root[N], tag[N * <span class="number">19</span>];</span><br><span class="line"><span class="type">int</span> m = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">double</span> sum[N * <span class="number">19</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tag[x]) &#123;</span><br><span class="line">        si[ls[x]] = si[rs[x]] = <span class="number">0</span>;</span><br><span class="line">        sum[ls[x]] = sum[rs[x]] = <span class="number">0</span>;</span><br><span class="line">        tag[ls[x]] = tag[rs[x]] = <span class="number">1</span>;</span><br><span class="line">        tag[x] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">return</span> f[x] == x ? f[x] : f[x] = <span class="built_in">find</span>(f[x]);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> a, <span class="type">double</span> v, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x) x = ++ tot;</span><br><span class="line">    si[x] += a, sum[x] += a*v;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (p &lt;= mid) <span class="built_in">add</span>(p, a, v, lson);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">add</span>(p, a, v, rson);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> b, <span class="type">int</span> e, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (b &lt;= l &amp;&amp; r &lt;= e)</span><br><span class="line">    &#123;</span><br><span class="line">        si[x] = <span class="number">0</span>, sum[x] = <span class="number">0</span>, tag[x] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (b &lt;= mid) <span class="built_in">del</span>(b, e, lson);</span><br><span class="line">    <span class="keyword">if</span> (e &gt; mid) <span class="built_in">del</span>(b, e, rson);</span><br><span class="line">    si[x] = si[ls[x]] + si[rs[x]];</span><br><span class="line">    sum[x] = sum[ls[x]] + sum[rs[x]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">querysi</span><span class="params">(<span class="type">int</span> b, <span class="type">int</span> e, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (b &lt;= l &amp;&amp; r &lt;= e) <span class="keyword">return</span> si[x];</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (b &lt;= mid) res += <span class="built_in">querysi</span>(b, e, lson);</span><br><span class="line">    <span class="keyword">if</span> (e &gt; mid) res += <span class="built_in">querysi</span>(b, e, rson);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= si[ls[x]]) <span class="keyword">return</span> <span class="built_in">find</span>(k, lson);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">find</span>(k - si[ls[x]], rson);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x+y;</span><br><span class="line">    si[x] += si[y], sum[x] += sum[y];</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="built_in">pushdown</span>(y);</span><br><span class="line">    ls[x] = <span class="built_in">merge</span>(ls[x], ls[y]);</span><br><span class="line">    rs[x] = <span class="built_in">merge</span>(rs[x], rs[y]);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T, c, x, y, t;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%d%d&quot;</span>, &amp;c, &amp;x);</span><br><span class="line">        <span class="keyword">switch</span>(c)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: <span class="built_in">add</span>(x, <span class="number">1</span>, <span class="built_in">log</span>(x), <span class="number">1</span>, m, root[++ n]), f[n] = n; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;y);</span><br><span class="line">                x = <span class="built_in">find</span>(x), y = <span class="built_in">find</span>(y);</span><br><span class="line">                <span class="keyword">if</span> (x != y)</span><br><span class="line">                &#123;</span><br><span class="line">                    f[y] = x;</span><br><span class="line">                    root[x] = <span class="built_in">merge</span>(root[x], root[y]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            &#123;</span><br><span class="line">                x = <span class="built_in">find</span>(x); <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;y);</span><br><span class="line">                t = <span class="built_in">querysi</span>(<span class="number">1</span>, y, <span class="number">1</span>, m, root[x]);</span><br><span class="line">                <span class="built_in">del</span>(<span class="number">1</span>, y, <span class="number">1</span>, m, root[x]);</span><br><span class="line">                <span class="built_in">add</span>(y, t, <span class="built_in">log</span>(y), <span class="number">1</span>, m, root[x]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            &#123;</span><br><span class="line">                x = <span class="built_in">find</span>(x);  <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;y);</span><br><span class="line">                t = <span class="built_in">querysi</span>(y, m, <span class="number">1</span>, m, root[x]);</span><br><span class="line">                <span class="built_in">del</span>(y, m, <span class="number">1</span>, m, root[x]);</span><br><span class="line">                <span class="built_in">add</span>(y, t, <span class="built_in">log</span>(y), <span class="number">1</span>, m, root[x]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>: </span><br><span class="line">            &#123;</span><br><span class="line">                x = <span class="built_in">find</span>(x); <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;y);</span><br><span class="line">                cout &lt;&lt; <span class="built_in">find</span>(y, <span class="number">1</span>, m, root[x]) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            &#123;</span><br><span class="line">                x = <span class="built_in">find</span>(x); <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;y);</span><br><span class="line">                y = <span class="built_in">find</span>(y);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum[root[x]] &gt; sum[root[y]]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span> : x = <span class="built_in">find</span>(x); cout &lt;&lt; si[root[x]] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="大陆争霸">大陆争霸</h3>
<p><a href="https://www.luogu.com.cn/problem/P2446">click</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//东方之珠 整夜未眠！</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pr;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">66</span>;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;pr, vector&lt;pr&gt;, greater&lt;pr&gt; &gt;q;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;p[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> to[N], nex[N], head[N], cnt;</span><br><span class="line"><span class="type">int</span> len[N], c[N];</span><br><span class="line"><span class="type">int</span> f[N], g[N], v[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> </span>&#123;</span><br><span class="line">    to[++ cnt] = y;</span><br><span class="line">    len[cnt] = z;</span><br><span class="line">    nex[cnt] = head[x];</span><br><span class="line">    head[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f), <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">    <span class="type">int</span> i, j, k, n, m, <span class="built_in">res</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> x, y, z;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">        <span class="built_in">add</span>(x, y, z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, c + i);</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= c[i]; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">            p[x].<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!c[i]) g[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">1</span>] = <span class="number">0</span>, q.<span class="built_in">push</span>(<span class="built_in">pr</span>(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        z = q.<span class="built_in">top</span>().first, x = q.<span class="built_in">top</span>().second, q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (v[x]) <span class="keyword">continue</span>;</span><br><span class="line">        v[x] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = head[x]; i; i = nex[i])</span><br><span class="line">        &#123;</span><br><span class="line">            y = to[i];</span><br><span class="line">            <span class="keyword">if</span> (f[y] &gt; z + len[i])</span><br><span class="line">            &#123;</span><br><span class="line">                f[y] = z + len[i];</span><br><span class="line">                <span class="keyword">if</span> (!c[y]) q.<span class="built_in">push</span>(<span class="built_in">pr</span>(<span class="built_in">max</span>(f[y], g[y]), y));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)p[x].<span class="built_in">size</span>(); ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            y = p[x][i];</span><br><span class="line">            -- c[y];</span><br><span class="line">            <span class="keyword">if</span> (!c[y])</span><br><span class="line">            &#123;</span><br><span class="line">                g[y] = z;</span><br><span class="line">                q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="built_in">max</span>(f[y], g[y]), y));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(f[n], g[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="小猪">小猪</h3>
<p><a href="https://www.luogu.com.cn/problem/P3420">click</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//bu bi yong vector</span></span><br><span class="line"><span class="comment">// dui x qu chu low</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//东方之珠 整夜未眠！</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>+<span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> to, nex;&#125;e[N]; <span class="type">int</span> head[N], bian;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++ bian].to = y;</span><br><span class="line">    e[bian].nex = head[x];</span><br><span class="line">    head[x] = bian;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dfn[N], low[N], sta[N], in[N], tar[N];</span><br><span class="line"><span class="type">int</span> tp, tot, cnt, cd[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, y;</span><br><span class="line">    dfn[x] = low[x] = ++ tot;</span><br><span class="line">    sta[++ tp] = x, in[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = head[x]; i; i = e[i].nex)</span><br><span class="line">    &#123;</span><br><span class="line">        y = e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[y])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(y);</span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (in[y]) low[x] = <span class="built_in">min</span>(low[x], dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (low[x] == dfn[x])</span><br><span class="line">    &#123;</span><br><span class="line">        ++ cnt;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            y = sta[tp --];</span><br><span class="line">            in[y] = <span class="number">0</span>;</span><br><span class="line">            tar[y] = cnt;</span><br><span class="line">        &#125; <span class="keyword">while</span> (y != x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, x, y, n, <span class="built_in">res</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;x), <span class="built_in">add</span>(i, x);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="keyword">if</span> (!dfn[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line">    <span class="keyword">for</span> (x = <span class="number">1</span>; x &lt;= n; ++ x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = head[x]; i; i = e[i].nex)</span><br><span class="line">        &#123;</span><br><span class="line">            y = e[i].to;</span><br><span class="line">            <span class="keyword">if</span> (tar[x] == tar[y]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> cd[tar[x]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= cnt; ++ i) <span class="keyword">if</span> (!cd[i]) ++ res;</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="食物链">食物链</h3>
<p><a href="https://darkbzoj.tk/problem/4562">click</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//东方之珠 整夜未眠！</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span>+<span class="number">66</span>;</span><br><span class="line"> </span><br><span class="line">queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line"><span class="type">int</span> rd[N], cd[N], f[N];</span><br><span class="line"><span class="type">int</span> to[N], nex[N], head[N], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    to[++ cnt] = y;</span><br><span class="line">    nex[cnt] = head[x];</span><br><span class="line">    head[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//f[i] has showed that from which zero to i&#x27;s ways</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, x, y, n, m, <span class="built_in">res</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%lld%lld&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="built_in">add</span>(x, y);</span><br><span class="line">        ++ rd[y];</span><br><span class="line">        ++ cd[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!rd[i]) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cd[i]) f[i] = <span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        x = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (i = head[x]; i; i = nex[i])</span><br><span class="line">        &#123;</span><br><span class="line">            y = to[i];</span><br><span class="line">            f[y] += f[x];</span><br><span class="line">            -- rd[y];</span><br><span class="line">            <span class="keyword">if</span> (!rd[y]) q.<span class="built_in">push</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="keyword">if</span> (!cd[i]) res += f[i];</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="blo">BLO</h3>
<p><a href="https://darkbzoj.tk/problem/1123">click</a></p>
<p>割点经典好题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//东方之珠 整夜未眠！</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span>+<span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> to[N&lt;&lt;<span class="number">1</span>], head[N&lt;&lt;<span class="number">1</span>], nex[N&lt;&lt;<span class="number">1</span>], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    to[++ cnt] = y;</span><br><span class="line">    nex[cnt] = head[x];</span><br><span class="line">    head[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> low[N], dfn[N], si[N], cut[N];</span><br><span class="line"><span class="type">int</span> n, m, tot;</span><br><span class="line">LL ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, y;</span><br><span class="line">    low[x] = dfn[x] = ++ tot, si[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">flag</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">sum</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (i = head[x]; i; i = nex[i])</span><br><span class="line">    &#123;</span><br><span class="line">        y = to[i];</span><br><span class="line">        <span class="keyword">if</span> (! dfn[y])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(y);</span><br><span class="line">            si[x] += si[y];</span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">            <span class="keyword">if</span> (low[y] &gt;= dfn[x])</span><br><span class="line">            &#123;</span><br><span class="line">                ++ flag;</span><br><span class="line">                ans[x] += (LL)si[y] * (n - si[y]);</span><br><span class="line">                sum += si[y];</span><br><span class="line">                <span class="keyword">if</span> (x != <span class="number">1</span> || flag &gt; <span class="number">1</span>) cut[x] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> low[x] = <span class="built_in">min</span>(low[x], dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cut[x]) ans[x] += (LL)(n - sum - <span class="number">1</span>) * (sum + <span class="number">1</span>) + (n - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//dui yu ge dian (n-1) duiying dandu yige dian deqingkuang</span></span><br><span class="line">    <span class="comment">//yijingjisuanle size[s1....sk]de qingkuang</span></span><br><span class="line">    <span class="comment">//(n - sum - 1) * (sum + 1)shi nage zitu</span></span><br><span class="line">    <span class="keyword">else</span> ans[x] = (n - <span class="number">1</span>)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, x, y;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++ i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span> (x == y) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">add</span>(x, y);</span><br><span class="line">        <span class="built_in">add</span>(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">tarjan</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= n; ++ i) cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>暑假日常</category>
      </categories>
      <tags>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title>8.16集训</title>
    <url>/2020/08/16/8.16%E9%9B%86%E8%AE%AD/</url>
    <content><![CDATA[<p>考试了呗 <span id="more"></span> ### 酒店</p>
<p><a href="https://darkbzoj.tk/problem/3522">click</a></p>
<p>观察题面可以得到：树上三个点之间的距离两两相同，说明距离一定是偶数，并且终点一定重合</p>
<p>考虑枚举中点，要求的就是三个点到中点距离相同的方案数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> head[N], to[N], nex[N], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   to[++ cnt] = y;</span><br><span class="line">   nex[cnt] = head[x];</span><br><span class="line">   head[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="type">long</span> <span class="type">long</span> s = <span class="number">0</span>, f = <span class="number">1</span>; <span class="type">char</span> ch;</span><br><span class="line">   <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = <span class="built_in">getchar</span>())) (ch == <span class="string">&#x27;-&#x27;</span>) &amp;&amp; (f = -f);</span><br><span class="line">   <span class="keyword">for</span>(s = ch ^ <span class="number">48</span>;<span class="built_in">isdigit</span>(ch = <span class="built_in">getchar</span>()); s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="number">48</span>));</span><br><span class="line">   <span class="keyword">return</span> s * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> md, g[N], d[N];</span><br><span class="line">LL f1[N], f2[N], f3[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> i, y;</span><br><span class="line">   md = <span class="built_in">max</span>(md, d[x]), ++ g[d[x]];</span><br><span class="line">   <span class="keyword">for</span> (i = head[x]; i; i = nex[i])</span><br><span class="line">   &#123;</span><br><span class="line">      y = to[i];</span><br><span class="line">      <span class="keyword">if</span> (y == fa) <span class="keyword">continue</span>;</span><br><span class="line">      d[y] = d[x] + <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">dfs</span>(y, x);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">query</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> i, j, y; <span class="function">LL <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="comment">// memset(f1, 0, sizeof f1),memset(f2, 0, sizeof f2), memset(f3, 0, sizeof f3);</span></span><br><span class="line">   <span class="keyword">for</span> (i = head[x]; i; i = nex[i])</span><br><span class="line">   &#123;</span><br><span class="line">      y = to[i];</span><br><span class="line">      d[y] = md = <span class="number">1</span>, <span class="built_in">dfs</span>(y, x);</span><br><span class="line">      <span class="keyword">for</span> (j = md; j &gt;= <span class="number">1</span>; -- j)</span><br><span class="line">      &#123;</span><br><span class="line">         f3[j] += (LL)f2[j]*g[j];</span><br><span class="line">         f2[j] += (LL)f1[j]*g[j];</span><br><span class="line">         f1[j] += (LL)g[j];</span><br><span class="line">         g[j] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) ans += f3[i];</span><br><span class="line">   <span class="keyword">for</span> ( i = <span class="number">1</span>; i &lt;= md&lt;&lt;<span class="number">1</span>; ++ i) f1[i] = f2[i] = f3[i] = <span class="number">0</span>; </span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) </span><br><span class="line">   <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> i, n, x, y;</span><br><span class="line">   <span class="function">LL <span class="title">res</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">   n = <span class="built_in">read</span>();</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line">   &#123;</span><br><span class="line">      x = <span class="built_in">read</span>();</span><br><span class="line">      y = <span class="built_in">read</span>();</span><br><span class="line">      <span class="built_in">add</span>(x, y);</span><br><span class="line">      <span class="built_in">add</span>(y, x);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) res += <span class="built_in">query</span>(i, n);</span><br><span class="line">   cout &lt;&lt; res;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最长道路tree">最长道路tree</h3>
<p><a href="https://darkbzoj.tk/problem/2870">click</a></p>
<p>树的直径加并查集</p>
<p>把权值从大到小排序，按照顺序加点，维护每个联通块的最长链乘以当前点权值作为贡献</p>
<p>考虑在连上一条边之后，如何快速找到新的直径？</p>
<p>这里GXZ大佬给出了我们一个结论：将两棵树连成一棵，新树的直径的两端点只可能是原来两棵树里面两条直径四个端点中的某一个</p>
<p>要用并查集维护树的直径长度以及端点位置，倍增求LCA</p>
<p>开LL</p>
<p><strong>PS</strong>：如果用LL全部替换掉int的话，大概率会T，我们只需要对查询函数以及答案开LL就可以了</p>
<p>还有，初始化的时候，尽量多初始化一点，但是也不要用memset，大概率会T</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//东方之珠 整夜未眠！</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> head[N], to[N], nex[N], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   to[++ cnt] = y;</span><br><span class="line">   nex[cnt] = head[x];</span><br><span class="line">   head[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> v[N], d[N], f[N], id[N];</span><br><span class="line"><span class="type">int</span> fa[N][<span class="number">18</span>], logs[N], px[N], py[N];</span><br><span class="line"><span class="function">LL <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;<span class="keyword">return</span> v[a] &gt; v[b];&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">return</span> f[x] == x ? x : f[x] = <span class="built_in">find</span>(f[x]);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> i, y;</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; i) &lt;= d[x]; ++ i) fa[x][i] = fa[fa[x][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">   <span class="keyword">for</span> (i = head[x]; i; i = nex[i])</span><br><span class="line">   &#123;</span><br><span class="line">      y = to[i];</span><br><span class="line">      <span class="keyword">if</span> (y == fa[x][<span class="number">0</span>]) <span class="keyword">continue</span>;</span><br><span class="line">      fa[y][<span class="number">0</span>] = x;</span><br><span class="line">      d[y] = d[x] + <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">dfs</span>(y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line">   <span class="keyword">if</span> (d[x] &lt; d[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">   <span class="keyword">for</span> (i = logs[d[x] - d[y]]; ~i; -- i)</span><br><span class="line">      <span class="keyword">if</span> (d[x] - d[y] &gt;= (<span class="number">1</span> &lt;&lt; i))</span><br><span class="line">         x = fa[x][i];</span><br><span class="line">   <span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;</span><br><span class="line">   <span class="keyword">for</span> (i = logs[d[x]]; ~i; -- i)</span><br><span class="line">      <span class="keyword">if</span> (d[x] &gt;= (<span class="number">1</span> &lt;&lt; i) &amp;&amp; fa[x][i] != fa[y][i])</span><br><span class="line">         x = fa[x][i], y = fa[y][i];</span><br><span class="line">   <span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">dis</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;<span class="keyword">return</span> d[x] + d[y] - (d[<span class="built_in">lca</span>(x, y)] &lt;&lt; <span class="number">1</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> i, tx, ty, t, vm, vx, vy, y;</span><br><span class="line">   <span class="keyword">for</span> (i = head[x]; i; i = nex[i])</span><br><span class="line">   &#123;</span><br><span class="line">      y = to[i];</span><br><span class="line">      <span class="keyword">if</span> (f[y])</span><br><span class="line">      &#123;</span><br><span class="line">         tx = <span class="built_in">find</span>(x), ty = <span class="built_in">find</span>(y), vm = <span class="number">-1</span>;</span><br><span class="line">         <span class="keyword">if</span> (vm &lt; (t = <span class="built_in">dis</span>(px[tx], py[tx]))) vm = t, vx = px[tx], vy = py[tx];      </span><br><span class="line">         <span class="keyword">if</span> (vm &lt; (t = <span class="built_in">dis</span>(px[ty], py[ty]))) vm = t, vx = px[ty], vy = py[ty];</span><br><span class="line">         <span class="keyword">if</span> (vm &lt; (t = <span class="built_in">dis</span>(px[tx], px[ty]))) vm = t, vx = px[tx], vy = px[ty];</span><br><span class="line">         <span class="keyword">if</span> (vm &lt; (t = <span class="built_in">dis</span>(px[tx], py[ty]))) vm = t, vx = px[tx], vy = py[ty];</span><br><span class="line">         <span class="keyword">if</span> (vm &lt; (t = <span class="built_in">dis</span>(py[tx], px[ty]))) vm = t, vx = py[tx], vy = px[ty];</span><br><span class="line">         <span class="keyword">if</span> (vm &lt; (t = <span class="built_in">dis</span>(py[tx], py[ty]))) vm = t, vx = py[tx], vy = py[ty];</span><br><span class="line">         f[ty] = tx, px[tx] = vx, py[tx] = vy;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   tx = <span class="built_in">find</span>(x);</span><br><span class="line">   ans = <span class="built_in">max</span>(ans, (LL)v[x] * (<span class="built_in">dis</span>(px[tx], py[tx]) + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> i, x, y, n;</span><br><span class="line">   cin &gt;&gt; n;</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;v[i]), id[i] = i;</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">scanf</span> (<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">      <span class="built_in">add</span>(x, y);</span><br><span class="line">      <span class="built_in">add</span>(y, x);</span><br><span class="line">      logs[i] = logs[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">   <span class="built_in">sort</span>(id + <span class="number">1</span>, id + n + <span class="number">1</span>, cmp);</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">   &#123;</span><br><span class="line">      f[id[i]] = px[id[i]] = py[id[i]] = id[i];</span><br><span class="line">      <span class="built_in">solve</span>(id[i]);</span><br><span class="line">   &#125;</span><br><span class="line">   cout &lt;&lt; ans;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="精神污染">精神污染</h3>
<p><a href="https://darkbzoj.tk/problem/3772">click</a></p>
<p>不会！</p>
]]></content>
      <categories>
        <category>暑假日常</category>
      </categories>
      <tags>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title>8.17DAY1</title>
    <url>/2020/08/17/8.17DAY1/</url>
    <content><![CDATA[<h1 id="上午">上午</h1>
<p>讲二分与分治 <span id="more"></span>
总体感觉收获不大，他讲比较慢，我走一会思再回来继续听，发现还是在讲同一道题.....</p>
<p>讲的倒也不是不好，很透彻清晰，估计是对那些初中生有些关照吧</p>
<p>给出几道可做不太难但是需要一些前置技能和一些细节的普及组的题目</p>
<h3 id="书的复制">书的复制</h3>
<p><a href="https://www.luogu.com.cn/problem/P1281">click</a></p>
<p>二分答案，考虑如果正着搞的话，显然是前边分的书多，后边少</p>
<p>题目要求后边多，前边尽可能少，也就是要你倒着去搞</p>
<h3 id="函数">函数</h3>
<p><a href="https://www.luogu.com.cn/problem/P1258">click</a></p>
<p>考虑对两边同时开log，然后魔改</p>
<p><span class="math inline">\(x^x
=10^{n-1}\)</span>，同时对两边去个<span
class="math inline">\(log\)</span>，先别管底数是谁</p>
<p><span class="math inline">\(log(x^x) = log(10^{n-1}) --&gt;x\times
log(x) = (n-1)\times log(10)\)</span></p>
<p>去底数为10，此时式子转化为：<span class="math inline">\(x\times
log(x) = n - 1\)</span></p>
<p>所以<span class="math inline">\(n = floor(x \times log(x) +
1)\)</span>，然后二分在实数域求值即可</p>
<h3 id="小车">小车</h3>
<p><a href="https://www.luogu.com.cn/problem/P1258">click</a></p>
<p>显然是A先坐车到达某个地方，然后A往终点走，车掉头回去接B，然后一起到达终点</p>
<p>二分车把A送到哪里最合适即可</p>
<h3 id="平面最近点对">平面最近点对</h3>
<p><a href="https://www.luogu.com.cn/problem/P1429">click</a></p>
<p>分治</p>
<p>考虑已经在左边有了答案<span
class="math inline">\(d1\)</span>,右边有了答案<span
class="math inline">\(d2\)</span>,取<span class="math inline">\(d =
Min(d1, d2)\)</span></p>
<p>考虑一个点与另一个点的连线跨越中间边的情况，是否可能会更新答案</p>
<p>考虑可能影响到答案的情况，显然，对于中间边两边水平距离为<span
class="math inline">\(d\)</span>，显然都有可能</p>
<p>但是这样还是不够优化，还需要继续优化</p>
<p>考虑<span
class="math inline">\(y\)</span>轴，对于每一个处于左边的点，还要通过<span
class="math inline">\(y\)</span>轴去判断他是否可能更新答案</p>
<p>我感觉我说的也不是太透彻，感觉这里<a
href="https://oi-wiki.org/geometry/nearest-points/">挺好</a></p>
<h3 id="传送带">传送带</h3>
<p><a href="https://www.luogu.com.cn/problem/P2571">click</a></p>
<p>显然最优路线是<span
class="math inline">\(A-E-F-D\)</span>,其中EF均属于AB，CD</p>
<p>然后我就不太<a
href="https://blog.csdn.net/YihAN_Z/article/details/58190194">透彻</a>了</p>
<h3 id="影子">影子</h3>
<p>没有给出链接</p>
<p>大致就是一道数学的分类讨论题，一个人站在一个灯底下，人可以左右移动，问影子最长是多少？</p>
<p>1.影子不在墙上，可以通过一个典型的相似三角形求出来</p>
<p>2.影子一部分落到了墙上，显然不在墙上的部分等于身高，在墙上的部分可以通过两个相似三角形也能求出比例关系</p>
<h1 id="下午">下午</h1>
<p>考试</p>
<h3 id="序列">序列</h3>
<p>有1到n这n个整数，把这n个整数排成一行使其满足一定的条件</p>
<ul>
<li><p>1最长上升子序列的长度为x</p></li>
<li><p>2最长下降子序列的长度为y</p></li>
</ul>
<p>如果有多个满足要求的排列，输出字典序最小的一个</p>
<p>给出七十分代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//ä¸œæ–¹ä¹‹ç  æ•´å¤œæœªçœ ï¼?</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">1e5</span>+<span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[M], a[M], d[M], v[M], c[M];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, X, Y, N, flag;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (flag) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (k == N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">        <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">res1</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">res2</span><span class="params">(<span class="number">0</span>)</span>, i, j</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i] = d[i] = <span class="number">1</span>;;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; i; ++ j) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[j] &lt; a[i]) f[i] = <span class="built_in">max</span>(f[j]+<span class="number">1</span>, f[i]);</span><br><span class="line">                <span class="keyword">if</span> (a[j] &gt; a[i]) d[i] = <span class="built_in">max</span>(d[j]+<span class="number">1</span>, d[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) </span><br><span class="line">        &#123;</span><br><span class="line">            res1 = <span class="built_in">max</span>(res1, f[i]);</span><br><span class="line">            res2 = <span class="built_in">max</span>(res2, d[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res1 == X &amp;&amp; res2 == Y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) c[i] = a[i];</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (v[i]) <span class="keyword">continue</span>;</span><br><span class="line">        v[i] = <span class="number">1</span>;</span><br><span class="line">        a[++ k] = i;</span><br><span class="line">        <span class="built_in">dfs</span>(i + <span class="number">1</span>, k);</span><br><span class="line">        v[i] = <span class="number">0</span>;</span><br><span class="line">        -- k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cout &lt;&lt; c[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, k, n, x, y, m, <span class="built_in">res</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;x, &amp;y);</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">7</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        N = n, X = x, Y = y;</span><br><span class="line">        <span class="built_in">work</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;		</span><br><span class="line">    &#125;</span><br><span class="line">    m = n, k = (n - y + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = k; i &lt;= n; ++ i) a[i] = (m --);</span><br><span class="line">    <span class="keyword">if</span> (k == x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; k; ++ i) cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = k; i &lt;= n; ++ i) cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k &lt; x) &#123;<span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="type">int</span> maxh = k - <span class="number">1</span>; j = maxh;</span><br><span class="line">    <span class="type">int</span> cha = k - x;</span><br><span class="line">    <span class="type">int</span> yhm = cha + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (yhm &gt; y) &#123;<span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    j -= cha;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; j; ++ i) cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = maxh; i &gt;= j; -- i) cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = k; i &lt;= n; ++ i) cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="链接">链接</h3>
<p>​ 小王来到了一片森林，森林中有一些树和连接两棵树的无向道路。</p>
<p>​ 小王对这片森林做了一些考察，有了两个奇怪的发现：</p>
<p>​ 1）森林中的树总共分为两种，不妨记为0型树和1型树。</p>
<p>​ 2）这些道路的长度都是2的整数次幂且互不相同，第ii条道路的长度为<span
class="math inline">\(2^i\)</span>。</p>
<p>​
小王又发现了这片森林的一个神奇之处，任何两棵类型不同的树之间都可以构成一组链接，这一对链接的能量值为两棵树之间的最短路。</p>
<p>​ 好奇的小王想知道这片森林所有链接的能量值之和，请你来帮帮他。</p>
<p>四十分代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="comment">// #define debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//东方之珠 整夜未眠！</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">66</span>, mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;LL, <span class="type">int</span>&gt; pr;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> head[N], to[N], nex[N], cnt; LL len[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, LL z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    to[++ cnt] = y;</span><br><span class="line">    len[cnt] = z;</span><br><span class="line">    nex[cnt] = head[x];</span><br><span class="line">    head[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">ksm</span><span class="params">(LL a, LL b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">LL <span class="title">res</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b&amp;<span class="number">1</span>) res = res * a;</span><br><span class="line">        a = a * a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;pr, vector&lt;pr&gt;, greater&lt;pr&gt; &gt;q;</span><br><span class="line"><span class="type">int</span> v[N]; LL dis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dij</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, x, y;</span><br><span class="line">    LL z;</span><br><span class="line">    <span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="keyword">sizeof</span> v);</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">    dis[s] = <span class="number">0</span>, q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">0</span>, s));</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        z = q.<span class="built_in">top</span>().first, x = q.<span class="built_in">top</span>().second; q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (v[x]) <span class="keyword">continue</span>;</span><br><span class="line">        v[x] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = head[x]; i; i = nex[i])</span><br><span class="line">        &#123;</span><br><span class="line">            y = to[i];</span><br><span class="line">            <span class="keyword">if</span> (dis[y] &gt; z + len[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[y] = z + len[i];</span><br><span class="line">                <span class="keyword">if</span> (! v[y])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(<span class="built_in">pr</span>(dis[y], y));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">thestars</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, x, y, n, m;</span><br><span class="line">    LL z, <span class="built_in">res</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        z = <span class="built_in">ksm</span>(<span class="number">2</span>, i);</span><br><span class="line">        <span class="built_in">add</span>(x, y, z);</span><br><span class="line">        <span class="built_in">add</span>(y, x, z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (x = <span class="number">1</span>; x &lt;= n; ++ x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">dij</span>(x);</span><br><span class="line">        <span class="keyword">for</span> (i = x + <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// if (i == x) continue;</span></span><br><span class="line">            <span class="comment">// if (x == 2 &amp;&amp; y == 3) cout &lt;&lt; &quot;herre\n&quot;;</span></span><br><span class="line">            <span class="comment">// if (i &lt; x || a[x] == a[i]) continue;</span></span><br><span class="line">            <span class="keyword">if</span> (a[x] == a[i]) <span class="keyword">continue</span>;</span><br><span class="line">            res = (res + dis[i])%mod;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> debug</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;x===&gt;&quot;</span> &lt;&lt;x &lt;&lt; <span class="string">&quot; i----&gt;&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; len[i]----&gt;&quot;</span> &lt;&lt; dis[i] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res%mod;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="游戏">游戏</h3>
<p>小王和小杨在二维平面上玩一个石头游戏。平面上共有nn个点供他们放置石头。当然，放石头会有一些规则限制：</p>
<p>​ 1）游戏开始前，石头在第一个点处</p>
<p>​ 2）小王和小杨交替放置石头，小王先放</p>
<p>​ 3）第一次放置，可以把石头放在除了第一个点之外的任何一个点处</p>
<p>​
4）从第二次放置开始，假设石头当前在x号点处并且上一次石头移动的距离为d，玩家可以把石头移到y点当且仅当<span
class="math inline">\(distance(x,y)&gt;d\)</span>并且yy点从未被放置过，注意，这里的<span
class="math inline">\(distance(x,y)\)</span>就是x,y两位置的间距，本题中的距离都采用欧几里得距离</p>
<p>​ 5）当一个玩家无处可放时，他输了</p>
<p>​ 小王和小杨都采取最优策略，请你告诉他们谁将获得胜利。</p>
<h1 id="晚上">晚上</h1>
<p>练习</p>
]]></content>
      <categories>
        <category>qbxt一次</category>
      </categories>
      <tags>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title>8.19DAY3</title>
    <url>/2020/08/19/8.19Day3/</url>
    <content><![CDATA[<p>讲了十六道题 <span id="more"></span> 等我稍后整理</p>
]]></content>
      <categories>
        <category>qbxt一次</category>
      </categories>
      <tags>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title>8.18DAY2</title>
    <url>/2020/08/18/8.18Day2/</url>
    <content><![CDATA[<h1 id="上午">上午</h1>
<p>讲了一道与二分有一点关系的题 <span id="more"></span></p>
<h3 id="消防">消防</h3>
<p><a href="https://darkbzoj.tk/problem/2282">click</a></p>
<ul>
<li><p>1.要找的路径一定在直径上。</p>
<p>很容易用反证法证明，只需讨论该路径与直径有交集和无交集的情况。</p>
<p>若有多条直径，随便讨论一条都行。</p></li>
<li><p>2.任意找出一条直径，将直径上的边权值设为0，再BFS一遍，就可以找出所有点到直径的最短距离。</p></li>
<li><p>3.从“枢纽路径”到每个点的最大距离有两种情况</p>
<p>A.枢纽到该点 B.枢纽到直径的端点</p></li>
<li><p>4.二分直径两端要去掉的长度。
然后再判断剩余的长度满不满足题目中要求的最大长度。</p>
<p>二分的下限为所有点到枢纽路径的距离中的最大者</p>
<p>二分的上限为直径的长度</p></li>
</ul>
<p>有一些细节，详见代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//东方之珠 整夜未眠！</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span>+<span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> to[N &lt;&lt; <span class="number">1</span>], nex[N &lt;&lt; <span class="number">1</span>], len[N &lt;&lt; <span class="number">1</span>], head[N &lt;&lt; <span class="number">1</span>], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    to[++ cnt] = y;</span><br><span class="line">    len[cnt] = z;</span><br><span class="line">    nex[cnt] = head[x];</span><br><span class="line">    head[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dis[N], fa[N], v[N], tot, f[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">-1</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q; <span class="type">int</span> i, x, y;</span><br><span class="line">    dis[now] = <span class="number">0</span>, q.<span class="built_in">push</span>(now);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        x = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (i = head[x]; i; i = nex[i])</span><br><span class="line">        &#123;</span><br><span class="line">            y = to[i];</span><br><span class="line">            <span class="keyword">if</span> (dis[y] != <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            fa[y] = x;</span><br><span class="line">            <span class="keyword">if</span> (v[y]) dis[y] = dis[x];</span><br><span class="line">            <span class="keyword">else</span> dis[y] = dis[x] + len[i];</span><br><span class="line">            <span class="comment">//对于前两个bfs，我们都没有用到v，显然这么写是没有问题的</span></span><br><span class="line">            <span class="comment">//而对于第三个bfs，我们的v数组表示，直径上的点的距离都是零(人为规定)</span></span><br><span class="line">            q.<span class="built_in">push</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> mid, <span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = tot;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= tot &amp;&amp; f[<span class="number">1</span>] - f[l + <span class="number">1</span>] &lt;= mid) ++ l;</span><br><span class="line">    <span class="keyword">while</span> (r &gt;= <span class="number">1</span> &amp;&amp; f[r] &lt;= mid) -- r;</span><br><span class="line">    <span class="keyword">return</span> f[l] - f[r + <span class="number">1</span>] &lt;= s;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    while (r &gt;= 1 &amp;&amp; f[r + 1] &lt;= mid) -- r;</span></span><br><span class="line"><span class="comment">    return f[l] - f[r] &lt;= s;</span></span><br><span class="line"><span class="comment">    这么写也是可以的</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, x, y, z, n, s, <span class="built_in">From</span>(<span class="number">0</span>), <span class="built_in">To</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;s);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">        <span class="built_in">add</span>(x, y, z);</span><br><span class="line">        <span class="built_in">add</span>(y, x, z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="keyword">if</span> (dis[i] &gt; dis[From]) From = i;</span><br><span class="line">    <span class="built_in">bfs</span>(From);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="keyword">if</span> (dis[i] &gt; dis[To]) To = i;</span><br><span class="line">    <span class="type">int</span> d = dis[To];</span><br><span class="line">    f[++ tot] = dis[To]; v[To] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (From != To)</span><br><span class="line">    &#123;</span><br><span class="line">        f[++ tot] = dis[fa[To]];</span><br><span class="line">        To = fa[To];</span><br><span class="line">        v[To] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bfs</span>(To);</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = d, mid;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) l = <span class="built_in">max</span>(l, dis[i]);</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//我们尝试在左右两边都减掉mid，然后再判断剩余的长度是否满足题目中要求的长度</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">pd</span>(mid, s)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; l;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
<p>还讲了一些贪心的例题，不是太多，但是我感觉都挺经典的</p>
<h3 id="合并果子">合并果子</h3>
<p>每次选出最小的两个来合并，哈夫曼树？</p>
<h3 id="钓鱼">钓鱼</h3>
<p><a href="https://www.luogu.com.cn/problem/P1717">click</a></p>
<p>显然无论任何一种做法，都是走一遍的，因为来回走，显然不优</p>
<p>考虑dp</p>
<p>状态：<span
class="math inline">\(f[i][j]\)</span>表示在j个单位时间内，在前i个池塘中最多能钓的鱼数</p>
<p>转移：<span class="math inline">\(f[i][j] = Max(f[i-1][j],f[i-1][
j-k-walk[i]]+GetFish[i][k])\)</span></p>
<p>结果：<span class="math inline">\(f[m][n]\)</span></p>
<p>考虑贪心</p>
<p>脑子里不由得怎么响起了cjh的毒瘤反问“贪心？怎么贪？搜索？怎么搜？”</p>
<p>由于只能走一边，所以我们考虑对于每一个点都作为终点来跑一边</p>
<p>假设以i号池塘作为终点，那么先用总时间减去从1号池塘到i号池塘行走耗费的时间,<span
class="math inline">\(Fish_Time=h-walk[i]\)</span>，那么剩下的时间(Fish_Time)就是用来钓鱼的时间了。</p>
<p>现在就相当于现在可以在1到i号池塘间任意瞬间移动了，每一个单位时间选当前能够钓到鱼最多的池塘来钓就行了，选最大用大根堆实现。</p>
<ul>
<li>1.每次从堆顶取出能钓到最大数量鱼的湖，并在那里钓一个单位时间的鱼，将钓到的鱼累加钓鱼的总数上;</li>
<li>2.把该湖下一个单位时间能钓鱼的数量更新(减去di)后，重新存入堆中；</li>
<li>3.总钓鱼时间减去一个单位的时间，重复该过程，直到没有时间或没有鱼可钓了为止;</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span> maxn=<span class="number">10001</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> f,d;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt;(node x)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> f&lt;x.f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[maxn];</span><br><span class="line"><span class="type">int</span> n,h,i,j,k,d[maxn],t[maxn],ans,H;</span><br><span class="line">priority_queue&lt;node&gt;q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;H;</span><br><span class="line">    H*=<span class="number">12</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        cin&gt;&gt;a[i].f;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        cin&gt;&gt;a[i].d;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">        cin&gt;&gt;t[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;       </span><br><span class="line">        h=H;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;i;j++)h-=t[j];            </span><br><span class="line">        <span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>())q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=i;++j)  </span><br><span class="line">            q.<span class="built_in">push</span>(a[j]);</span><br><span class="line">        <span class="keyword">while</span>(h&gt;<span class="number">0</span>)&#123;</span><br><span class="line">           node s;</span><br><span class="line">            s=q.<span class="built_in">top</span>(); </span><br><span class="line">        q.<span class="built_in">pop</span>();    </span><br><span class="line">                    </span><br><span class="line">            now+=s.f;    </span><br><span class="line">            s.f-=s.d;   </span><br><span class="line">            <span class="keyword">if</span>(s.f&lt;<span class="number">0</span>) s.f=<span class="number">0</span>;   </span><br><span class="line">            q.<span class="built_in">push</span>(s);</span><br><span class="line">            h--;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,now);     </span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="黑盒序列">黑盒序列</h3>
<p><a href="https://www.luogu.com.cn/problem/P1801">click</a></p>
<p>黑匣子<span class="math inline">\(hei\;xia\;zi\)</span></p>
<p>貌似有很多nb做法，splay，主席树</p>
<p>但是这里我们考虑用一种比较方便的东西来实现——大根堆与小跟堆</p>
<p>假设当前序列有t个数字</p>
<p>把数字都加到大根堆里面去，然后查询的时候，删除大根堆最大的<span
class="math inline">\(t-k+1\)</span>个数字，也就是说，大根堆里面留下了<span
class="math inline">\(k - 1\)</span>个数字</p>
<p>（目前序列的前k-1小的数字）</p>
<p>在上一个步骤里面，把每次删除的数字都压入到小根堆里面，最后小根堆里面就有了<span
class="math inline">\(t-k+1\)</span>个数字，而小根堆的堆首，就是当前第k大的数字，正确性显然</p>
<p>另：大根堆要重载小于号，小根堆重载大于号</p>
<h3 id="防晒霜">防晒霜</h3>
<p><a href="https://darkbzoj.tk/problem/1707">click</a></p>
<p>这次讲的方法我感觉冗杂，不太好，我比较喜欢简单一些的方法</p>
<p>给出一种方便简单的方法：</p>
<p>按照<span
class="math inline">\(Min(SPF)\)</span>递减的顺序排序，依次考虑每一头奶牛，对于每一个奶牛，在这头奶牛能用的防晒霜里面找SPF最大的</p>
<p>考虑贪心证明：考虑这一步的策略的作用范围扩展到后续其他奶牛之后产生的影响，每瓶防晒霜会被最大和最小两个值限制，</p>
<p>因为奶牛已经被按照<span
class="math inline">\(minSPF\)</span>排序了，所以每一个不低于当前奶牛的<span
class="math inline">\(minSPF\)</span>值的防晒霜，都不会小于后面奶牛的<span
class="math inline">\(SPF\)</span>,</p>
<p>也就是说，对于当恰奶牛可用的任意两瓶防晒霜x,y，如果发现<span
class="math inline">\(SPF[x] &lt;SPF
[y]\)</span>，那么后面奶牛只可能出现“xy都能用”，或者“xy都不能用”，或者“x能用，但是y不能用”，因此当前奶牛选择<span
class="math inline">\(maxSPF\)</span>较大的y去使用，对于整体问题的影响，显然比选择<span
class="math inline">\(maxSPF\)</span>较小的x要更好</p>
<p>另外，每一头奶牛的贡献都是1，即使让当前的奶牛放弃日光浴，留下防晒霜给后面的某一个用，结果不会变的更大</p>
<p>至此，尽量满足当前的奶牛，并选择<span
class="math inline">\(SPF\)</span>值较大的的防晒霜是一个正确的贪心策略</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Author:XuHt</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2506</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">COW</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> COW x) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> l &gt; x.l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; cow[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SPF</span> &#123;</span><br><span class="line">    <span class="type">int</span> s, c;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> SPF x) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s &gt; x.s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; spf[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;cow[i].l, &amp;cow[i].r);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;spf[i].s, &amp;spf[i].c);</span><br><span class="line">    <span class="built_in">sort</span>(cow + <span class="number">1</span>, cow + n + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">sort</span>(spf + <span class="number">1</span>, spf + m + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            <span class="keyword">if</span> (spf[j].c &amp;&amp; spf[j].s &gt;= cow[i].l &amp;&amp; spf[j].s &lt;= cow[i].r) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                spf[j].c--;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="植物大战僵尸">植物大战僵尸</h3>
<p><a href="http://oi.nks.edu.cn/zh/Problem/Details/2422">click</a></p>
<p><img
src="https://img2020.cnblogs.com/blog/1307264/202008/1307264-20200818212856351-1175642559.png" /></p>
<p><img
src="https://img2020.cnblogs.com/blog/1307264/202008/1307264-20200818212913866-160557334.png" /></p>
<h1 id="下午">下午</h1>
<p>讲了一些倍增的东西</p>
<h3 id="跑路">跑路</h3>
<p><a href="https://www.luogu.com.cn/problem/P1613">click</a></p>
<p>一道写的我自信心爆棚的题，随手切一道绿题</p>
<p>我们记录两个数组：</p>
<p><span
class="math inline">\(f[i][j][k]\)</span>表示是否有一条道路从<span
class="math inline">\(i\)</span>经过<span
class="math inline">\(2^k\)</span>到达<span
class="math inline">\(j\)</span></p>
<p><span class="math inline">\(g[i][j]\)</span>表示两个之间的距离</p>
<p>考虑转移：<span class="math inline">\(f[i][k][t- 1]\)</span>
&amp;&amp; <span class="math inline">\(f[k][j][t-1]\)</span></p>
<p>但是GXZ大佬说过，RP守恒……</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//东方之珠 整夜未眠！</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">55</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N][N][N], g[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">    <span class="type">int</span> i, j, k, t; <span class="type">int</span> x, y, n, m;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        f[x][y][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        g[x][y] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (t = <span class="number">1</span>; t &lt;= <span class="number">33</span>; ++ t) <span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= n; ++ k) <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (f[i][k][t - <span class="number">1</span>] &amp;&amp; f[k][j][t - <span class="number">1</span>])</span><br><span class="line">                  f[i][j][t] = <span class="number">1</span>, g[i][j] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= n; ++ k) <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">            g[i][j] = <span class="built_in">min</span>(g[i][j], g[i][k] + g[k][j]);</span><br><span class="line">    cout &lt;&lt; g[<span class="number">1</span>][n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="仓鼠找妹子">仓鼠找妹子</h3>
<p><a href="https://www.luogu.com.cn/problem/P3398">click</a></p>
<p>我真希望随手就能切了，但是时间显然不允许</p>
<p>我们容易发现，如果相交，记<span
class="math inline">\(x=lca(a,b)，y=lca(c,d)\)</span> ，则必有x在c ~
d路径上或y在a ~ b路径上</p>
<p>证明?：画一个图发现举不出反例就是对的</p>
<p>qbxt某dalao的原话：</p>
<p>•证明一下：易知两点的lca在其路径上。如果路径相交，那么x要么在相交的路径上，要么不在。我们不妨记相交的那段为e~f</p>
<p>•如果不在，由对称性，不妨设x靠近a，那么有a到x深度递减，b到e、e到f、f到x深度递减；同样，肯定有c到f、d到e深度递减，由此可知，y必定为f，由此得证（以上的e、f和c、d的相对位置是由对称性直接设的，各位不妨画图理解一下）</p>
<p>•如果在的话就更好证了</p>
<p>还剩下一件事情，那么如何查看一个点是否在一条路径上呢？</p>
<p>给出一个性质：即须满足该点到路径两端点的距离和等于两端点的距离，距离用lca和深度就可以了</p>
<p>设<span class="math inline">\(lca(u,v)=x\)</span>，则<span
class="math inline">\(u,v\)</span>间距则为<span
class="math inline">\(dep[u]+dep[v]-2*dep[x]\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//东方之珠 整夜未眠！</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> head[N &lt;&lt; <span class="number">1</span>], to[N &lt;&lt; <span class="number">1</span>], nex[N &lt;&lt; <span class="number">1</span>], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    to[++ cnt] = y;</span><br><span class="line">    nex[cnt] = head[x];</span><br><span class="line">    head[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> S = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> dep[N &lt;&lt; <span class="number">1</span>], f[N &lt;&lt; <span class="number">1</span>][<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, y;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= S; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (f[x][i - <span class="number">1</span>])</span><br><span class="line">            f[x][i] = f[f[x][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = head[x]; i; i = nex[i])</span><br><span class="line">    &#123;</span><br><span class="line">        y = to[i];</span><br><span class="line">        <span class="keyword">if</span> (y != f[x][<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            f[y][<span class="number">0</span>] = x;</span><br><span class="line">            dep[y] = dep[x] + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (dep[x] &lt; dep[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">    <span class="type">int</span> delta = dep[x] - dep[y];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= S; ++ i)</span><br><span class="line">        <span class="keyword">if</span> ((<span class="number">1</span> &lt;&lt; i) &amp; delta)</span><br><span class="line">            x = f[x][i];</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span> (i = S; i &gt;= <span class="number">0</span>; -- i)</span><br><span class="line">        <span class="keyword">if</span> (f[x][i] != f[y][i])</span><br><span class="line">            x = f[x][i], y = f[y][i];</span><br><span class="line">    <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">dis</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;<span class="keyword">return</span> dep[x] + dep[y] - <span class="number">2</span> * dep[<span class="built_in">LCA</span>(x, y)];&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, n, m, x, y;</span><br><span class="line">    <span class="type">int</span> a, b, c, d;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="built_in">add</span>(x, y), <span class="built_in">add</span>(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>); </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c, &amp;d);</span><br><span class="line">        x = <span class="built_in">LCA</span>(a, b), y = <span class="built_in">LCA</span>(c, d);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dis</span>(a, y) + <span class="built_in">dis</span>(y, b) == <span class="built_in">dis</span>(a, b) </span><br><span class="line">            || <span class="built_in">dis</span>(c, x) + <span class="built_in">dis</span>(x, d) == <span class="built_in">dis</span>(c, d))</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;Y&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;N&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="货车运输">货车运输</h3>
<p><a href="https://www.luogu.com.cn/problem/P1967">click</a></p>
<p>不会，留坑待填</p>
<p><img
src="https://img2020.cnblogs.com/blog/1307264/202008/1307264-20200818212159742-66637296.png" /></p>
<p><img
src="https://img2020.cnblogs.com/blog/1307264/202008/1307264-20200818212224316-1721151317.png" /></p>
<p><img
src="https://img2020.cnblogs.com/blog/1307264/202008/1307264-20200818212235482-1150082237.png" /></p>
<p><img
src="https://img2020.cnblogs.com/blog/1307264/202008/1307264-20200818212241404-911034285.png" /></p>
<p><img
src="https://img2020.cnblogs.com/blog/1307264/202008/1307264-20200818212246178-208090322.png" /></p>
<p><img
src="https://img2020.cnblogs.com/blog/1307264/202008/1307264-20200818212314342-730541515.png" /></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 10005 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 999999999</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge1</span>&#123;  </span><br><span class="line">    <span class="type">int</span> x,y,dis;</span><br><span class="line">&#125;edge1[<span class="number">50005</span>]; <span class="comment">//题目所给的图 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge2</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,next,w;</span><br><span class="line">&#125;edge2[<span class="number">100005</span>]; <span class="comment">//最大生成树的图 </span></span><br><span class="line"><span class="type">int</span> cnt,n,m,head[MAXN],deep[MAXN],f[MAXN],fa[MAXN][<span class="number">21</span>],w[MAXN][<span class="number">21</span>];</span><br><span class="line"><span class="comment">//f数组表示并查集中的父节点，fa数组表示树上的父节点，w数组表示最大载重 </span></span><br><span class="line"><span class="type">bool</span> vis[MAXN]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//前向星存图 </span></span><br><span class="line">    edge2[++cnt].next=head[from];</span><br><span class="line">    edge2[cnt].to=to;</span><br><span class="line">    edge2[cnt].w=w;</span><br><span class="line">    head[from]=cnt;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CMP</span><span class="params">(Edge1 x, Edge1 y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.dis&gt;y.dis; <span class="comment">//将边权从大到小排序 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;  <span class="comment">//并查集寻找父节点 </span></span><br><span class="line">    <span class="keyword">if</span>(f[x]!=x) f[x]=<span class="built_in">find</span>(f[x]);</span><br><span class="line">    <span class="keyword">return</span> f[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edge1+<span class="number">1</span>, edge1+m+<span class="number">1</span>, CMP); </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        f[i]=i;  <span class="comment">//并查集初始化 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(edge1[i].x)!=<span class="built_in">find</span>(edge1[i].y))&#123;</span><br><span class="line">            f[<span class="built_in">find</span>(edge1[i].x)]=<span class="built_in">find</span>(edge1[i].y);</span><br><span class="line">            <span class="built_in">addedge</span>(edge1[i].x, edge1[i].y, edge1[i].dis);</span><br><span class="line">            <span class="built_in">addedge</span>(edge1[i].y, edge1[i].x, edge1[i].dis);  <span class="comment">//无向图，双向加边 </span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;</span><br><span class="line">    vis[node]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[node]; i; i=edge2[i].next)&#123; <span class="comment">//前向星遍历 </span></span><br><span class="line">        <span class="type">int</span> to=edge2[i].to;</span><br><span class="line">        <span class="keyword">if</span>(vis[to]) <span class="keyword">continue</span>;</span><br><span class="line">        deep[to]=deep[node]+<span class="number">1</span>; <span class="comment">//计算深度 </span></span><br><span class="line">        fa[to][<span class="number">0</span>]=node; <span class="comment">//储存父节点 </span></span><br><span class="line">        w[to][<span class="number">0</span>]=edge2[i].w; <span class="comment">//储存到父节点的权值 </span></span><br><span class="line">        <span class="built_in">dfs</span>(to);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">find</span>(x)!=<span class="built_in">find</span>(y)) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//不连通，输出-1 </span></span><br><span class="line">    <span class="type">int</span> ans=INF;</span><br><span class="line">    <span class="keyword">if</span>(deep[x]&gt;deep[y]) <span class="built_in">swap</span>(x,y); <span class="comment">//保证y节点更深 </span></span><br><span class="line">    <span class="comment">//将y节点上提到于x节点相同深度 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">20</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span>(deep[fa[y][i]]&gt;=deep[x])&#123;</span><br><span class="line">            ans=<span class="built_in">min</span>(ans, w[y][i]);  <span class="comment">//更新最大载重（最小边权） </span></span><br><span class="line">            y=fa[y][i]; <span class="comment">//修改y位置 </span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(x==y) <span class="keyword">return</span> ans; <span class="comment">//如果位置已经相等，直接返回答案 </span></span><br><span class="line">    <span class="comment">//寻找公共祖先 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">20</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span>(fa[x][i]!=fa[y][i])&#123;</span><br><span class="line">            ans=<span class="built_in">min</span>(ans, <span class="built_in">min</span>(w[x][i], w[y][i])); <span class="comment">//更新最大载重（最小边权）</span></span><br><span class="line">            x=fa[x][i]; </span><br><span class="line">            y=fa[y][i]; <span class="comment">//修改x,y位置 </span></span><br><span class="line">        &#125;</span><br><span class="line">    ans=<span class="built_in">min</span>(ans, <span class="built_in">min</span>(w[x][<span class="number">0</span>], w[y][<span class="number">0</span>]));</span><br><span class="line">    <span class="comment">//更新此时x,y到公共祖先最大载重，fa[x][0], fa[y][0]即为公共祖先 </span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y,z,q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">        edge1[i].x=x;</span><br><span class="line">        edge1[i].y=y;</span><br><span class="line">        edge1[i].dis=z;</span><br><span class="line">    &#125; <span class="comment">//储存题目所给图 </span></span><br><span class="line">    <span class="built_in">kruskal</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])&#123; <span class="comment">//dfs收集信息 </span></span><br><span class="line">            deep[i]=<span class="number">1</span>; </span><br><span class="line">            <span class="built_in">dfs</span>(i);</span><br><span class="line">            fa[i][<span class="number">0</span>]=i;</span><br><span class="line">            w[i][<span class="number">0</span>]=INF;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//LCA初始化 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">20</span>; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; j++)&#123;</span><br><span class="line">            fa[j][i]=fa[fa[j][i<span class="number">-1</span>]][i<span class="number">-1</span>]; </span><br><span class="line">            w[j][i]=<span class="built_in">min</span>(w[j][i<span class="number">-1</span>], w[fa[j][i<span class="number">-1</span>]][i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=q; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">lca</span>(x,y)); <span class="comment">//回答询问 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="the-merchant">The merchant</h3>
<p><a href="http://poj.org/problem?id=3728">click</a></p>
<p>这题是真的好啊，我要是能把这道题写出来，那基本倍增就没问题了</p>
<p><span class="math inline">\(Description\)</span></p>
<p>n个城市构成一棵树，每个城市都有一种商品有一个固定的价格，一个商人要从一个城市到另一个城市，他会在路途中选取一个城市购买这种商品然后在之后的某个城市卖掉以赚取差价，问最大差价</p>
<p><span class="math inline">\(Input\)</span></p>
<p>第一行一整数n表示城市个数</p>
<p>之后n个整数val[i]表示第i个城市该种商品的价格，之后n-1行每行两个整数u和v表示u城市和v城市有路径，然后输入一整数q表示查询数，每次查询输入两个整数u和v表示商人从u到v路途中可以赚取的最大差价<span
class="math inline">\((1&lt;=n,val[i],q&lt;=50000)\)</span></p>
<p><span class="math inline">\(Output\)</span></p>
<p>对于每组查询输出一个答案</p>
<p>发现商人要走的路径大体为<span
class="math inline">\(x-&gt;LCA-&gt;y\)</span>，具体来说，不过三种：</p>
<ul>
<li><p>1.在x-&gt;LCA途中完成买卖</p></li>
<li><p>2.在LCA-&gt;y途中完成买卖</p></li>
<li><p>3.在x-&gt;LCA买，在LCA-&gt;y卖</p></li>
</ul>
<p>dalao说一眼可以看出来是树上倍增</p>
<p>显然，我们需要维护多个倍增数组</p>
<p><span class="math inline">\(Max[i][j]\)</span>：i到i的<span
class="math inline">\(2^j\)</span>之间的最大值</p>
<p><span class="math inline">\(Min[i][j]\)</span>：i到i的<span
class="math inline">\(2^j\)</span>之间的最小值</p>
<p><span class="math inline">\(Up[i][j]\)</span>：i到i的<span
class="math inline">\(2^j\)</span>父亲之间的差值最大</p>
<p><span class="math inline">\(Down[i][j]\)</span>：从i的<span
class="math inline">\(2^j\)</span>到i之间的最大差值</p>
<p>并且显然，我们所要得到的答案，只会来自于两个地方（假如是上升的）：</p>
<ul>
<li>1.前一段与后一段的最大差值 取一个最大值</li>
<li>2.后一段的最大值 减去 前一段的最小值</li>
</ul>
<p>对于第二三种情况，类比第一种就可以了</p>
<p>预处理:</p>
<p><img
src="https://img2020.cnblogs.com/blog/1307264/202008/1307264-20200818211424357-1687063529.png" /></p>
<p><img
src="https://img2020.cnblogs.com/blog/1307264/202008/1307264-20200818211432297-155611570.png" /></p>
<p>两条路径：</p>
<p><img
src="https://img2020.cnblogs.com/blog/1307264/202008/1307264-20200818211451214-905414777.png" /></p>
<p><img
src="https://img2020.cnblogs.com/blog/1307264/202008/1307264-20200818211458541-162241552.png" /></p>
<p>计算答案：</p>
<p><img
src="https://img2020.cnblogs.com/blog/1307264/202008/1307264-20200818211516339-929504769.png" /></p>
<p>困惑：为什么对于第三种情况，也要是往上跳？</p>
<p>还有别的几道好题没找到链接</p>
<h3 id="宝物">宝物</h3>
<p><img
src="https://img2020.cnblogs.com/blog/1307264/202008/1307264-20200818213843403-465421532.png" /></p>
<p>贪心可得90分，每个类，取(a+b+c)均值最大的</p>
<p><img
src="https://img2020.cnblogs.com/blog/1307264/202008/1307264-20200818214004893-708125797.png" /></p>
<p>值得注意的是：对于<span class="math inline">\(cnt_i =
0\)</span>的类，应当在搜索中直接跳过，否则可能导致T</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> _read(T&amp; x)&#123;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();<span class="type">bool</span> sign=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)sign=<span class="literal">false</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">for</span>(x=<span class="number">0</span>;<span class="built_in">isdigit</span>(ch);ch=<span class="built_in">getchar</span>())x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(!sign)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,k,K;</span><br><span class="line"><span class="type">int</span> t[<span class="number">55</span>],a[<span class="number">55</span>],b[<span class="number">55</span>],c[<span class="number">55</span>];</span><br><span class="line"><span class="type">int</span> id[<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line"><span class="type">int</span> cnt[<span class="number">55</span>];</span><br><span class="line"><span class="type">int</span> Type[<span class="number">55</span>];</span><br><span class="line"></span><br><span class="line">ll ans=<span class="number">0</span>;<span class="comment">//记得用long long 否则拿不到100分 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*void dfs(int num,int A,int B,int C)&#123;</span></span><br><span class="line"><span class="comment">    //当前讨论第num个非空类选择哪一个物品（因为选一个一定比不选优） </span></span><br><span class="line"><span class="comment">    if(num&gt;K)&#123;</span></span><br><span class="line"><span class="comment">        ans=max(ans, 1LL*A*B*C);</span></span><br><span class="line"><span class="comment">        return;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    int type=Type[num];//第num个非空类为Type[num] </span></span><br><span class="line"><span class="comment">    for(int i=1;i&lt;=cnt[type];i++)&#123;//依次尝试每一个物品 </span></span><br><span class="line"><span class="comment">        int v=id[type][i];</span></span><br><span class="line"><span class="comment">        dfs(num+1,A+a[v],B+b[v],C+c[v]);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> num,<span class="type">int</span> A,<span class="type">int</span> B,<span class="type">int</span> C)</span></span>&#123;</span><br><span class="line">    <span class="comment">//当前讨论第num个类选择哪一个物品（因为选一个一定比不选优） </span></span><br><span class="line">    <span class="keyword">if</span>(num&gt;K)&#123;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans, <span class="number">1LL</span>*A*B*C);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt[num]==<span class="number">0</span>)<span class="built_in">dfs</span>(num+<span class="number">1</span>,A,B,C);</span><br><span class="line">    <span class="type">int</span> type=num;<span class="comment">//Type[num];//第num个非空类为Type[num] </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt[type];i++)&#123;<span class="comment">//依次尝试每一个物品 </span></span><br><span class="line">        <span class="type">int</span> v=id[type][i];</span><br><span class="line">        <span class="built_in">dfs</span>(num+<span class="number">1</span>,A+a[v],B+b[v],C+c[v]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,j,type;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        _read(type);_read(a[i]);_read(b[i]);_read(c[i]);</span><br><span class="line">        cnt[type]++;  <span class="comment">//type类的物品数+1 </span></span><br><span class="line">        id[type][cnt[type]]=i;  <span class="comment">//type类的第cnt[type]个物品编号为i </span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//统计所有非空类，K表示非空种类数量，非空的种类存入Type数组 </span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt[i]==<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">        K++;</span><br><span class="line">        Type[K]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">99</span>,<span class="number">99</span>,<span class="number">99</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="赛车">赛车</h3>
<p><img
src="https://img2020.cnblogs.com/blog/1307264/202008/1307264-20200818214208869-1955415331.png" /></p>
<p><img
src="https://img2020.cnblogs.com/blog/1307264/202008/1307264-20200818214234421-2046075846.png" /></p>
<p><img
src="https://img2020.cnblogs.com/blog/1307264/202008/1307264-20200818214253574-736318410.png" /></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> _read(T&amp; x)&#123;</span><br><span class="line">    <span class="type">char</span> ch=<span class="built_in">getchar</span>();<span class="type">bool</span> sign=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))&#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)sign=<span class="literal">false</span>;ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">for</span>(x=<span class="number">0</span>;<span class="built_in">isdigit</span>(ch);ch=<span class="built_in">getchar</span>())x=x*<span class="number">10</span>+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(!sign)x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> p,a;</span><br><span class="line">    <span class="type">bool</span> mark;</span><br><span class="line">    <span class="built_in">node</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">node</span>(<span class="type">int</span> P,<span class="type">int</span> A)&#123;</span><br><span class="line">        p=P;a=A;mark=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">node car[<span class="number">50005</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node A,node B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A.a==B.a)<span class="keyword">return</span> A.p&gt;B.p;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> A.a&lt;B.a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> q[<span class="number">50005</span>];</span><br><span class="line"><span class="type">double</span> meet[<span class="number">50005</span>];</span><br><span class="line"><span class="type">int</span> rear;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="comment">//if(car[i].p==car[j].p)return 0.0;</span></span><br><span class="line">    <span class="comment">//if((car[i].a&lt;car[j].a&amp;&amp;car[j].p&gt;car[i].p)||(car[i].a&gt;car[j].a&amp;&amp;car[j].p&lt;car[i].p))return -1.0;</span></span><br><span class="line">    <span class="type">double</span> a1=car[i].a,a2=car[j].a,p1=car[i].p,p2=car[j].p;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="number">2.0</span>*(p2-p1)/(a1-a2));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;car.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="comment">//freopen(&quot;car.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    T=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> i,j,k,n;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(car,<span class="number">0</span>,<span class="built_in">sizeof</span>(car));</span><br><span class="line">        _read(n);</span><br><span class="line">        <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            _read(car[i].p);</span><br><span class="line">            _read(car[i].a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(car+<span class="number">1</span>,car+<span class="number">1</span>+n,cmp);</span><br><span class="line">        <span class="type">int</span> id=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(car[i<span class="number">-1</span>].a==car[i].a&amp;&amp;car[i<span class="number">-1</span>].p==car[i].p)&#123;</span><br><span class="line">            <span class="comment">//处理p，a都相同的车，mark为true表示存在另一个与他参数相同的车 </span></span><br><span class="line">                car[i<span class="number">-1</span>].mark=<span class="literal">true</span>;</span><br><span class="line">                car[i].mark=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> tot=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(car[i].a!=car[i<span class="number">-1</span>].a)car[++tot]=car[i]; </span><br><span class="line">            <span class="comment">//相同加速度的车我们只留一个p最大的 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//tot=保留的车的数量 </span></span><br><span class="line">        rear=<span class="number">1</span>;</span><br><span class="line">        q[rear]=<span class="number">1</span>; <span class="comment">//把第一个车加进栈 </span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=tot;i++)&#123; <span class="comment">//依次讨论每一辆车 </span></span><br><span class="line">            <span class="keyword">while</span>(rear&gt;<span class="number">0</span>&amp;&amp;car[i].p&gt;=car[q[rear]].p)rear--; </span><br><span class="line">            <span class="comment">//如果栈顶车p比当前车小，那么栈顶车可以扔掉(因为它p、a都比当前车小) </span></span><br><span class="line">            <span class="keyword">while</span>(rear&gt;=<span class="number">2</span>)&#123; <span class="comment">//栈里还有大于两个车 </span></span><br><span class="line">                <span class="comment">//meet[i]存储q[i]和q[i+1]两辆车相交的时间点 </span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">solve</span>(i,q[rear])&lt;meet[rear<span class="number">-1</span>]+<span class="number">1e-5</span>)rear--; </span><br><span class="line">                <span class="comment">//如果栈顶两车的相交点 不小于 当前车和栈顶车的相交点 栈顶可以扔掉 </span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            q[++rear]=i; <span class="comment">//当前车入栈 </span></span><br><span class="line">            <span class="keyword">if</span>(rear&gt;<span class="number">1</span>)meet[rear<span class="number">-1</span>]=<span class="built_in">solve</span>(q[rear<span class="number">-1</span>],q[rear]); <span class="comment">//存储对应meet值 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//q里面就是所有的领跑者 </span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=rear;i++)<span class="keyword">if</span>(car[q[i]].mark==<span class="literal">false</span>)ans++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>qbxt一次</category>
      </categories>
      <tags>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title>8.21DAY5</title>
    <url>/2020/08/21/8.21Day5/</url>
    <content><![CDATA[<h3 id="小鱼">小鱼</h3>
<p>题目描述</p>
<p>大鱼生活在一座海底的宫殿，宫殿里的交易货币只有<span
class="math inline">\(2\)</span>元，<span
class="math inline">\(5\)</span>元，<span
class="math inline">\(10\)</span>元，<span
class="math inline">\(20\)</span>元，50元，<span
class="math inline">\(100\)</span>元六种纸币。现在大鱼想买一根恰好<span
class="math inline">\(n\)</span>元的拐杖，不能找零，那么大鱼至少要带多少张纸币去呢？
<span id="more"></span> 输入格式</p>
<p>一行一个整数 <span class="math inline">\(n\)</span>。</p>
<p>输出格式</p>
<p>一行一个整数表示答案。</p>
<p>样例数据</p>
<p>input</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure>
<h4 id="output">output</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>样例解释​</p>
<p>带<span class="math inline">\(2\)</span>张<span
class="math inline">\(2\)</span>元，一张<span
class="math inline">\(5\)</span>元。</p>
<p>数据规模与约定</p>
<p>对于 <span class="math inline">\(30\%\)</span> 的数据，<span
class="math inline">\(n \leq 100\)</span>。</p>
<p>对于 <span class="math inline">\(60\%\)</span> 的数据，<span
class="math inline">\(n \leq 10^9\)</span>。</p>
<p>对于 <span class="math inline">\(100\%\)</span> 的数据，<span
class="math inline">\(4 \leq n \leq 10^{18}\)</span>。</p>
<p>时间限制：<span class="math inline">\(1 \text{s}\)</span></p>
<p>空间限制：<span class="math inline">\(512 \text{MB}\)</span></p>
<p>模拟就完事了</p>
<p>那么多人都出锅了，他们好菜</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="comment">// #define debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//东方之珠 整夜未眠！</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, liu, wu, si, san, er, yi, <span class="built_in">pd</span>(<span class="number">0</span>); </span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span> (n &amp; <span class="number">1</span>) n -= <span class="number">5</span>, pd = <span class="number">1</span>;</span><br><span class="line">    liu = n / <span class="number">100</span>; n %= <span class="number">100</span>;</span><br><span class="line">    wu = n / <span class="number">50</span>, n %= <span class="number">50</span>;</span><br><span class="line">    si = n / <span class="number">20</span>, n %= <span class="number">20</span>;</span><br><span class="line">    san = n / <span class="number">10</span>, n %= <span class="number">10</span>;</span><br><span class="line">    er = n / <span class="number">5</span>; n = n - er * <span class="number">5</span>; <span class="keyword">if</span> (n%<span class="number">2</span> != <span class="number">0</span>) n += er * <span class="number">5</span>; er = <span class="number">0</span>;</span><br><span class="line">    yi = n / <span class="number">2</span>, n %= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (pd) ++ er;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> debug</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;100----&gt;&quot;</span> &lt;&lt; liu &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;50----&gt;&quot;</span> &lt;&lt; wu &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;20----&gt;&quot;</span> &lt;&lt; si &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;10----&gt;&quot;</span> &lt;&lt; san &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;5----&gt;&quot;</span> &lt;&lt; er &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;2----&gt;&quot;</span> &lt;&lt; yi &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    cout &lt;&lt; liu + wu + si + san + er + yi &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="built_in">fclose</span> (stdin), <span class="built_in">fclose</span> (stdout);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2147483647214748364</span></span><br><span class="line"><span class="comment">100----&gt;21474836472147483</span></span><br><span class="line"><span class="comment">50----&gt;1</span></span><br><span class="line"><span class="comment">20----&gt;0</span></span><br><span class="line"><span class="comment">10----&gt;1</span></span><br><span class="line"><span class="comment">5----&gt;0</span></span><br><span class="line"><span class="comment">2----&gt;2</span></span><br><span class="line"><span class="comment">1----&gt;0</span></span><br><span class="line"><span class="comment">21474836472147487</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="小黑">小黑</h3>
<p>题目描述</p>
<p>小黑初始有一个<span class="math inline">\(1\)</span>到<span
class="math inline">\(n\)</span>的排列构成的序列，之后有<span
class="math inline">\(m\)</span>次修改，每次可以在任意位置删掉一个元素或者插入一个之前被删掉了的元素（即保证序列中元素各不相同）。</p>
<p>然后有<span
class="math inline">\(Q\)</span>次查询，每次给出一个序列，问这个序列在这<span
class="math inline">\(m\)</span>次修改的结果（不包括初始序列）中，是其中多少个的子串。</p>
<p>输入格式</p>
<p>第<span class="math inline">\(1\)</span>行<span
class="math inline">\(3\)</span>个整数 <span
class="math inline">\(n,m,Q\)</span>。</p>
<p>接下来<span class="math inline">\(1\)</span>行<span
class="math inline">\(n\)</span>个整数，表示初始的<span
class="math inline">\(1\)</span>到<span
class="math inline">\(n\)</span>排列。</p>
<p>接下来<span class="math inline">\(m\)</span>行，每行形式为<span
class="math inline">\(1,x\)</span>或<span
class="math inline">\(2,x,y\)</span>，分别表示删除数<span
class="math inline">\(x\)</span>和在数<span
class="math inline">\(x\)</span>后面插入数<span
class="math inline">\(y\)</span>，保证操作合法，插入操作中<span
class="math inline">\(x=0\)</span>表示在序列开头插入，操作过程中序列可能为空。</p>
<p>接下来<span class="math inline">\(Q\)</span>行，每行第<span
class="math inline">\(1\)</span>个正整数<span
class="math inline">\(k\)</span>，表示查询序列的长度，接下来<span
class="math inline">\(k\)</span>个数，表示查询序列，保证序列的元素在<span
class="math inline">\(1\)</span>到<span
class="math inline">\(n\)</span>中且各不相同。<span
class="math inline">\(k \geq 2\)</span>。</p>
<p>输出格式</p>
<p><span class="math inline">\(Q\)</span>行，每行一个整数表示答案。</p>
<p>样例数据</p>
<p>input</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 4 2</span><br><span class="line">3 1 2 4</span><br><span class="line">1 1</span><br><span class="line">1 2</span><br><span class="line">2 0 1</span><br><span class="line">2 1 2</span><br><span class="line">2 3 4</span><br><span class="line">2 1 3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>output</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>样例解释</p>
<p>序列的变化如下：</p>
<p><span class="math inline">\(3,1,2,4 \rightarrow 3,2,4 \rightarrow 3,4
\rightarrow 1,3,4 \rightarrow 1,2,3,4\)</span></p>
<p><span class="math inline">\(3,4\)</span>是其中<span
class="math inline">\(3\)</span>个的子串，<span
class="math inline">\(1,3\)</span>是其中<span
class="math inline">\(1\)</span>个的子串。</p>
<p>数据规模与约定</p>
<p>对于 <span class="math inline">\(30\%\)</span> 的数据，<span
class="math inline">\(1 \leq n,m \leq 70\)</span>。</p>
<p>对于<span class="math inline">\(60\%\)</span> 的数据，<span
class="math inline">\(1 \leq n,m \leq 500\)</span>。</p>
<p>对于 <span class="math inline">\(100\%\)</span> 的数据，<span
class="math inline">\(1 \leq n,m \leq 100000\)</span>，<span
class="math inline">\(1 \leq Q \leq 100\)</span>
，查询序列的总长度不超过<span
class="math inline">\(1000000\)</span>。</p>
<p>时间限制：<span class="math inline">\(1 \text{s}\)</span></p>
<p>空间限制：<span class="math inline">\(512 \text{MB}\)</span></p>
<p>题目保证元素不重复，所以相邻元素组成的序对在序列中是唯一的</p>
<p>一个长度为k的序列是模式序列的字串，当且仅当它的k-1个相邻元素组成的序对都在模式序列中出现过</p>
<p>所以我们在修改过程中，需要维护模式序列相邻元素组成的序对。询问序列的序对出现了k-1次，就说明它现在是模式序列的字串</p>
<p>用链表维护模式序列，开一个数组记录序对，用cnt记录出现次数即可</p>
<p>链表模拟，两个坑点</p>
<p>一定给后继赋初值，另外一定要先更新last后更新nex</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//东方之珠 整夜未眠！</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, Q;</span><br><span class="line"><span class="type">int</span> opt[N], x[N], y[N], a[N];</span><br><span class="line"><span class="type">int</span> last[N], pre[N], nex[N];</span><br><span class="line"><span class="type">int</span> cnt, res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">charu</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">if</span> (pre[x] == last[x]) ++ cnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">shanchu</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">if</span> (pre[x] == last[x]) -- cnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">yhm</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(last, <span class="number">0</span>, <span class="keyword">sizeof</span> last);</span><br><span class="line">    <span class="built_in">memset</span>(pre, <span class="number">0</span>, <span class="keyword">sizeof</span> pre);</span><br><span class="line">    <span class="built_in">memset</span>(nex, <span class="number">0</span>, <span class="keyword">sizeof</span> nex);</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">u</span><span class="params">(n + <span class="number">3</span>)</span>, v, i, k</span>;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= k; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;v);</span><br><span class="line">        pre[v] = u;</span><br><span class="line">        u = v;</span><br><span class="line">    &#125;</span><br><span class="line">    pre[n + <span class="number">4</span>] = u, cnt = res = <span class="number">0</span>;<span class="comment">//keng</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        nex[a[i]] = a[i + <span class="number">1</span>];</span><br><span class="line">        last[a[i + <span class="number">1</span>]] = a[i];</span><br><span class="line">        <span class="built_in">charu</span>(a[i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        u = x[i], v = y[i];</span><br><span class="line">        <span class="keyword">if</span> (opt[i] == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">shanchu</span>(u); <span class="built_in">shanchu</span>(nex[u]);</span><br><span class="line">            nex[last[u]] = nex[u];</span><br><span class="line">            last[nex[u]] = last[u];</span><br><span class="line">            <span class="built_in">charu</span>(nex[u]);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (! u) u = n + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">shanchu</span>(nex[u]);</span><br><span class="line">            last[v] = u, nex[v] = nex[u];</span><br><span class="line">            last[nex[u]] = v, nex[u] = v;<span class="comment">//keng</span></span><br><span class="line">            <span class="built_in">charu</span>(v), <span class="built_in">charu</span>(nex[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt == k - <span class="number">1</span>) ++ res;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;Q);</span><br><span class="line">    a[<span class="number">0</span>] = n + <span class="number">1</span>, a[n + <span class="number">1</span>] = n + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%d%d&quot;</span>, &amp;opt[i], &amp;x[i]);</span><br><span class="line">        <span class="keyword">if</span> (opt[i] != <span class="number">1</span>) <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;y[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (Q --) <span class="built_in">yhm</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="小鱼-1">小鱼</h3>
<p>题目描述</p>
<p>小鱼遇到了一个组合问题，给定正整数<span
class="math inline">\(n\)</span>，求 <span class="math display">\[
\sum_{i=1}^{n} \frac{n}{gcd(i,n)}
\]</span> 输入格式</p>
<p>第<span class="math inline">\(1\)</span>行一个整数<span
class="math inline">\(T\)</span>，表示有<span
class="math inline">\(T\)</span>个询问。</p>
<p>接下来<span class="math inline">\(T\)</span>行，每行一个数<span
class="math inline">\(n\)</span>。</p>
<p>输出格式</p>
<p><span
class="math inline">\(T\)</span>行，每行对应一个询问的答案。</p>
<p>样例数据</p>
<p>input</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>output</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">7</span><br><span class="line">11</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>数据规模与约定</p>
<p>对于 <span class="math inline">\(40\%\)</span> 的数据，<span
class="math inline">\(1 \leq n \leq 2000\)</span>。</p>
<p>对于另外 <span class="math inline">\(10\%\)</span> 的数据，保证<span
class="math inline">\(n\)</span>是质数。</p>
<p>对于另外 <span class="math inline">\(10\%\)</span> 的数据，保证<span
class="math inline">\(n\)</span>是两个质数的乘积。</p>
<p>对于 <span class="math inline">\(100\%\)</span> 的数据，<span
class="math inline">\(1 \leq T \leq 300000,1 \leq n \leq
10000000\)</span>。</p>
<p>时间限制：<span class="math inline">\(2 \text{s}\)</span></p>
<p>空间限制：<span class="math inline">\(512 \text{MB}\)</span></p>
<p><img
src="https://pic.imgdb.cn/item/6327cf9a16f2c2beb1262e2b.png" /></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//东方之珠 整夜未眠！</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e7</span>+<span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> !y ? x : <span class="built_in">gcd</span>(y, x%y);&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g[N], w[N], last[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> v[N], pri[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T, i, j, n, <span class="built_in">cnt</span>(<span class="number">0</span>);</span><br><span class="line">    w[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= N; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (! v[i])</span><br><span class="line">        &#123;</span><br><span class="line">            pri[++ cnt] = last[i] = i;</span><br><span class="line">            g[i] = w[i] = i * (i - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * pri[j] &lt;= N; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            v[i * pri[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (! (i % pri[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                g[i * pri[j]] = g[i] * pri[j] * pri[j] - pri[j] + <span class="number">1</span>;</span><br><span class="line">                w[i * pri[j]] = w[i / last[i]] * g[i * pri[j]];</span><br><span class="line">                last[i * pri[j]] = last[i] * pri[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            g[i * pri[j]] = pri[j] * (pri[j] - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            w[i * pri[j]] = w[i] * w[pri[j]];</span><br><span class="line">            last[i * pri[j]] = pri[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;i);</span><br><span class="line">        cout &lt;&lt; w[i] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>qbxt一次</category>
      </categories>
      <tags>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title>8.24DAY8(END)</title>
    <url>/2020/08/24/8.24Day8%EF%BC%88%E5%AE%8C%E7%BB%93%EF%BC%89/</url>
    <content><![CDATA[<p>今天清北学堂培训结束了 <span id="more"></span>
此刻，我正一边唱着歌，一遍写着博客</p>
<p>现在很累，就像刚刚跑完1km一样，不想学习，想听音乐，想透彻</p>
<p>但是我却不能透彻</p>
<p>只好来写写随笔，记录一下近几天的收获</p>
<p>第一天第二天讲的二分倍增贪心</p>
<p>感觉收获不少，不怵头贪心题，来二分的题目也还可以，要是tm出一道三分来，我tm直播倒立吃*</p>
<p>第三天讲了数据结构，对堆，队列，栈，并茶几有了新理解</p>
<p>第四天讲了图论，觉得也没什么，至少自己掌握了不少讨论，“开局一张图”</p>
<p><img
src="https://pic.imgdb.cn/item/6327cf1e16f2c2beb125bd53.png" /></p>
<p>第五天考试，</p>
<p>第六天dp，对“倒推”有了新理解</p>
<p><img
src="https://pic.imgdb.cn/item/6327cf1e16f2c2beb125bd58.png" /></p>
<p>第七天数论！！！对高数有了新理解</p>
<p>今天考试，艹，靠的不是太好，暴力分数没打满，可是明明感觉自己已经尽力了，能拿的分都拿了</p>
<p>或者说自己好煞笔，暴力都不会打，钟皓曦说暴力用爆艘加背包可以八十分</p>
<p>我tm背包都想不到</p>
]]></content>
      <categories>
        <category>qbxt一次</category>
      </categories>
      <tags>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title>8.26集训</title>
    <url>/2020/08/26/8.26/</url>
    <content><![CDATA[<p>今天做题</p>
<p>第一道是钓鱼 <span id="more"></span> 昨晚是用贪心写的，今天用的dp</p>
<p>写出了点锅，还没d出来，wa了几个点</p>
<p>第二道叫：P4054 [JSOI2009]计数问题</p>
<p>一个二维树状数组的板子题目</p>
<p>以前从来没写过二维树状数组，第一次写</p>
<p>第三道的话，叫P2922 [USACO08DEC]Secret Message G</p>
<p>我愿意称之为Trie树最经典例题</p>
<p>初始没思路，</p>
<p><span class="math inline">\(O(len)\)</span>插入，<span
class="math inline">\(O(1)\)</span> 查询</p>
<p>sum表示以这个节点为终点的字符串个数</p>
<p>num表示到达这个节点而且没完成的字符串个数</p>
<p>这样就不重复也不遗漏了</p>
<p>第四道叫 P2887 [USACO07NOV]Sunscreen G</p>
<p>贪心的，感觉很简单，就切了</p>
<p>第五道叫 P1792 [国家集训队]种树</p>
<p>初始没思路，但是据说<span
class="math inline">\(n^3\)</span>的dp显然？？？？？</p>
<p>是一道贪心好题，用<span class="math inline">\(a[x - 1] + a[x + 1] -
a[x]\)</span>来做反悔，因为<span class="math inline">\(a[x] + a[x - 1] +
a[x + 1] - a[x]\)</span>终究还是要等于<span class="math inline">\(a[x -
1] + a[x + 1]\)</span></p>
<p>用大根堆来维护，注意每次都要维护好链表</p>
<p>第六道也叫做种树，P1484 种树</p>
<p>这个和上边的大致题意差不多，但就是有一个条件不太一样“ｋ可以不用完”</p>
<p>刚开始可以模仿上边的思路可以做到80分，但是距离正解还差一个边界条件</p>
<p>第五道题与第六道题的推广：再次遇到那种隔着选的题，考虑大根堆和链表维护反悔</p>
<p>第七道题　lca的模板题</p>
<p>这一次完完全全的搞透彻了，有以下几个需要注意的细节：</p>
<ul>
<li><p>1.for (i = 30; i &gt;= 0; -- i) if (fa[x][i] != fa[y][i]) x =
fa[x][i], y = fa[y][i]; 需要倒着搞</p></li>
<li><p>2.必须从零开始！</p></li>
</ul>
<p>第八道题　火车</p>
<p>初始的话，思路不太通畅，隐隐约约知道合并,但是不知道具体怎么合并</p>
<p>用UFS和LCA来做，每次找完之后，顺道把路过的节点都合并起来</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title>8.27集训</title>
    <url>/2020/08/27/8.27/</url>
    <content><![CDATA[<p>今天有考试，有做题 <span id="more"></span> 第一个是单调队列的板子，</p>
<p>切了</p>
<p>注意细节与拓展：</p>
<ul>
<li>保证<span class="math inline">\(l \leq r\)</span>的情况下</li>
<li>求区间最小值，维护递减队列，如果<span
class="math inline">\(a[i]&gt;a[q[r]]\)</span>，不断缩小r</li>
<li>求区间最大值，维护递增队列，如果<span
class="math inline">\(a[i]&lt;a[q[r]]\)</span>，不断缩小r</li>
</ul>
<p>第二个是bzoj2151 火车</p>
<p>昨天没写完今天接着写的</p>
<p>细节多：</p>
<ul>
<li>dep[0] = -1，不然就GG</li>
<li>开LL</li>
<li>数组得开到<span class="math inline">\(1e6\)</span>以上</li>
</ul>
<p>然后考试了</p>
<p>考试第一题，大致就是需要在树上寻找三条链并且有相同的公共部分求得最大的累加和</p>
<p>cjh给出状态....</p>
<p><img
src="https://pic.imgdb.cn/item/6327dccf16f2c2beb1355618.png" /></p>
<p><img
src="https://pic.imgdb.cn/item/6327dcec16f2c2beb1357b01.png" /></p>
<p>然后就是转移了....</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//东方之珠 整夜未眠！</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">66</span>, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> TO[N &lt;&lt; <span class="number">1</span>], nex[N &lt;&lt; <span class="number">1</span>], head[N &lt;&lt; <span class="number">1</span>], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TO[++ cnt] = y;</span><br><span class="line">    nex[cnt] = head[x];</span><br><span class="line">    head[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, res = -inf;</span><br><span class="line"><span class="type">int</span> val[N], f[N][<span class="number">66</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[x][<span class="number">0</span>] = val[x]; <span class="type">int</span> tmp[<span class="number">8</span>], i, j, y;</span><br><span class="line">    <span class="keyword">for</span> (i = head[x]; i; i = nex[i])</span><br><span class="line">    &#123;</span><br><span class="line">        y = TO[i];</span><br><span class="line">        <span class="keyword">if</span> (y == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y, x);</span><br><span class="line">        <span class="type">int</span> *fx = f[x], *to = f[y];</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">8</span>; ++ j) tmp[j] = fx[j];</span><br><span class="line"></span><br><span class="line">        tmp[<span class="number">1</span>] = <span class="built_in">max</span>(tmp[<span class="number">1</span>], fx[<span class="number">0</span>] + <span class="built_in">max</span>(to[<span class="number">0</span>], to[<span class="number">1</span>]));</span><br><span class="line">        tmp[<span class="number">4</span>] = <span class="built_in">max</span>(tmp[<span class="number">4</span>], fx[<span class="number">0</span>] + <span class="built_in">max</span>(to[<span class="number">3</span>], to[<span class="number">4</span>]));</span><br><span class="line">        tmp[<span class="number">7</span>] = <span class="built_in">max</span>(tmp[<span class="number">7</span>], fx[<span class="number">0</span>] + <span class="built_in">max</span>(to[<span class="number">6</span>], to[<span class="number">7</span>]));</span><br><span class="line">        tmp[<span class="number">2</span>] = <span class="built_in">max</span>(tmp[<span class="number">2</span>], fx[<span class="number">1</span>] + <span class="built_in">max</span>(to[<span class="number">0</span>], to[<span class="number">1</span>]));</span><br><span class="line">        tmp[<span class="number">5</span>] = <span class="built_in">max</span>(tmp[<span class="number">5</span>], fx[<span class="number">1</span>] + <span class="built_in">max</span>(to[<span class="number">3</span>], to[<span class="number">4</span>]));</span><br><span class="line"></span><br><span class="line">        res = <span class="built_in">max</span>(res, <span class="built_in">max</span>(fx[<span class="number">0</span>], fx[<span class="number">1</span>]) + <span class="built_in">max</span>(to[<span class="number">6</span>], to[<span class="number">7</span>]));</span><br><span class="line"></span><br><span class="line">        tmp[<span class="number">3</span>] = <span class="built_in">max</span>(tmp[<span class="number">3</span>], fx[<span class="number">2</span>] + <span class="built_in">max</span>(to[<span class="number">0</span>], to[<span class="number">1</span>]));</span><br><span class="line">        tmp[<span class="number">6</span>] = <span class="built_in">max</span>(tmp[<span class="number">6</span>], fx[<span class="number">2</span>] + <span class="built_in">max</span>(to[<span class="number">3</span>], to[<span class="number">4</span>]));</span><br><span class="line">        tmp[<span class="number">5</span>] = <span class="built_in">max</span>(tmp[<span class="number">5</span>], fx[<span class="number">4</span>] + <span class="built_in">max</span>(to[<span class="number">0</span>], to[<span class="number">1</span>]));</span><br><span class="line">        tmp[<span class="number">6</span>] = <span class="built_in">max</span>(tmp[<span class="number">6</span>], fx[<span class="number">5</span>] + <span class="built_in">max</span>(to[<span class="number">0</span>], to[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">        res = <span class="built_in">max</span>(res, <span class="built_in">max</span>(fx[<span class="number">3</span>], fx[<span class="number">4</span>]) + <span class="built_in">max</span>(to[<span class="number">3</span>], to[<span class="number">4</span>]));</span><br><span class="line">        res = <span class="built_in">max</span>(res, <span class="built_in">max</span>(fx[<span class="number">6</span>], fx[<span class="number">7</span>]) + <span class="built_in">max</span>(to[<span class="number">0</span>], to[<span class="number">1</span>]));</span><br><span class="line">        res = <span class="built_in">max</span>(res, tmp[<span class="number">7</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">8</span>; ++ j) fx[j] = tmp[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, x, y;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) cin &gt;&gt; val[i];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="built_in">add</span> (x, y), <span class="built_in">add</span>(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span> (f, <span class="number">0xf3</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
<p>第二题</p>
<p><img
src="https://pic.imgdb.cn/item/6327dd0616f2c2beb1359b47.png" /></p>
<p>矩阵 + BSGS</p>
<p>第三题</p>
<p>求前缀最大值有a个，后缀最大值有b个的长度为n的排列个数。</p>
<p>显然每一个前缀最大值和一段连续的区间构成了一个环排列，显然每个前缀最大值就是这个环中的最大值。</p>
<p>而全局最大值一定把前后缀最大值分开。
所以答案考虑除最大值外，左侧需要a−1个前缀最大值，右侧需要b−1个前缀最大值。也就是一共要a+b−2个环，</p>
<p>那么这一部分的贡献是<span
class="math inline">\(\begin{bmatrix}n-1\\a+b-2\end{bmatrix}\)</span>,
而环在左右随意分配，所以再乘上一个<span
class="math inline">\(a+b-2\choose a-1\)</span></p>
<p>解释一个小问题，为什么不需要考虑环的最大值的大小关系，因为我们强制在排列过程中按照最大值从小往大放，而每个环因为放置的时候是一个线段，那么我们保证最大值一定在靠外侧，这样子后面的比它小的值必定不是前缀或者后缀最大值。</p>
<p>那么问题转化成了怎么预处理第一类斯特林数</p>
<p>第一类斯特林数：</p>
<p><span
class="math inline">\(\begin{bmatrix}n\\m\end{bmatrix}\)</span>表示n个元素分成m个环的方案数。</p>
<p>那么递推式很显然：<span
class="math inline">\(\begin{bmatrix}n\\m\end{bmatrix}=\begin{bmatrix}n-1\\m-1\end{bmatrix}+(n-1)*\begin{bmatrix}n-1\\m\end{bmatrix}\)</span></p>
<p>即考虑先前已经放好的n−1个数，当前新加入的这个元素有两种选择，第一种是自己成一个环，贡献是<span
class="math inline">\(\begin{bmatrix}n-1\\m-1\end{bmatrix}\)</span></p>
<p>第二种是放到环内，那么它可以放在任意一个数的前面，所以就是<span
class="math inline">\((n-1)*\begin{bmatrix}n-1\\m\end{bmatrix}\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="comment">// #define debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//东方之珠 整夜未眠！</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span>+<span class="number">66</span>, mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">ksm</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (! b) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (b &amp; <span class="number">1</span>) <span class="keyword">return</span> a * <span class="built_in">ksm</span>(a, b<span class="number">-1</span>) % mod;</span><br><span class="line">    <span class="type">int</span> tmp = <span class="built_in">ksm</span>(a, b/<span class="number">2</span>)%mod;</span><br><span class="line">    <span class="keyword">return</span> tmp * tmp % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N][N], js[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, res, n, m, a, b;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; a &gt;&gt; b; -- n;</span><br><span class="line">    js[<span class="number">0</span>] = <span class="number">1</span>, m = a + b - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= (a + b)&lt;&lt;<span class="number">1</span>; ++ i) js[i] = js[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    res = js[m] * <span class="built_in">ksm</span>(js[a - <span class="number">1</span>], mod - <span class="number">2</span>) % mod * <span class="built_in">ksm</span>(js[b - <span class="number">1</span>], mod - <span class="number">2</span>) % mod;</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= i; ++ j)</span><br><span class="line">            f[i][j] = (f[i - <span class="number">1</span>][j - <span class="number">1</span>] + (i - <span class="number">1</span>) * f[i - <span class="number">1</span>][j] % mod) % mod;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> debug</span></span><br><span class="line">cout &lt;&lt; f[n][m];</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    cout &lt;&lt; f[n][m]*res%mod;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title>8.20DAY4</title>
    <url>/2020/08/20/8.20Day4/</url>
    <content><![CDATA[<span id="more"></span>
<p>55555</p>
<p>翻车了</p>
]]></content>
      <categories>
        <category>qbxt一次</category>
      </categories>
      <tags>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title>8.01集训</title>
    <url>/2020/08/01/8.1%E9%9B%86%E8%AE%AD/</url>
    <content><![CDATA[<h1 id="上午">上午</h1>
<p>考试 <span id="more"></span> ### 第一题</p>
<p>一句话题意：给你几堆火，给你几个罐子，这几个罐子分别对火可能会产生不同的影响，每次使用罐子的时候都必须对全部的火进行操作，<span
class="math inline">\(1\)</span>表示浇灭，<span
class="math inline">\(0\)</span>表示 无影响，<span
class="math inline">\(-1\)</span> 表示点燃</p>
<p>问最少用几次罐子可以把火浇灭，否则输出“-1”</p>
<p>一眼搜索</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span>+<span class="number">250</span>;</span><br><span class="line"></span><br><span class="line">queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">map&lt;LL, <span class="type">int</span>&gt; vis, dis; </span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> zuikaishideyangzi, moweideyangzi;</span><br><span class="line"><span class="type">int</span> a[<span class="number">250</span>][<span class="number">250</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">shuruyijichushihua</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) zuikaishideyangzi = zuikaishideyangzi * <span class="number">10</span> + <span class="number">1</span>;</span><br><span class="line">   dis[zuikaishideyangzi] = <span class="number">0</span>;</span><br><span class="line">   vis[zuikaishideyangzi] = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j) &#123;</span><br><span class="line">         cin &gt;&gt; a[i][j];</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   q.<span class="built_in">push</span>(zuikaishideyangzi);</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">jiejuewenti</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      <span class="type">int</span> now = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">      <span class="keyword">if</span> (now == moweideyangzi) <span class="keyword">return</span>;</span><br><span class="line">      <span class="type">int</span> tmp = n, shu[<span class="number">66</span>], yuan[<span class="number">66</span>];</span><br><span class="line">      <span class="type">int</span> xianzaideyangzi = now;</span><br><span class="line">      <span class="keyword">while</span> (tmp != <span class="number">0</span>) &#123;</span><br><span class="line">         yuan[tmp] = shu[tmp] = xianzaideyangzi%<span class="number">10</span>;</span><br><span class="line">         -- tmp;</span><br><span class="line">         xianzaideyangzi /= <span class="number">10</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i][j] == <span class="number">1</span>) shu[j] = <span class="number">0</span>;</span><br><span class="line">               <span class="keyword">if</span> (a[i][j] == <span class="number">-1</span>) shu[j] = <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         LL houlainayiwei = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j) &#123;</span><br><span class="line">         houlainayiwei = houlainayiwei*<span class="number">10</span> + shu[j];</span><br><span class="line">         shu[j] = yuan[j];</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (!vis.<span class="built_in">count</span>(houlainayiwei)) &#123;</span><br><span class="line">            vis[houlainayiwei] = <span class="number">1</span>;</span><br><span class="line">            dis[houlainayiwei] = dis[now] + <span class="number">1</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(houlainayiwei);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">shuchudaan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (vis[moweideyangzi]) cout &lt;&lt; dis[moweideyangzi];</span><br><span class="line">   <span class="keyword">else</span> <span class="built_in">puts</span> (<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">shuruyijichushihua</span>();</span><br><span class="line">   <span class="built_in">jiejuewenti</span>();</span><br><span class="line">   <span class="built_in">shuchudaan</span>();</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第二题">第二题</h3>
<p><a href="https://www.cnblogs.com/zbtrs/p/7618124.html">photo</a></p>
<p>一眼贪心，我们观察样例以及样例解释</p>
<details>
<summary>
Code
</summary>
<pre><code>3 1
2 2
4 3
样例解释:
如果没人躺过来，需要27的面积。
我们只要让第1个人躺过来，就只需要21的面积！
</code></pre>
</details>
<p>开始揣测，为什么一定要让第一个人的<span
class="math inline">\(w\)</span>与<span
class="math inline">\(h\)</span>翻转？为什么不是别人？如果别人翻转会是什么样子的？</p>
<p>画图发现</p>
<p>在第一个人的<span class="math inline">\(w\)</span>与<span
class="math inline">\(h\)</span>翻转前后，他们的<span
class="math inline">\(maxh\)</span>一直都是3，只是他们的<span
class="math inline">\(sumw\)</span>变小了，所以整体的体积变小了</p>
<p>在经过一段时间的臆想，我决定给他们按某种方式的排序，或许会好做一些</p>
<p>考虑：按<span
class="math inline">\(h\)</span>的高度大小排序？显然不合适，没有考虑全体，缺点太多</p>
<p>考虑：按<span
class="math inline">\(w\)</span>的大小排序？显然要被否定</p>
<p>于是继续臆想，最终决定按一个数的<span
class="math inline">\(h\)</span>与<span
class="math inline">\(w\)</span>的差值来从大到小来排序（他们的绝对值）</p>
<p>于是原来的样例变成这样：</p>
<details>
<summary>
Code
</summary>
<pre><code>3 1(3-1=2)
4 3(4-3=1)
2 2(2-2=0)
</code></pre>
</details>
<p>我们肯定优先是对那些<span class="math inline">\(h\)</span>与<span
class="math inline">\(w\)</span>差值大的组合进行翻转，因为只有这样才有<strong>可能</strong>对答案产生有效或者更大的贡献</p>
<p>这时候再来考虑：</p>
<p><span class="math inline">\(h\)</span>与<span
class="math inline">\(w\)</span>大小的关系</p>
<ul>
<li><span class="math inline">\(w &gt; h\)</span></li>
<li><span class="math inline">\(w &lt; h\)</span></li>
<li><span class="math inline">\(w = h\)</span></li>
</ul>
<p>显然对于第三种情况我们无论是否调换<span
class="math inline">\(w\)</span><span
class="math inline">\(h\)</span>都是无影响的</p>
<p>分情况讨论第一种与第二种情况：</p>
<p>当<span class="math inline">\(w&gt;h\)</span>的时候，考虑<span
class="math inline">\(w\)</span>是否影响<span
class="math inline">\(maxh\)</span></p>
<p>1.<span class="math inline">\(w &lt;maxh\)</span>，此时交换<span
class="math inline">\(w\)</span>与<span
class="math inline">\(h\)</span>显然是优的，因为我们在<span
class="math inline">\(maxh\)</span>没有变动的情况下，是的<span
class="math inline">\(sumw\)</span>尽量的小</p>
<p>2.<span
class="math inline">\(w&gt;maxh\)</span>，这时候直接交换不一定是优的，因此我们需要计算一下交换之后的面积</p>
<p>如果<span class="math inline">\(面积_{当前算出来的}
&gt;面积_{以前算出来的}\)</span> 显然不优，我们不去交换<span
class="math inline">\(w\)</span>与<span
class="math inline">\(h\)</span>，反之则交换，并注意更新<span
class="math inline">\(maxh\)</span>与一些数组</p>
<p>当<span class="math inline">\(w &lt; h\)</span>的时候，考虑<span
class="math inline">\(maxh\)</span>与<span
class="math inline">\(h\)</span>的关系</p>
<p>1.<span class="math inline">\(h\neq
maxh\)</span>，显然，我交换之后不影响你<span
class="math inline">\(h\)</span>的最大值，并且交换之后，我<span
class="math inline">\(sumw\)</span>还变大了，面积也会变大，显然不优，我们不去交换</p>
<p>2.<span class="math inline">\(h = maxh\)</span>，还要继续分析：</p>
<p>整体序列是否只有这么一个<span
class="math inline">\(maxh\)</span>，那我们需要计算交换之后的面积，然后……（上文提过，此处省略）</p>
<p>如果不止一个<span
class="math inline">\(maxh\)</span>，那我们交换之后显然吃亏，因为我们交换之后的<span
class="math inline">\(h\)</span>没有影响到<span
class="math inline">\(maxh\)</span>并且我的<span
class="math inline">\(sumw\)</span>也变大了</p>
<p>算法整体就结束了，不过仍然有一个细节要注意，因为题目规定，要求不超过<span
class="math inline">\(\dfrac n
2\)</span>的修改个数，所以每一次交换之后，都需要累加计数器，如果发现计数器大于<span
class="math inline">\(\dfrac n 2\)</span>就退出
底下是90分代码，还需要经过我再D一下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="comment">//#define debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;<span class="type">int</span> h, w, cha;&#125;a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">cmp</span><span class="params">(node x, node y)</span> </span>&#123;<span class="keyword">return</span> x.cha &gt; y.cha;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, sum;</span><br><span class="line"><span class="type">int</span> sumw[N], maxh = -N;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">   m = n&gt;&gt;<span class="number">1</span>;</span><br><span class="line">   <span class="type">int</span> dodododo = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">      <span class="built_in">scanf</span> (<span class="string">&quot;%d%d&quot;</span>, &amp;a[i].w, &amp;a[i].h);</span><br><span class="line">      a[i].cha = <span class="built_in">abs</span>(a[i].w-a[i].h);</span><br><span class="line">      dodododo += a[i].w;</span><br><span class="line">      maxh = (maxh&gt;a[i].h)?maxh:a[i].h;</span><br><span class="line">   &#125;</span><br><span class="line">   sum = dodododo*maxh;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> debug</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;dodododo--&gt;&quot;</span> &lt;&lt; dodododo &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="string">&quot;maxh--&gt;&quot;</span> &lt;&lt; maxh &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sum--&gt;&quot;</span> &lt;&lt; sum &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line">   <span class="built_in">sort</span> (a+<span class="number">1</span>, a+n+<span class="number">1</span>, cmp);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> debug</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cout &lt;&lt; a[i].w &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a[i].h &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) sumw[i] = sumw[i - <span class="number">1</span>] + a[i].w;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (m == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span> (a[i].w &gt; a[i].h) &#123;</span><br><span class="line">         <span class="keyword">if</span> (a[i].w &lt;= maxh) &#123;</span><br><span class="line">            sum = maxh*(sumw[i - <span class="number">1</span>]+a[i].h+sumw[n]-sumw[i]);</span><br><span class="line">            <span class="built_in">swap</span>(a[i].w, a[i].h);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n; ++ j) sumw[j] = sumw[j - <span class="number">1</span>] + a[j].w;</span><br><span class="line">            -- m;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> ans = a[i].w*(sumw[i<span class="number">-1</span>]+a[i].h+sumw[n]-sumw[i]);</span><br><span class="line">            <span class="keyword">if</span> (ans &lt; sum) &#123;</span><br><span class="line">               sum = ans;</span><br><span class="line">               <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n; ++ j) maxh = a[i].w;</span><br><span class="line">               -- m;</span><br><span class="line">	    &#125; <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">	 &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (a[i].w == a[i].h) &#123;<span class="keyword">continue</span>;&#125;</span><br><span class="line">      <span class="keyword">if</span> (a[i].w &lt; a[i].h) &#123;</span><br><span class="line">         <span class="keyword">if</span> (maxh != a[i].h) &#123;<span class="keyword">continue</span>;&#125;</span><br><span class="line">         <span class="keyword">if</span> (maxh == a[i].h) &#123;</span><br><span class="line">            <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">               <span class="keyword">if</span> (a[j].h == maxh) ++ flag;</span><br><span class="line">            flag -= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;<span class="keyword">continue</span>;&#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="type">int</span> one = -N;</span><br><span class="line">	       <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; ++ j) one =(one&gt;a[j].h)?one:a[j].h;</span><br><span class="line">	       <span class="keyword">for</span> (<span class="type">int</span> j = i+<span class="number">1</span>; j &lt;= n; ++ j) one =(one&gt;a[j].h)?one:a[j].h;</span><br><span class="line">	       one = (one&gt;a[i].w)?one:a[i].w;</span><br><span class="line">	       <span class="type">int</span> ans = one*(sumw[i<span class="number">-1</span>]+a[i].h+sumw[n]-sumw[i]);</span><br><span class="line">	       <span class="keyword">if</span> (ans &lt; sum) &#123;</span><br><span class="line">                  sum = ans;</span><br><span class="line">                  maxh = one;</span><br><span class="line">                  <span class="built_in">swap</span>(a[i].w, a[i].h);</span><br><span class="line">                  <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n; ++ j)sumw[j]=sumw[j - <span class="number">1</span>] + a[i].w;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;<span class="keyword">continue</span>;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   cout &lt;&lt; sum;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第三题">第三题</h3>
<p><a href="https://www.cnblogs.com/zbtrs/p/7623047.html">eat</a></p>
<p>一眼枚举</p>
<p>关于吃东西这道题，我们首先来分析一下题意</p>
<p>给你<span
class="math inline">\(ABCD\)</span>四堆数，告诉每堆数里面你必须选一个，再给你一个判定器n，问你有多少种方案选数？</p>
<p>最暴力的做法，四重for，可以拿到三十分</p>
<p>然后考虑优化，最简单的优化是知道前三个数，然后利用判定器减去前三数的和就可以得到第四个数</p>
<p>在这个题中，我们如果知道了<span
class="math inline">\(A+B\)</span>的和，就可以很容易的推出<span
class="math inline">\(C+D\)</span>的具体范围，</p>
<p>具体做法：枚举出<span
class="math inline">\(A+B\)</span>的所有组合，再枚举<span
class="math inline">\(C+D\)</span>的所有组合，</p>
<p>我们定义<span class="math inline">\(C1,C2\)</span>数组</p>
<p>其中<span class="math inline">\(C1[i]=x\)</span>就表示<span
class="math inline">\(A+B\)</span>所能凑出来的和的第<span
class="math inline">\(i\)</span>种方案，其价值为<span
class="math inline">\(x\)</span>，同理</p>
<p><span class="math inline">\(C2[i] = x\)</span>表示<span
class="math inline">\(C+D\)</span>所能凑出来的和的第<span
class="math inline">\(i\)</span>种方案，其价值为<span
class="math inline">\(x\)</span></p>
<p>在<span class="math inline">\(C2\)</span>数组中找到能与<span
class="math inline">\(C1\)</span>数组匹配的数的下标，然后就可以累加答案</p>
<p>更具体的分析在代码中</p>
<p>下面是自己的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e8</span>+<span class="number">66</span>, M = <span class="number">5e3</span>+<span class="number">66</span>, P = <span class="number">2e7</span>+<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, cnt1, cnt2, maxn, res;</span><br><span class="line"><span class="type">int</span> A, B, C, D;</span><br><span class="line"><span class="type">int</span> a[M], b[M], c[M], d[M];</span><br><span class="line"><span class="type">int</span> c1[P], c2[N], f[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   cin &gt;&gt; n &gt;&gt; A &gt;&gt; B &gt;&gt; C &gt;&gt; D;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= A; ++ i) cin &gt;&gt; a[i];</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= B; ++ i) cin &gt;&gt; b[i];</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= C; ++ i) cin &gt;&gt; c[i];</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= D; ++ i) cin &gt;&gt; d[i];</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= A; ++ i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= B; ++ j) &#123;</span><br><span class="line">         <span class="keyword">if</span> (a[i] + b[j] &lt;= n) &#123;</span><br><span class="line">            ++ f[a[i] + b[j]];</span><br><span class="line">	    maxn = <span class="built_in">max</span> (maxn, a[i] + b[j]);</span><br><span class="line">	 &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= maxn; ++ i) &#123;</span><br><span class="line">      <span class="keyword">while</span> (f[i]) &#123;</span><br><span class="line">         -- f[i];</span><br><span class="line">         c1[++ cnt1] = i;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   maxn = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= C; ++ i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= D; ++ j) &#123;</span><br><span class="line">         <span class="keyword">if</span> (c[i] + d[j] &lt;= n) &#123;</span><br><span class="line">         ++ f[c[i] + d[j]];</span><br><span class="line">         maxn = <span class="built_in">max</span> (maxn, c[i] + d[j]);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= maxn; ++ i) &#123;</span><br><span class="line">      <span class="keyword">while</span> (f[i]) &#123;</span><br><span class="line">         -- f[i];</span><br><span class="line">         c2[++ cnt2] = i;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">int</span> cur;</span><br><span class="line">   <span class="keyword">for</span> (cur = cnt2; cur &gt;= <span class="number">1</span>; -- cur)</span><br><span class="line">      <span class="keyword">if</span> (c1[<span class="number">1</span>] + c2[cur] &lt;= n)</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">   <span class="comment">//我们在C2数组中寻找最后一个能与C1[1]相匹配的数的下标</span></span><br><span class="line">   <span class="comment">//何为匹配？我加上你可以在判定器的范围之内</span></span><br><span class="line">   <span class="comment">//所以应该倒序枚举，保证前边的一定可以匹配</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt1; ++ i) &#123;</span><br><span class="line">      res += cur;</span><br><span class="line"><span class="comment">//cur表示的是在C2数组中最后一个能与当前的C1[i]匹配的下标</span></span><br><span class="line">      <span class="keyword">while</span> (cur &amp;&amp; c1[i + <span class="number">1</span>] + c2[cur] &gt; n)</span><br><span class="line">         -- cur;</span><br><span class="line"><span class="comment">//cur这个计数器需要不断往前更新，一直在找，能与C1数组中匹配的下标</span></span><br><span class="line">   &#125;</span><br><span class="line">   cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>暑假日常</category>
      </categories>
      <tags>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title>8.29集训</title>
    <url>/2020/08/29/8.29/</url>
    <content><![CDATA[<p>做了一道题 传纸条， <span id="more"></span> 分别有<span
class="math inline">\(n^4\)</span>的做法，<span
class="math inline">\(n^3\)</span>的做法（都是dp</p>
<p>开始只会<span class="math inline">\(n^4\)</span>，经过优化，因为<span
class="math inline">\(x_1+y_1-x_2=y_1\)</span>所以可以优化成三维</p>
<p>又因为这道题的数组只跟临近的数据有关系，可以弄成变相的滚动数组</p>
<p>空间少了不少，但是复杂度和<span
class="math inline">\(n^3\)</span>一模一样</p>
<p>学了个小东西，悬线法</p>
<p>可以解决以下三个问题</p>
<ul>
<li>需要在扫描序列时维护单调的信息</li>
<li>可以使用单调栈解决</li>
<li>不需要在单调栈上二分</li>
</ul>
<p>悬线，就是一条竖线，这条竖线有初始位置和高度两个性质，可以在其上端点不超过当前位置的矩形高度的情况下左右移动。</p>
<p>对于一条悬线，我们在这条上端点不超过当前位置的矩形高度且不移出边界的前提下，将这条悬线左右移动，求出其最多能向左和向右扩展到何处，此时这条悬线扫过的面积就是包含这条悬线的尽可能大的矩形。容易发现，最大子矩形必定是包含一条初始位置为高度为i的悬线。枚举实现这个过程的时间复杂度为
<span
class="math inline">\(O(n^2)\)</span>，但是我们可以用悬线法将其优化到<span
class="math inline">\(O(n)\)</span></p>
<p>有例题：</p>
<p>Largest Rectangle in a
Histogram，最大子矩形，一开始初始化的时候必须让左边界和右边界都为i</p>
<p>然后每次更新<span
class="math inline">\(l[i]\;to\;l[a[i]-1]\)</span>，r数组同理</p>
<p>如果说，还学习了什么的话，只有“主席树”了</p>
<p><img
src="https://pic.imgdb.cn/item/6327dc5116f2c2beb1349786.png" /></p>
<p>每次修改都是logn，是一个多维的数据结构</p>
<p>前人经验：不要吝啬空间</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title>8.02集训</title>
    <url>/2020/08/02/8.2%E9%9B%86%E8%AE%AD/</url>
    <content><![CDATA[<h1 id="上午">上午</h1>
<p>考试 <span id="more"></span> # 下午</p>
<h3 id="第一题">第一题</h3>
<p>一句话题意：给出两个<span class="math inline">\(1\)</span> <span
class="math inline">\(to\)</span> <span
class="math inline">\(n\)</span>的序列，定义<span
class="math inline">\(T(a,b)\)</span>为<span
class="math inline">\(a\)</span>与<span
class="math inline">\(b\)</span>在序列中的距离</p>
<p>其计算公式为：<span class="math inline">\(下标_{b所在的位置} -
下标_{a所在的位置}\)</span></p>
<p>找出两个序列中，<span
class="math inline">\(max({T_1(a,b),+T_2(a,b))}\)</span></p>
<p>看一组例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">A:<span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">B:<span class="number">2</span> <span class="number">5</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>考虑<span class="math inline">\(2\)</span>与<span
class="math inline">\(4\)</span>这两个数字对答案的贡献，</p>
<p>显然：<span class="math inline">\(ans_{当前} =
(下标_{4所在的A系列位置}-下标_{2所在的A序列位置})
+(下标_{4所在的B系列位置}-下标_{2所在的B序列位置})\)</span></p>
<p>合并之后得到：<span class="math inline">\(ans_{当前} =
(下标_{4所在的A系列位置} +
下标_{4所在的B系列位置})-(下标_{2所在的A序列位置} +
下标_{2所在的B序列位置})\)</span></p>
<p>A序列中的<span class="math inline">\(2\)</span>与<span
class="math inline">\(4\)</span>是递增分布的，考虑，如果B序列中出现<span
class="math inline">\(4.......2\)</span>的情况怎么办？</p>
<p>或者A序列中<span
class="math inline">\(4.......2\)</span>，而B序列中<span
class="math inline">\(2......4\)</span>怎么办？</p>
<p>也就是说B序列与A序列的“顺序不同”（需要感性理解）</p>
<p>这时候我们考虑把下标从右往左标上一圈，原来不是从左往右吗？现在所谓的“逆序”，我们从右往左，实现也很简单，<span
class="math inline">\(n-下标_{当前}+1\)</span>就是你逆序之后的下标</p>
<p>给出自己的代码（借鉴了<a
href="https://www.cnblogs.com/wsdslll/">Tethys</a>dalao的代码）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="type">long</span> <span class="type">long</span> s = <span class="number">0</span>, f = <span class="number">1</span>; <span class="type">char</span> ch;</span><br><span class="line">   <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = <span class="built_in">getchar</span>())) (ch == <span class="string">&#x27;-&#x27;</span>) &amp;&amp; (f = -f);</span><br><span class="line">   <span class="keyword">for</span>(s = ch ^ <span class="number">48</span>;<span class="built_in">isdigit</span>(ch = <span class="built_in">getchar</span>()); s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="number">48</span>));</span><br><span class="line">   <span class="keyword">return</span> s * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>+<span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, res, ans_s_max, ans_s_min = N&lt;&lt;<span class="number">1</span>, ans_n_max, ans_n_min = N&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> a[N], b[N], f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">shuruyijijiejueheshuchu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   n = <span class="built_in">read</span>();</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) a[i] = <span class="built_in">read</span>();</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">      b[i] = <span class="built_in">read</span>();</span><br><span class="line">      f[b[i]] = i;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">      ans_s_max = <span class="built_in">max</span>(ans_s_max, i + f[a[i]]);</span><br><span class="line">      ans_s_min = <span class="built_in">min</span>(ans_s_min, i + f[a[i]]);</span><br><span class="line">      ans_n_max = <span class="built_in">max</span>(ans_n_max, i + n-f[a[i]]+<span class="number">1</span>);</span><br><span class="line">      ans_n_min = <span class="built_in">min</span>(ans_n_min, i + n-f[a[i]]+<span class="number">1</span>);</span><br><span class="line">      res = <span class="built_in">max</span>(res, ans_s_max - ans_s_min);</span><br><span class="line">      res = <span class="built_in">max</span>(res, ans_n_max - ans_n_min);</span><br><span class="line">   &#125;</span><br><span class="line">   cout &lt;&lt; res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">shuruyijijiejueheshuchu</span>();</span><br><span class="line">   <span class="built_in">fclose</span> (stdin), <span class="built_in">fclose</span> (stdout);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">2 1 5 3 4</span></span><br><span class="line"><span class="comment">4 2 5 1 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>我懒得去写具体的代码分析了，日后补吧</p>
<h3 id="第二题">第二题</h3>
<p>一句话题意：求<span
class="math inline">\(\begin{aligned}\sum_{i=0}^xC_{x}^i*C_{y}^{z+i}\%998244353\end{aligned}\)</span></p>
<p>其中数据：<span
class="math inline">\(T&lt;=10000,0&lt;=x,y,z&lt;=1000000\)</span></p>
<p>可曾听闻范德蒙德卷积？</p>
<p>然后就没了</p>
<p><span
class="math inline">\(\begin{aligned}\sum_{i=0}^k{C_n^iC_{m}^{k-i}}=C_{n+m}^{k}\end{aligned}\)</span></p>
<p>具体详见<a href="https://www.cnblogs.com/Ame-sora/">Ame__</a></p>
<p>给出代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e7</span>+<span class="number">66</span>, mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="type">int</span> s = <span class="number">0</span>, f = <span class="number">1</span>; <span class="type">char</span> ch;</span><br><span class="line">   <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = <span class="built_in">getchar</span>())) (ch == <span class="string">&#x27;-&#x27;</span>) &amp;&amp; (f = -f);</span><br><span class="line">   <span class="keyword">for</span>(s = ch ^ <span class="number">48</span>;<span class="built_in">isdigit</span>(ch = <span class="built_in">getchar</span>()); s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="number">48</span>));</span><br><span class="line">   <span class="keyword">return</span> s * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x, y, z, t;</span><br><span class="line"><span class="type">int</span> js[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">ksm</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (!b) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">if</span> (b&amp;<span class="number">1</span>) <span class="keyword">return</span> a*<span class="built_in">ksm</span>(a,b<span class="number">-1</span>);</span><br><span class="line">   <span class="type">int</span> tmp = <span class="built_in">ksm</span>(a, b/<span class="number">2</span>)%mod;</span><br><span class="line">   <span class="keyword">return</span> tmp*tmp%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个快速幂我没有测</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (n &lt; m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">return</span> js[n]*<span class="built_in">ksm</span>(js[m]*js[n-m]%mod, mod<span class="number">-2</span>)%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Lucas</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (!m) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">C</span>(n%mod, m%mod)*<span class="built_in">Lucas</span>(n/mod, m/mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">shuruhejiejueheshuchu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   t = <span class="built_in">read</span>();</span><br><span class="line">   js[<span class="number">0</span>] = <span class="number">1</span>, js[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= N; ++ i) js[i] = js[i - <span class="number">1</span>]*i%mod;</span><br><span class="line">   <span class="keyword">while</span> (t -- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span></span><br><span class="line">      x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>(), z = <span class="built_in">read</span>();</span><br><span class="line">      <span class="type">int</span> sum =  <span class="built_in">Lucas</span>(x+y, x+z)%mod;</span><br><span class="line">      cout &lt;&lt; sum &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">shuruhejiejueheshuchu</span>();</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
<p>这题tmd卡快读，艹，我用<span
class="math inline">\(cin\)</span>全T飞了</p>
<h3 id="第三题">第三题</h3>
<p>一句话题意：给你个序列，每次要异或一个数，还要查询一个判定器，其中<span
class="math inline">\(n \leq 1e6\)</span></p>
<p>显然暴力<span class="math inline">\(n^2\)</span>，正解是：<span
class="math inline">\(01Tire\)</span>，艹，我就是tm讲的Trie树，我自己没看出来，老往主席树什么玩意的想去了</p>
<p>关键是前几天学长好几道异或的题，都跟01Trie树没关系啊，我知道是01Trie树之后，当场mmp</p>
<p>后来gzh奆佬直言：学过01Trie树的一眼就能看出来（于是口吐不清的开始了他迷迷糊糊的讲解）</p>
<p>具体思路：在01Trie树上搞一搞就可以了</p>
<p>给出代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">6e6</span>+<span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, t, x, y, cnt;</span><br><span class="line"><span class="type">int</span> ch[N][<span class="number">6</span>], tag[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">shuruyijijiejueheshuchu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   cin &gt;&gt; n &gt;&gt; t;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">      <span class="type">int</span> now = <span class="number">0</span>;</span><br><span class="line">      cin &gt;&gt; x;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">16</span>; j &gt;= <span class="number">0</span>; -- j) &#123;</span><br><span class="line">         <span class="keyword">if</span> (!ch[now][x&gt;&gt;j&amp;<span class="number">1</span>]) ch[now][x&gt;&gt;j&amp;<span class="number">1</span>] = ++ cnt;</span><br><span class="line">         now = ch[now][x&gt;&gt;j&amp;<span class="number">1</span>];</span><br><span class="line">         ++ tag[now];</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">while</span> (t --&gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="type">int</span> res = <span class="number">0</span>, now = <span class="number">0</span>;</span><br><span class="line">      cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">16</span>; j &gt;= <span class="number">0</span>; -- j) &#123;</span><br><span class="line">         <span class="keyword">if</span> (y&gt;&gt;j&amp;<span class="number">1</span>) res += tag[ch[now][x&gt;&gt;j&amp;<span class="number">1</span>]];</span><br><span class="line">         now = ch[now][(y&gt;&gt;j&amp;<span class="number">1</span>)^(x&gt;&gt;j&amp;<span class="number">1</span>)];</span><br><span class="line">         <span class="keyword">if</span> (!now) <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (now) res += tag[now];</span><br><span class="line">      cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">shuruyijijiejueheshuchu</span>();</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5 5</span></span><br><span class="line"><span class="comment">7 6 7 3 4</span></span><br><span class="line"><span class="comment">2 6</span></span><br><span class="line"><span class="comment">1 8</span></span><br><span class="line"><span class="comment">8 7</span></span><br><span class="line"><span class="comment">3 2</span></span><br><span class="line"><span class="comment">6 2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>暑假日常</category>
      </categories>
      <tags>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title>8.28集训</title>
    <url>/2020/08/28/8.28/</url>
    <content><![CDATA[<p>第一题 在一个无向图里面找到一个生成树，使得代价最小</p>
<p>其中代价定义为 每个点的深度h（根节点深度为1）*权值v <span id="more"></span>
切了</p>
<p>但是我想得太复杂，写的时间太长，没给第二题留下充足的时间思考</p>
<p>如果再给我一个小时，我未尝不可把第二题切了</p>
<p>枚举每个节点作为根节点，跑dfs或者bfs都可以</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//东方之珠 整夜未眠！</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pr;</span><br><span class="line"></span><br><span class="line">map&lt;pr, <span class="type">bool</span>&gt; yhm_exist;</span><br><span class="line"><span class="type">int</span> to[N &lt;&lt; <span class="number">1</span>], nex[N &lt;&lt; <span class="number">1</span>], head[N &lt;&lt; <span class="number">1</span>], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    to[++ cnt] = y;</span><br><span class="line">    nex[cnt] = head[x];</span><br><span class="line">    head[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> val[N], dep[N], vis[N];</span><br><span class="line"></span><br><span class="line">queue &lt;pr&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">yhm</span><span class="params">(<span class="type">int</span> now, <span class="type">int</span> FA, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span> (dep, <span class="number">0</span>, <span class="keyword">sizeof</span> dep);</span><br><span class="line">    <span class="built_in">memset</span> (vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">pr</span>(now, FA)), dep[now] = <span class="number">1</span>, vis[now] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> i, x, y, fa, <span class="built_in">res</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (! q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        x = q.<span class="built_in">front</span>().first, fa = q.<span class="built_in">front</span>().second; q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (i = head[x]; i; i = nex[i])</span><br><span class="line">        &#123;</span><br><span class="line">            y = to[i];</span><br><span class="line">            <span class="keyword">if</span> (y == fa) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (! vis[y] || dep[y] &gt; dep[x] + <span class="number">1</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                vis[y] = <span class="number">1</span>;</span><br><span class="line">                dep[y] = dep[x] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(<span class="built_in">pr</span>(y, x));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) res += dep[i] * val[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, <span class="built_in">j</span>(<span class="number">0</span>), k, n, m, <span class="built_in">res</span>(<span class="number">123456789</span>), <span class="built_in">ans</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, val + i);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        ++ x, ++ y;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; y) <span class="built_in">swap</span>(x, y);</span><br><span class="line">        <span class="keyword">if</span> (yhm_exist[<span class="built_in">pr</span>(x, y)]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">add</span>(x, y), <span class="built_in">add</span>(y, x);</span><br><span class="line">        yhm_exist[<span class="built_in">pr</span>(x, y)] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n - <span class="number">1</span> &gt; m) &#123;<span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>); <span class="built_in">fclose</span> (stdin), <span class="built_in">fclose</span> (stdout); <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span> (x = <span class="number">1</span>; x &lt;= n; ++ x)</span><br><span class="line">    &#123;</span><br><span class="line">        res = <span class="built_in">min</span>(res, <span class="built_in">yhm</span>(x, <span class="number">0</span>, n));</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="keyword">if</span> (! vis[i]) &#123;j = <span class="number">1</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
<p>第二题，给定点，给定每次删点范围，点不可重复删，问每次可以删掉多少点？</p>
<p>数据量十万</p>
<p>mapy[y].erase(x);</p>
<p>mapx.erase(it1, it2);</p>
<p>这两个函数说尽了一切，第一行是在y坐标上删除，第二行是在x坐标上全删除</p>
<p>总结STL是真的niub</p>
<p>学好STL会省很大的劲，pb_ds封装了平衡树…..</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//东方之珠 整夜未眠！</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">66</span>;</span><br><span class="line"></span><br><span class="line">map &lt;<span class="type">int</span>, multiset &lt;<span class="type">int</span>&gt; &gt; mapx, mapy;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span> (<span class="string">&quot;city.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin), <span class="built_in">freopen</span> (<span class="string">&quot;city.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    <span class="type">int</span> i, n, m, cnt;</span><br><span class="line">    <span class="type">int</span> opt, n1, n2;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        mapx[x].<span class="built_in">insert</span>(y), mapy[y].<span class="built_in">insert</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%d%d%d&quot;</span>, &amp;opt, &amp;n1, &amp;n2); cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (! opt)</span><br><span class="line">        &#123;</span><br><span class="line">            map &lt;<span class="type">int</span>, multiset &lt;<span class="type">int</span>&gt; &gt; :: iterator it, it1, it2;</span><br><span class="line">            it1 = mapx.<span class="built_in">lower_bound</span>(n1);</span><br><span class="line">            it2 = mapx.<span class="built_in">upper_bound</span>(n2);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (it = it1; it != it2; ++ it)</span><br><span class="line">            &#123;</span><br><span class="line">                multiset &lt;<span class="type">int</span>&gt; &amp;myset = (it -&gt; second);</span><br><span class="line">                <span class="type">int</span> x = it -&gt; first;</span><br><span class="line">                cnt += myset.<span class="built_in">size</span>();</span><br><span class="line">                <span class="keyword">for</span> (multiset &lt;<span class="type">int</span>&gt; :: iterator it = myset.<span class="built_in">begin</span>(); it != myset.<span class="built_in">end</span>(); ++ it)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> y = *it;</span><br><span class="line">                    mapy[y].<span class="built_in">erase</span>(x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mapx.<span class="built_in">erase</span>(it1, it2);</span><br><span class="line">        &#125; <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            map &lt;<span class="type">int</span>, multiset &lt;<span class="type">int</span>&gt; &gt; :: iterator it, it1, it2;</span><br><span class="line">            it1 = mapy.<span class="built_in">lower_bound</span>(n1);</span><br><span class="line">            it2 = mapy.<span class="built_in">upper_bound</span>(n2);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (it = it1; it != it2; ++ it)</span><br><span class="line">            &#123;</span><br><span class="line">                multiset &lt;<span class="type">int</span>&gt; &amp;myset = (it -&gt; second);</span><br><span class="line">                <span class="type">int</span> y = it -&gt; first;</span><br><span class="line">                cnt += myset.<span class="built_in">size</span>();</span><br><span class="line">                <span class="keyword">for</span> (multiset &lt;<span class="type">int</span>&gt; :: iterator it = myset.<span class="built_in">begin</span>(); it != myset.<span class="built_in">end</span>(); ++ it)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> x = *it;</span><br><span class="line">                    mapx[x].<span class="built_in">erase</span>(y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mapy.<span class="built_in">erase</span>(it1, it2);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; cnt &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
<p>第三题</p>
<p><img
src="https://pic.imgdb.cn/item/6327dc8f16f2c2beb134f900.png" /></p>
<p>从1开始dfs，因为1就是根，其次就几乎是一个裸的线段树合并</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mid ((l + r) &gt;&gt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//东方之珠 整夜未眠！</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e6</span>+<span class="number">66</span>, inf = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;e[N];</span><br><span class="line"><span class="type">int</span> a[N], cnt, res;</span><br><span class="line"><span class="type">int</span> head[N], rt[N &lt;&lt; <span class="number">2</span>][<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yhm</span>&#123;<span class="type">int</span> ls, rs, sum;&#125; tr[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> &amp;o, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> p, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (! o) o = ++ cnt;</span><br><span class="line">    tr[o].sum = <span class="built_in">max</span>(tr[o].sum, w);</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (p &lt;= mid) <span class="built_in">insert</span>(tr[o].ls, l, mid, p, w);</span><br><span class="line">    <span class="keyword">if</span> (p &gt; mid) <span class="built_in">insert</span>(tr[o].rs, mid + <span class="number">1</span>, r, p, w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> o, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (! o) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y) <span class="keyword">return</span> tr[o].sum;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) sum = <span class="built_in">max</span>(sum, <span class="built_in">query</span>(tr[o].ls, l, mid, x, y));</span><br><span class="line">    <span class="keyword">if</span> (y &gt; mid) sum = <span class="built_in">max</span>(sum, <span class="built_in">query</span>(tr[o].rs, mid + <span class="number">1</span>, r, x, y));</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> &amp;l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (! l) &#123;l = r; <span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span> (! r) <span class="keyword">return</span>;</span><br><span class="line">    tr[l].sum = <span class="built_in">max</span> (tr[l].sum, tr[r].sum);</span><br><span class="line">    <span class="built_in">merge</span> (tr[l].ls, tr[r].ls), <span class="built_in">merge</span> (tr[l].rs, tr[r].rs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dododo</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">kakaka</span><span class="params">(<span class="number">0</span>)</span>, i, y</span>;</span><br><span class="line">    <span class="built_in">insert</span> (rt[x][<span class="number">0</span>], <span class="number">0</span>, inf, a[x], <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">insert</span> (rt[x][<span class="number">1</span>], <span class="number">0</span>, inf, a[x], <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; e[x].<span class="built_in">size</span>(); ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        y = e[x][i];</span><br><span class="line">        <span class="built_in">dfs</span>(y);</span><br><span class="line">        dododo = <span class="built_in">max</span> (dododo, <span class="built_in">query</span> (rt[y][<span class="number">0</span>], <span class="number">0</span>, inf, <span class="number">0</span>, a[x] - <span class="number">1</span>));</span><br><span class="line">        kakaka = <span class="built_in">max</span> (kakaka, <span class="built_in">query</span> (rt[y][<span class="number">1</span>], <span class="number">0</span>, inf, a[x] + <span class="number">1</span>, inf));</span><br><span class="line">        <span class="built_in">merge</span> (rt[x][<span class="number">0</span>], rt[y][<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">merge</span> (rt[x][<span class="number">1</span>], rt[y][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">insert</span> (rt[x][<span class="number">0</span>], <span class="number">0</span>, inf, a[x], dododo + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">insert</span> (rt[x][<span class="number">1</span>], <span class="number">0</span>, inf, a[x], kakaka + <span class="number">1</span>);</span><br><span class="line">    res = <span class="built_in">max</span> (res, dododo + kakaka + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, n, fx;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%d%d&quot;</span>, &amp;a[i], &amp;fx);</span><br><span class="line">        <span class="keyword">if</span> (fx) e[fx].<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title>8.06集训</title>
    <url>/2020/08/06/8.6%E9%9B%86%E8%AE%AD/</url>
    <content><![CDATA[<h1 id="上午">上午</h1>
<p>写博客做题 <span id="more"></span> # 下午</p>
<p>讲课，组合数学与一部分的数据结构</p>
<p>没时间写了，这是个坑，以后得补上（教练规定9.00以后才能写博客，可是一个小时根本不够用啊！！！！！！！）</p>
<h1 id="晚上">晚上</h1>
<p>更新博客8.3，与8.5</p>
<p>做了几道贪心二分题，见<a
href="https://www.cnblogs.com/yszhyhm/p/13425599.html">8.3博客</a></p>
]]></content>
      <categories>
        <category>暑假日常</category>
      </categories>
      <tags>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title>8.31集训</title>
    <url>/2020/08/31/8.31/</url>
    <content><![CDATA[<p>今天做了三个dp <span id="more"></span> 第一个是子串</p>
<p>状态：设<span
class="math inline">\(f[i][j][p][0/1]\)</span>表示a串前i位使用p个子串匹配b串前j位字符且第i个位置选/不选的方案数</p>
<p>转移：</p>
<ul>
<li>当<span class="math inline">\(a[i]=b[j]\)</span></li>
<li><span
class="math inline">\(f[val][j][p][0]=(f[val\;xor\;1][j][p][0]+f[val\;xor\;1][j][p][1])\%mod\)</span></li>
<li><span
class="math inline">\(f[val][j][p][1]=(f[val\;xor\;1][j-1][p][1]+(f[val\;xor\;1][j-1][p-1][0]+f[val\;xor\;1][j-1][p-1][1])\%mod)\%mod\)</span></li>
<li>当<span class="math inline">\(a[i]\neq[j]\)</span></li>
<li><span
class="math inline">\(f[val][j][p][0]=(f[val\;xor\;1][j][p][0]+f[val\;xor\;1][j][p][1])\%mod\)</span></li>
<li><span class="math inline">\(f[val][j][p][1]=0;\)</span></li>
</ul>
<p>时间复杂度<span
class="math inline">\(O(n^3)\)</span>，空间复杂度<span
class="math inline">\(O(m\times k)\)</span></p>
<p>因此需要优化空间，发现第一维<span
class="math inline">\(i\)</span>只与<span
class="math inline">\(i-1\)</span>有关系，所以把<span
class="math inline">\(i\)</span>这一维度滚掉</p>
<p>方法：<span class="math inline">\(val\)</span>是当前的<span
class="math inline">\(i\)</span>，而<span
class="math inline">\(val\;xor\;1\)</span>是<span
class="math inline">\(i-1\)</span>，总之就是转移方程的时候另一个数</p>
<p>每次都<span class="math inline">\(xor\;1\)</span>，然后答案就是<span
class="math inline">\(n\&amp;1\)</span>，感觉很奇妙。。。。</p>
<p>注意：这种情况下，<span class="math inline">\(val\)</span>初始为1</p>
<p>第二个是换教室</p>
<p>一道极其好，但是极其难做的题</p>
<p><img
src="https://pic.imgdb.cn/item/6327dc1316f2c2beb134226d.png" /></p>
<p>坑点：</p>
<p>1.弗洛伊德</p>
<p>有向图和无向图写法不一样</p>
<p>有向图：</p>
<details>
<summary>
Code
</summary>
<pre><code>memset (dis, 0x3f, sizeof dis);
for (i = 1; i <= n; ++ i) dis[i][i] = 0;
for (k = 1; k <= n; ++ k)
   for (i = 1; i <= n; ++ ｉ)
      for (j = 1; j <= n; ++ j)
         dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);
</code></pre>
</details>
<p>无向图：</p>
<details>
<summary>
Code
</summary>
<pre><code>for (i = 1; i <= n; ++ i)
   for (j = 1; j < i; ++ j)
      dis[i][j] = dis[j][i] = inf;
for (i = 1; i <= e; ++ i)
&#123;
   cin >> x >> y >> z;
   dis[x][y] = dis[y][x] = min(dis[x][y], z);
&#125;
for (e = 1; e <= v; ++ e)
   for (i = 1; i <= v; ++ i)
      for (j = 1; j < i; ++ j)
         dis[i][j] = dis[j][i] = min(dis[i][j], dis[i][e] + dis[e][j]);
</code></pre>
</details>
<p>2.只在memset里面用0x3f，0x7f，其中<span
class="math inline">\(0x7f\)</span>比<span
class="math inline">\(0x3f\)</span>大一倍，<span
class="math inline">\(0x7f\)</span>约为2147483647</p>
<p>在平时不要用赋值语句，或者直接输出将会得到<span
class="math inline">\(63\;or\;127\)</span></p>
<p>其中0x7fffffff，为2147483647</p>
<p>第三道，飞扬的小鸟</p>
<p>状态：<span
class="math inline">\(f[i][j]\)</span>表示横坐标为i时高度为j的最少点击次数</p>
<p>转移：</p>
<ul>
<li>上升的话是完全背包，因为可以一直点</li>
<li>下降的话，是01背包</li>
</ul>
<p>其中转移顺序的话，先升再降，超过m变为m——特判</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title>8.03集训</title>
    <url>/2020/08/03/8.3%E9%9B%86%E8%AE%AD/</url>
    <content><![CDATA[<h1 id="上午">上午</h1>
<p>###第一题 <span id="more"></span> <img
src="https://pic.imgdb.cn/item/6327e22c16f2c2beb13b7b4a.png" /></p>
<p>其中<span class="math inline">\(n \leq 1e18\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   cin &gt;&gt; n;</span><br><span class="line">   <span class="type">int</span> l = <span class="number">1</span>, r = <span class="built_in">sqrt</span>(n)*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">   <span class="type">int</span> mo = <span class="number">2</span>*n<span class="number">-2</span>;</span><br><span class="line">   <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">      <span class="type">int</span> mid = (l + r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (mid*(mid+<span class="number">1</span>) &gt;= mo) r = mid;</span><br><span class="line">      <span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   cout &lt;&lt; l;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第二题">第二题</h3>
<p><img
src="https://pic.imgdb.cn/item/6327e24216f2c2beb13b908c.png" /></p>
<p><img
src="https://pic.imgdb.cn/item/6327e25b16f2c2beb13ba91d.png" /></p>
<p>有百分之二十的暴力，但是需要LL</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="type">long</span> <span class="type">long</span> s = <span class="number">0</span>, f = <span class="number">1</span>; <span class="type">char</span> ch;</span><br><span class="line">   <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = <span class="built_in">getchar</span>())) (ch == <span class="string">&#x27;-&#x27;</span>) &amp;&amp; (f = -f);</span><br><span class="line">   <span class="keyword">for</span>(s = ch ^ <span class="number">48</span>;<span class="built_in">isdigit</span>(ch = <span class="built_in">getchar</span>()); s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="number">48</span>));</span><br><span class="line">   <span class="keyword">return</span> s * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span>+<span class="number">66</span>, INF = <span class="number">214748364000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, res = INF;</span><br><span class="line"><span class="type">int</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;<span class="type">int</span> a, t, v;&#125;yhm[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> num, <span class="type">int</span> ans, <span class="type">int</span> fangyu)</span> </span>&#123;</span><br><span class="line">   vis[x] = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">if</span> (num == n) &#123;</span><br><span class="line">      res = <span class="built_in">min</span>(res, ans);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">         <span class="type">int</span> now_ans = (yhm[i].a-fangyu)*yhm[i].t+ans;</span><br><span class="line">         <span class="type">int</span> now_fangyu = yhm[i].v + fangyu;</span><br><span class="line">         <span class="built_in">dfs</span>(i, num+<span class="number">1</span>, now_ans, now_fangyu);</span><br><span class="line">         vis[i] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   n = <span class="built_in">read</span>();</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      yhm[i].a = <span class="built_in">read</span>(), yhm[i].t = <span class="built_in">read</span>(), yhm[i].v = <span class="built_in">read</span>();</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">      <span class="built_in">memset</span> (vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">      <span class="built_in">dfs</span>(i, <span class="number">1</span>, yhm[i].a*yhm[i].t, yhm[i].v);</span><br><span class="line">   &#125;</span><br><span class="line">   cout &lt;&lt; res;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
<p>下面给出正解：</p>
<p><img
src="https://pic.imgdb.cn/item/6327e27516f2c2beb13bc5a9.png" /></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="type">long</span> <span class="type">long</span> s = <span class="number">0</span>, f = <span class="number">1</span>; <span class="type">char</span> ch;</span><br><span class="line">   <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch = <span class="built_in">getchar</span>())) (ch == <span class="string">&#x27;-&#x27;</span>) &amp;&amp; (f = -f);</span><br><span class="line">   <span class="keyword">for</span>(s = ch ^ <span class="number">48</span>;<span class="built_in">isdigit</span>(ch = <span class="built_in">getchar</span>()); s = (s &lt;&lt; <span class="number">1</span>) + (s &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="number">48</span>));</span><br><span class="line">   <span class="keyword">return</span> s * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">4e5</span>+<span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, res, fangyu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;<span class="type">int</span> a, t, v; <span class="type">double</span> anzhi;&#125;yhm[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">cmp</span><span class="params">(node x, node y)</span></span>&#123;<span class="keyword">return</span> x.anzhi &gt; y.anzhi;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   cin &gt;&gt; n;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">      yhm[i].a = <span class="built_in">read</span>(), yhm[i].t = <span class="built_in">read</span>(), yhm[i].v = <span class="built_in">read</span>();</span><br><span class="line">      yhm[i].anzhi = (<span class="type">double</span>)yhm[i].v/yhm[i].t;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">sort</span> (yhm+<span class="number">1</span>, yhm+n+<span class="number">1</span>, cmp);</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">      res += (yhm[i].a - fangyu)*yhm[i].t;</span><br><span class="line">      fangyu += yhm[i].v;</span><br><span class="line">   &#125;</span><br><span class="line">   cout &lt;&lt; res;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第三题">第三题</h3>
<p><img
src="https://pic.imgdb.cn/item/6327e29116f2c2beb13be1c5.png" /></p>
<p><img
src="https://pic.imgdb.cn/item/6327e2ad16f2c2beb13bfd19.png" /></p>
<p>我的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="comment">// #define debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, q, res;</span><br><span class="line"><span class="type">int</span> ql[N], qr[N], qs[N], qt[N], base[N];</span><br><span class="line"><span class="type">int</span> dis[N][N], f[<span class="number">600000</span>][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">shuru</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">   <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) dis[i][i] = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">      <span class="type">int</span> u, v, w;</span><br><span class="line">      cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">      dis[u][v] = <span class="built_in">min</span>(dis[u][v], w);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; ++ k)</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">            dis[i][j] = <span class="built_in">min</span>(dis[i][k]+dis[k][j], dis[i][j]);</span><br><span class="line">   base[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; ++ i) &#123;</span><br><span class="line">      cin &gt;&gt; qs[i] &gt;&gt; qt[i] &gt;&gt; ql[i] &gt;&gt; qr[i];</span><br><span class="line">      base[i] = base[i - <span class="number">1</span>]*<span class="number">3</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f); f[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">jiejue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; base[q]; ++ i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= q; ++ k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i%base[k]/base[k - <span class="number">1</span>] == <span class="number">1</span>)<span class="comment">//qu chu</span></span><br><span class="line">               f[i][qs[k]] = <span class="built_in">min</span>(f[i][qs[k]],<span class="built_in">max</span>((f[i - base[k - <span class="number">1</span>]][j] + dis[j][qs[k]]), ql[k]));</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i%base[k]/base[k - <span class="number">1</span>] == <span class="number">2</span> &amp;&amp;f[i - base[k - <span class="number">1</span>]][j] + dis[j][qt[k]] &lt;= qr[k])</span><br><span class="line">               f[i][qt[k]] = <span class="built_in">min</span>(f[i][qt[k]],f[i - base[k - <span class="number">1</span>]][j] + dis[j][qt[k]]);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">shuchu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; base[q]; ++ i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j) &#123;</span><br><span class="line">         <span class="keyword">if</span> (f[i][j] != <span class="number">0x3f3f3f3f</span>) &#123;</span><br><span class="line">            <span class="function"><span class="type">int</span> <span class="title">now</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= q; ++ k)</span><br><span class="line">               <span class="keyword">if</span> (i%base[k]/base[k - <span class="number">1</span>] == <span class="number">2</span>)</span><br><span class="line">                  ++ now;</span><br><span class="line">                  res = <span class="built_in">max</span>(res, now);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   cout &lt;&lt; res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">shuru</span>();</span><br><span class="line">   <span class="built_in">jiejue</span>();</span><br><span class="line">   <span class="built_in">shuchu</span>();</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
<h1 id="下午">下午</h1>
<p>rqj学长讲课</p>
<h3 id="二分">二分</h3>
<p><a
href="https://www.cnblogs.com/lcosmos/p/9438705.html">click</a></p>
<p>我从来只写一种二分：</p>
<details>
<summary>
二分
</summary>
<pre><code>while (l < r) &#123;
   int mid = (l+r+1)>>1;
   if (a[mid] >= x) r = mid - 1;
   else l = mid;
&#125;
</code></pre>
</details>
<p>二分有好多种写法，李某东dalao说，只有百分之十的程序员能写对二分。。。</p>
<p>二分查找：在一个<strong>从小到大</strong>的序列中balabala...</p>
<p>考虑：为什么一定是从小到大？因为二分无论是查找还是二分答案都必须利用序列的有序性</p>
<p>有以下典型例题：</p>
<h3 id="挑石头">挑石头</h3>
<p><a href="https://www.luogu.com.cn/problem/P2678">click</a></p>
<p>"最小距离最大值"典型二分答案，刚刚在rqj奆佬的指导下，改变了二分写法，这种二分结束后<span
class="math inline">\(l == r\)</span>，<span
class="math inline">\(l,r\)</span>都是答案</p>
<p>给出一组<span class="math inline">\(Hack\)</span>数据：65343245 0
0</p>
<p>（时隔半年，再写一次二分答案，感觉手生了好多，顿时又有些感动，我第一次学二分答案，到现在已经过去两三年了吧）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m; LL L, res;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="type">int</span> <span class="title">an</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">last</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n+<span class="number">1</span>; ++ i)</span><br><span class="line">      (a[i]-last&lt;x)? ++ an : last = a[i];</span><br><span class="line">   <span class="comment">// printf(&quot;pd %d = %d\n&quot;, x, m &gt;= an);</span></span><br><span class="line">   <span class="keyword">return</span> m&gt;=an;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   cin &gt;&gt; L &gt;&gt; n &gt;&gt; m;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cin &gt;&gt; a[i];</span><br><span class="line">   a[n + <span class="number">1</span>] = L;</span><br><span class="line">   LL l = <span class="number">1</span>, r = L;</span><br><span class="line">   <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">      LL mid = (l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">pd</span>(mid)) l = mid;</span><br><span class="line">      <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   cout &lt;&lt; l;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自动做题机子">自动做题机子</h3>
<p><a href="https://www.luogu.com.cn/problem/P4343">click</a></p>
<p>考虑二分答案，因为要求一个最小值和最大值嘛，跑两遍</p>
<p>给出ac代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">66</span>, inf = <span class="number">1e18</span>+<span class="number">250</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k, res_min = <span class="number">-1</span>, res_max = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="type">int</span> <span class="title">an</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">tmp</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">      tmp += a[i];</span><br><span class="line">      <span class="keyword">if</span> (tmp &lt; <span class="number">0</span>) tmp = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (tmp &gt;= x) ++ an, tmp = <span class="number">0</span>; </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> an;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cin &gt;&gt; a[i];</span><br><span class="line">      <span class="type">int</span> l = <span class="number">1</span>, r = inf;</span><br><span class="line">      <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">         <span class="type">int</span> mid = (l+r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">if</span> (<span class="built_in">pd</span>(mid) &lt;= k) &#123;</span><br><span class="line">            r = mid;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">pd</span>(mid) == k) res_min = mid;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   l = <span class="number">0</span>, r = inf;</span><br><span class="line">   <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">      <span class="type">int</span> mid = (l+r+<span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">pd</span>(mid) &gt;= k) &#123;</span><br><span class="line">         l = mid;</span><br><span class="line">         <span class="keyword">if</span> (<span class="built_in">pd</span>(mid) == k) res_max = mid;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (res_min == <span class="number">-1</span>) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">   <span class="keyword">else</span> cout &lt;&lt; res_min &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; res_max;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<p>如果要二分答案求一个尽量小的值：</p>
<details>
<summary>
find min
</summary>
<pre><code>int l = 1, r = inf;
while (l < r) &#123;
   int mid = (l+r)>>1;
   if (pd(mid)) r = mid;
   else l = mid+1;
&#125;
</code></pre>
</details>
<p>如果二分答案求一个尽量大的值：</p>
<details>
<summary>
find max
</summary>
<pre><code>int l = 1, r = inf;
while (l < r) &#123;
   int mid = (l+r+1)>>1;
   if (pd(mid)) l = mid;
   else r = mid - 1;
&#125;
</code></pre>
</details>
<h3 id="扑克">扑克</h3>
<p><a href="https://www.luogu.com.cn/problem/P5815">click</a></p>
<p>首先，我们可以发现，<span class="math inline">\(J\)</span> 和 <span
class="math inline">\(1,2,⋯ ,n\)</span>其实没什么区别，假如我们把 <span
class="math inline">\(J\)</span> 看成 <span
class="math inline">\(0\)</span> 号牌，那么，相当于这 <span
class="math inline">\(n+1\)</span> 种牌中任意 <span
class="math inline">\(n\)</span> 种各一张可以组成一套牌。</p>
<p>然后，<span class="math inline">\(n\)</span> 种各一张可以转化为 <span
class="math inline">\(n+1\)</span> 种各拿一张再取回去一张。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">66</span>, inf = <span class="number">600000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="type">int</span> <span class="title">an</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i)</span><br><span class="line">      an += <span class="built_in">max</span>(x - a[i], <span class="number">0ll</span>);</span><br><span class="line">   <span class="keyword">return</span> x&gt;=an;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   cin &gt;&gt; n &gt;&gt; a[<span class="number">0</span>];</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      cin &gt;&gt; a[i];</span><br><span class="line">   <span class="type">int</span> l = <span class="number">0</span>, r = inf;</span><br><span class="line">   <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">      <span class="type">int</span> mid = (l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">pd</span>(mid)) l = mid;</span><br><span class="line">      <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   cout &lt;&lt; l;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
<p>在实数域的二分也有道题：</p>
<h3 id="极品飞车">极品飞车</h3>
<p><a href="https://www.luogu.com.cn/problem/UVA1753">click</a></p>
<p>已知<span class="math inline">\(\begin{aligned} \sum_{i=1} ^n \dfrac
{d_i} {s_i+c} = t\end{aligned}\)</span>求<span
class="math inline">\(c\)</span><span class="math inline">\((d_i&gt;0,
s_i+c&gt;0)\)</span></p>
<p>其中精度要求<span class="math inline">\(1e\)</span><span
class="math inline">\(-6\)</span></p>
<p>左边函数是单调递减的，因此可二分求解，</p>
<p>常用板子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (r - l &gt; eps) &#123;</span><br><span class="line">    <span class="type">double</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pd</span>(mid)) l = mid;</span><br><span class="line">    <span class="keyword">else</span> r = mid;</span><br><span class="line">&#125;</span><br><span class="line">其中eps = <span class="number">1e-6</span></span><br></pre></td></tr></table></figure>
<p>小技巧：<span class="math inline">\(while(cnt--)\)</span>其中cnt =
100</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">66</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, t;</span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line"><span class="type">double</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">while</span> (<span class="built_in">scanf</span> (<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;t) != EOF) &#123;</span><br><span class="line">      <span class="type">int</span> cnt = <span class="number">100</span>, i;</span><br><span class="line">      <span class="type">double</span> l = <span class="number">1e8</span>, r = <span class="number">1e8</span>, res, mid;</span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">         cin &gt;&gt; d[i] &gt;&gt; s[i];</span><br><span class="line">         l = <span class="built_in">min</span>(l, s[i]);</span><br><span class="line">      &#125;</span><br><span class="line">      l = -l;</span><br><span class="line">      <span class="keyword">while</span> (cnt --) &#123;</span><br><span class="line">         mid = (l+r)/<span class="number">2</span>, res = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) res += d[i]/(s[i]+mid);</span><br><span class="line">         <span class="keyword">if</span> (res &lt; t) r = mid;</span><br><span class="line">         <span class="keyword">else</span> l = mid;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span> (<span class="string">&quot;%.9lf\n&quot;</span>, l);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
<p>关于分治，分而治之嘛</p>
<p>有一些关于主定理的东西，但是noip不考，详见<a
href="https://www.cnblogs.com/oier/p/9454539.html">click</a></p>
<h3 id="无聊序列">无聊序列</h3>
<p><a href="https://www.luogu.com.cn/problem/UVA1608">click</a></p>
<p>考虑如果这个区间中存在某个数，使得它在整段区间中出现次数为1，那么对于所有包含该数的子区间，该数都出现且仅出现1次。所以只需要分治处理这个数左右两端的子区间即可；如果这个区间中不存在这样的数，那么它就是不合法的</p>
<p>具体：从左右两端向中间扫，扫到了就停止。这样找一次的复杂度一定是2倍较短区间长度</p>
<p><span class="math inline">\(20.08.10update\)</span></p>
<p><strong>PS:</strong>题意太操蛋了，大致意思就是说，如果在某一个区间里面，发现某一个数出现了一次，那么这个区间就叫做不无聊的序列，</p>
<p>比如<span
class="math inline">\({1,2,3,2,3}\)</span>尽管2,3都出现了他娘的两次，但是1出现了一次，所以这个区间还是他娘的不无聊序列</p>
<p>那我们就记这个数上一次出现的位置，和下一次出现的位置，特判<span
class="math inline">\(pres[linr] \; &lt; \; l\)</span> &amp;&amp; <span
class="math inline">\(nex[linr] \; &gt; \; r\)</span>就好了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//东方之珠 整夜未眠！</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span>+<span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N], pres[N], nex[N];</span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">work</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (l == r || l &gt; r) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   <span class="type">int</span> linl = l, linr = r;</span><br><span class="line">   <span class="keyword">while</span> (linl &lt; linr) &#123;</span><br><span class="line">      -- linr;</span><br><span class="line">      <span class="keyword">if</span> (pres[linr] &lt; l &amp;&amp; nex[linr] &gt; r)</span><br><span class="line">         <span class="keyword">if</span> (<span class="built_in">work</span>(l, linr - <span class="number">1</span>) &amp;&amp; <span class="built_in">work</span>(linr + <span class="number">1</span>, r))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      ++ linl;</span><br><span class="line">      <span class="keyword">if</span> (pres[linl] &lt; l &amp;&amp; nex[linl] &gt; r)</span><br><span class="line">         <span class="keyword">if</span> (<span class="built_in">work</span>(l, linl - <span class="number">1</span>) &amp;&amp; <span class="built_in">work</span>(linl + <span class="number">1</span>, r))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="type">int</span> T, i, j, n;</span><br><span class="line">   <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">   <span class="keyword">while</span> (T --&gt; <span class="number">0</span>) &#123;</span><br><span class="line">      mp.<span class="built_in">clear</span>();</span><br><span class="line">      <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">         <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">         pres[i] = <span class="number">0</span>, nex[i] = n+<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">         <span class="keyword">if</span> (mp.<span class="built_in">find</span>(a[i]) != mp.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            pres[i] = mp[a[i]];</span><br><span class="line">            nex[mp[a[i]]] = i;</span><br><span class="line">         &#125;</span><br><span class="line">         mp[a[i]] = i;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">work</span>(<span class="number">1</span>, n)) <span class="built_in">puts</span>(<span class="string">&quot;non-boring&quot;</span>);</span><br><span class="line">      <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;boring&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
<p>关于贪心嘛，一般都不是正解，但是应用面十分的广泛</p>
<h3 id="线段覆盖">线段覆盖</h3>
<p><a href="https://www.luogu.com.cn/problem/P1803">click</a></p>
<p>右端点排个序就好了，证明也很简单，从左往右放，右端点越小，妨碍越小</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, res;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;<span class="type">int</span> s, t;&#125;a[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">cmp</span><span class="params">(node x, node y)</span></span>&#123;<span class="keyword">return</span> x.t &lt; y.t;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      <span class="built_in">scanf</span> (<span class="string">&quot;%d%d&quot;</span>, &amp;a[i].s, &amp;a[i].t);</span><br><span class="line">   <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>, cmp);</span><br><span class="line">   <span class="type">int</span> end = a[<span class="number">1</span>].t; res = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (end &lt;= a[i].s) &#123;</span><br><span class="line">         ++ res, end = a[i].t;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   cout &lt;&lt; res;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="国王游戏">国王游戏</h3>
<p><a href="https://www.luogu.com.cn/problem/P1080">click</a></p>
<p>对于相邻的<span class="math inline">\(i\)</span>和<span
class="math inline">\(j\)</span>，令<span
class="math inline">\(i,j\)</span> 比<span
class="math inline">\(j,i\)</span> 更优，</p>
<p>则有<span class="math inline">\(max(\dfrac 1 {b[i]},\dfrac
{a[i]}{b[j]})&lt;max(\dfrac 1 {b[j]}, \dfrac{a[j]} {b[i]})\)</span></p>
<p>又因为<span class="math inline">\(\dfrac {a[i]}{b[j]}&gt;\dfrac 1
{b[j]}\)</span>，<span class="math inline">\(\dfrac{a[j]}
{b[i]}&gt;\dfrac 1 {b[i]}\)</span>，</p>
<p>因此必须有<span class="math inline">\(\dfrac{a[j]} {b[i]} &gt; \dfrac
{a[i]}{b[j]}&gt;\)</span>化简后得<span
class="math inline">\(a[i]*b[i]&lt;a[j]*b[j]\)</span></p>
<p>于是贪心策略就是按照<span
class="math inline">\(a*b\)</span>从小到大排序，之后计算即可</p>
<p>代码没写</p>
<h3 id="护花">护花</h3>
<p><a href="https://www.luogu.com.cn/problem/P2878">click</a></p>
<p>一眼贪心，随便推一下就可以得到<span class="math inline">\(\dfrac
{t[i]} {d[i]}\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>+<span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, sum[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;<span class="type">int</span> t, d; <span class="type">double</span> paixu;&#125;a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">cmp</span><span class="params">(node x, node y)</span> </span>&#123;<span class="keyword">return</span> x.paixu &lt; y.paixu;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   cin &gt;&gt; n;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">      cin &gt;&gt; a[i].t &gt;&gt; a[i].d;</span><br><span class="line">      a[i].paixu = (<span class="type">double</span>)a[i].t/a[i].d;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>, cmp);</span><br><span class="line">   <span class="type">int</span> res = <span class="number">0</span>, shijian = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">      shijian += a[i - <span class="number">1</span>].t*<span class="number">2</span>;</span><br><span class="line">      res += shijian*a[i].d;</span><br><span class="line">   &#125;</span><br><span class="line">   cout &lt;&lt; res;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
<p>贪心也经常与堆一起用</p>
<h3 id="合并果子">合并果子</h3>
<p><a href="https://www.luogu.com.cn/problem/P1090">click</a></p>
<p>设有a、b、c，令a+b+a+b+c
是所有合并方案中最小的，推出a&lt;c且b&lt;c</p>
<p>也可以用于“反悔“</p>
<h3 id="hur-warehouse-store">HUR-Warehouse Store</h3>
<p><a href="https://www.luogu.com.cn/problem/P3545">click</a></p>
<p>我们肯定是维护一个堆，如果发现当前的客户满足不了了，就尝试踢掉原来的最大的一个</p>
<p>贪心证明：是当前的剩余尽量多，保证后面可以满足更多客户</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span>+<span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, num;</span><br><span class="line"><span class="type">int</span> a[N], b[N], v[N];</span><br><span class="line"></span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt;q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">scanf</span> (<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span> (<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span> (<span class="string">&quot;%lld&quot;</span>, &amp;b[i]);</span><br><span class="line">   <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">      res += a[i];</span><br><span class="line">      <span class="keyword">if</span> (res &gt;= b[i]) &#123;</span><br><span class="line">         res -= b[i];</span><br><span class="line">         q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(b[i], i));</span><br><span class="line">         v[i] = <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (!q.<span class="built_in">empty</span>() &amp;&amp; q.<span class="built_in">top</span>().first &gt; b[i]) &#123;</span><br><span class="line">            <span class="type">int</span> t = q.<span class="built_in">top</span>().second; q.<span class="built_in">pop</span>();</span><br><span class="line">            res = res + b[t] - b[i];</span><br><span class="line">            q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(b[i], i));</span><br><span class="line">            v[t] = <span class="number">0</span>, v[i] = <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="keyword">if</span> (v[i]) ++ num;</span><br><span class="line">   <span class="built_in">printf</span> (<span class="string">&quot;%lld\n&quot;</span>, num);</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) </span><br><span class="line">      <span class="keyword">if</span> (v[i])</span><br><span class="line">         cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="建筑抢修">建筑抢修</h3>
<p><a href="https://www.luogu.com.cn/problem/P4053">click</a></p>
<p>可以推出按<span
class="math inline">\(second\)</span>从小到大排序，排完序之后和上个题一摸一样啊</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>+<span class="number">66</span>;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;<span class="type">int</span> s, t;&#125;a[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">cmp</span> <span class="params">(node x, node y)</span> </span>&#123;<span class="keyword">return</span> x.t &lt; y.t;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">scanf</span> (<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">      <span class="built_in">scanf</span> (<span class="string">&quot;%lld%lld&quot;</span>, &amp;a[i].s, &amp;a[i].t);</span><br><span class="line">   <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>, cmp);</span><br><span class="line">   <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (res + a[i].s &lt;= a[i].t) &#123;</span><br><span class="line">         res += a[i].s;</span><br><span class="line">         q.<span class="built_in">push</span>(a[i].s);</span><br><span class="line">         ++ num;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!q.<span class="built_in">empty</span>() &amp;&amp; q.<span class="built_in">top</span>() &gt; a[i].s) &#123;<span class="comment">//为什么不写成res - q.top() + a[i].s &lt;= a[i].t，留给读者自己思考</span></span><br><span class="line">         res = res - q.<span class="built_in">top</span>() + a[i].s; q.<span class="built_in">pop</span>();</span><br><span class="line">         q.<span class="built_in">push</span>(a[i].s);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   cout &lt;&lt; num;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="合并果子nb版本">合并果子nb版本</h3>
<p><a href="https://www.luogu.com.cn/problem/P6033">click</a></p>
<p>考虑一个队列存排序结果（当然是桶排），另一个存合并结果，每次取出队首，这题需要快读和LL</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e7</span>+<span class="number">66</span>;</span><br><span class="line"></span><br><span class="line">queue&lt;<span class="type">int</span>&gt;q1, q2;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, res;</span><br><span class="line"><span class="type">int</span> a[N], b[N&gt;&gt;<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="type">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="type">char</span> ch;</span><br><span class="line">   <span class="keyword">while</span> (! <span class="built_in">isdigit</span>(ch = <span class="built_in">getchar</span>())) (ch == <span class="string">&#x27;-&#x27;</span>) &amp;&amp; (f = -f);</span><br><span class="line">   <span class="keyword">for</span> (x = ch ^ <span class="number">48</span>; <span class="built_in">isdigit</span>(ch = <span class="built_in">getchar</span>()); x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="number">48</span>));</span><br><span class="line">   <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Find</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="type">int</span> x;</span><br><span class="line">   <span class="keyword">if</span> ((q1.<span class="built_in">front</span>() &lt; q2.<span class="built_in">front</span>() &amp;&amp; !q1.<span class="built_in">empty</span>()) || q2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      x = q1.<span class="built_in">front</span>();</span><br><span class="line">      q1.<span class="built_in">pop</span>();</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      x = q2.<span class="built_in">front</span>();</span><br><span class="line">      q2.<span class="built_in">pop</span>();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   n = <span class="built_in">read</span>();</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">      a[i] = <span class="built_in">read</span>();</span><br><span class="line">      ++ b[a[i]];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N&gt;&gt;<span class="number">6</span>; ++ i) &#123;</span><br><span class="line">      <span class="keyword">while</span> (b[i]) &#123;</span><br><span class="line">         -- b[i];</span><br><span class="line">         q1.<span class="built_in">push</span>(i);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">      <span class="type">int</span> x = <span class="built_in">Find</span>();</span><br><span class="line">      <span class="type">int</span> y = <span class="built_in">Find</span>();</span><br><span class="line">      q2.<span class="built_in">push</span>(x + y);</span><br><span class="line">      res += x + y;</span><br><span class="line">   &#125;</span><br><span class="line">   cout &lt;&lt; res;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
<p>还有一类比较难的数位贪心，整体思路是需要从高位到低位贪心，证明显然。这种题目常见与二进制位运算中</p>
<h3 id="起床困难综合症">起床困难综合症</h3>
<p><a href="https://www.luogu.com.cn/problem/P2114">click</a></p>
<p>位运算的主要特点是不用进位</p>
<p><span
class="math inline">\(x_0\)</span>的第k位应该填1而不是零，当且仅当满足一下两个条件：
1.用已经填好的最高位的数加上当前的<span
class="math inline">\(1&lt;&lt;k\)</span>不超过m
2.(lyd原话：)用每个参数的第k位参加运算，若初值为1，则n次运算之后结果为1
若初值为0，则n次运算之后为0</p>
<p>其实我现在还是不太明白第二点在表达什么...</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//东方之珠 整夜未眠！</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">pair&lt;string, <span class="type">int</span>&gt;a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> bit, <span class="type">int</span> now)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">      <span class="type">int</span> x = (a[i].second&gt;&gt;bit)&amp;<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (a[i].first == <span class="string">&quot;AND&quot;</span>) now &amp;= x;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (a[i].first == <span class="string">&quot;OR&quot;</span>) now |= x;</span><br><span class="line">      <span class="keyword">else</span> now ^= x;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">      <span class="type">char</span> ch[<span class="number">5</span>]; <span class="type">int</span> x;</span><br><span class="line">      <span class="built_in">scanf</span> (<span class="string">&quot;%s%d&quot;</span>, ch, &amp;x);</span><br><span class="line">      a[i] = <span class="built_in">make_pair</span>(ch, x);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">int</span> val = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> bit = <span class="number">30</span>; bit &gt;= <span class="number">0</span>; -- bit) &#123;</span><br><span class="line">      <span class="type">int</span> res0 = <span class="built_in">calc</span>(bit, <span class="number">0</span>);</span><br><span class="line">      <span class="type">int</span> res1 = <span class="built_in">calc</span>(bit, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (val + (<span class="number">1</span>&lt;&lt;bit) &lt;= m &amp;&amp; res0 &lt; res1) </span><br><span class="line">         val += (<span class="number">1</span>&lt;&lt;bit), ans += res1 &lt;&lt; bit;</span><br><span class="line">      <span class="keyword">else</span> ans += res0 &lt;&lt; bit;</span><br><span class="line">   &#125;</span><br><span class="line">   cout &lt;&lt; ans;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="or-xor">or xor</h3>
<p><a
href="https://www.cnblogs.com/DaD3zZ-Beyonder/p/6130881.html">click</a></p>
<p>不会….</p>
<h1 id="晚上">晚上</h1>
<p>补坑 写博客 做题</p>
]]></content>
      <categories>
        <category>暑假日常</category>
      </categories>
      <tags>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title>8.04集训</title>
    <url>/2020/08/04/8.4%E9%9B%86%E8%AE%AD/</url>
    <content><![CDATA[<p>#上午</p>
<p>考试 <span id="more"></span></p>
<h3 id="第一题">第一题</h3>
<p>给你一个初始序列，和两个操作：操作1可以使得<span
class="math inline">\(i\)</span>与<span
class="math inline">\(i+2\)</span>两个数交换位置，操作2是相邻的数可以交换位置</p>
<p>问：这个序列最少用多少次操作2可是使序列单调递增？</p>
<p>你考虑，操作1的性质：使得<span
class="math inline">\(i\)</span>与<span
class="math inline">\(i+2\)</span>两个数交换位置，不就是奇偶性相同的位置吗？而操作2的性质：相邻的数可以交换位置，不就是奇偶性不同的数吗？</p>
<p>把原序列排序之后，对于为排序的序列，我们考虑当前这个数的下标与排完序之后的下标，如果发现他们奇偶性相同，也就是说，可以经过若干次操作1可以变换到那个位置</p>
<p>如果发现奇偶性不同，说明肯定是经过了一次操作1，因此计数器叠加</p>
<p>注意细节：这样统计是<strong>真实答案的二倍</strong>，因为：假如当前在<span
class="math inline">\(i\)</span>，你发现这个数排完序之后在<span
class="math inline">\(j\)</span>（<span class="math inline">\(i &lt;
j\)</span>），且<span
class="math inline">\(i,j\)</span>的奇偶性不同，这时你计数器累加，但是到了<span
class="math inline">\(j\)</span>那个位置，你的计数器还会叠加，也就是说，你的计数器对于同一种情况增加了两次</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span>+<span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, res;</span><br><span class="line"><span class="type">int</span> a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   cin &gt;&gt; n;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">      cin &gt;&gt; a[i];</span><br><span class="line">      b[i] = a[i];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">sort</span>(b+<span class="number">1</span>, b+n+<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">      <span class="type">int</span> pos = <span class="built_in">lower_bound</span>(b+<span class="number">1</span>, b+n+<span class="number">1</span>, a[i]) - b;</span><br><span class="line">      <span class="keyword">if</span> ((pos&amp;<span class="number">1</span>) != (i&amp;<span class="number">1</span>)) ++ res;</span><br><span class="line">   &#125;</span><br><span class="line">   cout &lt;&lt; (res/<span class="number">2</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
<p>###第二题</p>
<p>有<span
class="math inline">\(10^8\)</span>条横向道路与竖向道理，相邻的道路之间相差<span
class="math inline">\(100m\)</span>，从左到右第<span
class="math inline">\(i\)</span>条纵向街道和从下到上第<span
class="math inline">\(j\)</span>条横向街道之间的交点描述为<span
class="math inline">\((i,j)\)</span>，在某些交点上建有以交点为圆心，半径是
<span class="math inline">\(10\)</span>
米的喷泉，行走时不能穿过喷泉。</p>
<p>问你要从<span class="math inline">\((x_1,x_2)\)</span>走到<span
class="math inline">\((x_2,y_2)\)</span>最短要走多少？</p>
<details>
<summary>
Sample Input
</summary>
<pre><code>1 1 6 5
3
3 2
5 3
2 4
</code></pre>
</details>
<details>
<summary>
Sample Output
</summary>
<pre><code>891.415926535897938
</code></pre>
</details>
<p><img
src="https://pic.imgdb.cn/item/6327e1b616f2c2beb13b0fdb.png" /></p>
<p>有<span
class="math inline">\(10^8\)</span>条横向道路与竖向道理，相邻的道路之间相差<span
class="math inline">\(100m\)</span>，从左到右第<span
class="math inline">\(i\)</span>条纵向街道和从下到上第<span
class="math inline">\(j\)</span>条横向街道之间的交点描述为<span
class="math inline">\((i,j)\)</span>，在某些交点上建有以交点为圆心，半径是
<span class="math inline">\(10\)</span>
米的喷泉，行走时不能穿过喷泉。</p>
<p>问你要从<span class="math inline">\((X_1,Y_2)\)</span>走到<span
class="math inline">\((X_2,Y_2)\)</span>最短要走多少？</p>
<p>由于所有的喷泉横纵坐标都相等，所以显然走尽可能多的喷泉可以是路径更短，</p>
<p>对于一个喷泉可以短<span class="math inline">\(20-\dfrac 1 4* 2\pi
r\)</span></p>
<p>至此问题完成转化：最长上升子序列问题</p>
<p>不妨设<span
class="math inline">\(X_1&lt;X_2,Y_1&lt;Y_2\)</span>，仅当<span
class="math inline">\(X_1&lt;x_i&lt;X_2,Y_1&lt;y_i&lt;Y_2\)</span>时候，统计这个点对答案的影响</p>
<p>并把所有点按照横坐标排序，求<span
class="math inline">\(y_i\)</span>以<span
class="math inline">\(Y_1\)</span>为开始，<span
class="math inline">\(Y_2\)</span>终止的最长上升子序列</p>
<p>对于正常的<span
class="math inline">\(dp\)</span>做法，过不去的，需要用<span
class="math inline">\(nlog_n\)</span>的做法，我想，下文会提到的吧</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span>+<span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, ans, f[N];</span><br><span class="line"><span class="type">int</span> sx, sy, tx, ty;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;<span class="type">int</span> x, y;&#125;a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">cmp</span><span class="params">(node s, node t)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (s.x == t.x) <span class="keyword">return</span> s.y &gt; t.y;</span><br><span class="line">   <span class="keyword">if</span> (sy &lt; ty) <span class="keyword">return</span> s.x &lt; t.x;</span><br><span class="line">   <span class="keyword">return</span> s.x &gt; t.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   cin &gt;&gt; sx &gt;&gt; sy &gt;&gt; tx &gt;&gt; ty &gt;&gt; n;</span><br><span class="line">   <span class="keyword">if</span> (tx &lt; sx) <span class="built_in">swap</span>(sx, tx), <span class="built_in">swap</span>(sy, ty);</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cin &gt;&gt; a[i].x &gt;&gt; a[i].y;</span><br><span class="line">   <span class="built_in">sort</span>(a+<span class="number">1</span>, a+n+<span class="number">1</span>, cmp);</span><br><span class="line">   <span class="type">double</span> mhd = tx - sx + <span class="built_in">abs</span>(ty - sy);</span><br><span class="line">   f[<span class="number">0</span>] = <span class="number">-0x7fffffff</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[i].x &gt; <span class="built_in">max</span>(sx, tx) || a[i].x &lt; <span class="built_in">min</span>(sx, tx) || a[i].y &gt; <span class="built_in">max</span>(sy, ty) || a[i].y &lt; <span class="built_in">min</span>(sy, ty)) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span> (a[i].y &gt; f[ans]) f[++ ans] = a[i].y;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (a[i].y &lt; f[ans]) &#123;</span><br><span class="line">         <span class="type">int</span> pos = <span class="built_in">lower_bound</span>(f+<span class="number">1</span>, f+ans+<span class="number">1</span>, a[i].y) - f;</span><br><span class="line">         f[pos] = a[i].y;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span> (<span class="string">&quot;%.15lf&quot;</span>, <span class="number">100</span>*mhd-ans*(<span class="number">20</span><span class="number">-5</span>*M_PI));</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第三题">第三题</h3>
<p>显然，三分图有以下性质：</p>
<ul>
<li>同一集合内，没有连边</li>
<li>不存在一个点向同一个集合连两条边</li>
</ul>
<p>发现上面的性质好像只涉及到两个集合啊，因此答案呼之欲出：<span
class="math inline">\(calc(A,B)*calc(A,C)*calc(B,C)\)</span></p>
<p>状态：设<span
class="math inline">\(f[i][j]\)</span>表示一个集合有<span
class="math inline">\(i\)</span>个点，另一个集合有<span
class="math inline">\(j\)</span>个点的时候，炼成的三分图的个数</p>
<p>转移：<span class="math inline">\(f[i][j] =
f[i][j-1]+f[i-1][j-1]*i\)</span></p>
<p>考虑第二个集合的最后一个点，他可能有什么情况，</p>
<p>第一种，不连边，继承上一次的</p>
<p>第二种，连边，则有<span
class="math inline">\(i\)</span>种连边方式，若练了某条边，则第一个集合对应的点就不能连其他边了，方案数为：<span
class="math inline">\(i*f[i-1][j-1]\)</span></p>
<p>结果：<span
class="math inline">\(f[a][b]*f[b][c]*f[a][c]\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e3</span>+<span class="number">66</span>, mod = <span class="number">998244353</span>, M = <span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t, a, b, c;</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   cin &gt;&gt; t;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3000</span>; ++ i) &#123;</span><br><span class="line">      f[i][<span class="number">1</span>] = i+<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j &lt;= i; ++ j) </span><br><span class="line">         f[i][j] = (f[i][j - <span class="number">1</span>] + i*f[i - <span class="number">1</span>][j - <span class="number">1</span>]%mod)%mod;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3000</span>; ++ i)</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; ++ j)</span><br><span class="line">         f[j][i] = f[i][j];</span><br><span class="line">         <span class="keyword">while</span>(t --&gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> a, b, c;</span><br><span class="line">            cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">            cout &lt;&lt; f[a][b]*f[a][c]%mod*f[b][c]%mod &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">         &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="下午">下午</h1>
<p>讲dp！！！</p>
<p>我们来通过通过几道例题来体会一下什么是dp</p>
<h3 id="背包">01背包</h3>
<p>将n件有着各自体积和价值的物品装入一个容积为m的背包中，求最大的总价值</p>
<p>状态：<span class="math inline">\(f[i][j]\)</span>表示前<span
class="math inline">\(i\)</span>件物品放入背包为<span
class="math inline">\(j\)</span>的背包中所能获得的最大总价值</p>
<p>转移：<span class="math inline">\(f[i][j] = max(f[i-1][j],
f[i-1][j-v[i]]+w[i])\)</span></p>
<p>结果：<span class="math inline">\(f[n][m]\)</span></p>
<h3 id="最长不下降子序列">最长不下降子序列</h3>
<p>给出一个长度为n 的序列，求最长的子序列，满足这些元素依次不减</p>
<p>状态：设<span class="math inline">\(f[i]\)</span>表示以<span
class="math inline">\(i\)</span>为结尾的最长不下降子序列的最长长度</p>
<p>转移：<span class="math inline">\(f[i] =
max(f[j]+1)\)</span>其中<span
class="math inline">\(a[j]&lt;a[i]\)</span></p>
<p>结果：<span class="math inline">\(max(f[i])\)</span></p>
<p>上面是<span class="math inline">\(O(n^2)\)</span>做法，还有一种<span
class="math inline">\(O(nlogn)\)</span>的做法：</p>
<p>状态：设<span class="math inline">\(f[i]\)</span>表示长度为<span
class="math inline">\(i\)</span>的的最长不下降子序列的最后一个元素的最小值</p>
<p>举个例子：</p>
<p>有序列<span class="math inline">\(a[] =
{8,2,3,5,7,6,4}\)</span>，所以可得：</p>
<p><span class="math inline">\(f[0] = 0,f[1] = 2, f[2] = 3,
f[3]=5,f[4]=7\)</span>(第一遍扫)</p>
<p>遇到<span class="math inline">\(6\)</span>考虑更新<span
class="math inline">\(f[4]\)</span>，遇到<span
class="math inline">\(4\)</span>考虑更新<span
class="math inline">\(f[3]\)</span></p>
<p>至于为什么是logn的，因为每次是二分查找（<span
class="math inline">\(lower\)</span>_<span
class="math inline">\(bound\)</span>是log的）</p>
<p>再次考虑<span class="math inline">\(dp\)</span>的牛逼之处：
需要有<strong>易于表示的状态，能够列出的转移，便于计算的结果</strong></p>
<p>要把式子推出来再去写代码</p>
<p>下面有几道一般dp，没什么特点，就是<strong>难</strong></p>
<h3 id="渡河问题">渡河问题</h3>
<p><a href="https://darkbzoj.tk/problem/1617">click</a></p>
<p>状态：<span class="math inline">\(f[i]\)</span>表示将前<span
class="math inline">\(i\)</span>头牛运到对岸的时间</p>
<p>转移：<span class="math inline">\(f[i] =
min(f[j]+2*M+sum[i-j])\)</span>其中<span
class="math inline">\(sum\)</span>为前缀和</p>
<p>结果：<span class="math inline">\(f[n]\)</span></p>
<h3 id="解题">解题</h3>
<p><a href="https://darkbzoj.tk/problem/1700">click</a></p>
<p>给出贪心的<span class="math inline">\(Hack\)</span>数据：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">50</span> <span class="number">5</span>  </span><br><span class="line"><span class="number">40</span> <span class="number">10</span>  </span><br><span class="line"><span class="number">10</span> <span class="number">40</span>  </span><br><span class="line"><span class="number">10</span> <span class="number">5</span>  </span><br><span class="line"><span class="number">10</span> <span class="number">3</span>  </span><br><span class="line"><span class="number">10</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>状态：<span class="math inline">\(f[i][j]\)</span>表示处理<span
class="math inline">\(1\)</span>到<span
class="math inline">\(j\)</span>的题，最后一次选择了<span
class="math inline">\(i\)</span>到<span
class="math inline">\(j\)</span>的最短月数</p>
<p>转移：<span class="math inline">\(f[i][j] =
min(f[k][i-1]+1/2)\)</span>其中剩下的钱足够就是<span
class="math inline">\(+1\)</span>否则是<span
class="math inline">\(+2\)</span></p>
<p>结果：<span class="math inline">\(min(f[i][p])+1\)</span></p>
<h1 id="晚上">晚上</h1>
<p>没时间写了啊，**白某飞主任</p>
]]></content>
      <categories>
        <category>暑假日常</category>
      </categories>
      <tags>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title>8.05集训</title>
    <url>/2020/08/05/8.5%E9%9B%86%E8%AE%AD/</url>
    <content><![CDATA[<h1 id="上午">上午</h1>
<p>考试 <span id="more"></span> ### 第一题</p>
<p><a href="https://www.luogu.com.cn/problem/P2165">click</a></p>
<p>考试的时候这个题的数据比较大，<span class="math inline">\(n \leq
2e6\)</span></p>
<p>考虑枚举圆的直径，搞一个双指针来操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e6</span>+<span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, a[N], sum[N], res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">scanf</span> (<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">      <span class="built_in">scanf</span> (<span class="string">&quot;%lld&quot;</span>,a+i);</span><br><span class="line">      sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">int</span> yhm = sum[n]/<span class="number">2</span>, num;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">      num = i;</span><br><span class="line">      <span class="keyword">if</span> (sum[i] &gt; yhm) <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">int</span> top = num, kaishi = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> (kaishi &lt; top || num &lt; n) &#123;</span><br><span class="line">      <span class="keyword">while</span> (sum[num] - sum[kaishi] &gt; yhm) ++ kaishi;</span><br><span class="line">      <span class="keyword">if</span> (kaishi == top &amp;&amp; num == n) <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span> (sum[num] - sum[kaishi] == yhm) ++ res;</span><br><span class="line">      ++ num;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(res == <span class="number">0</span> || sum[n] % <span class="number">2</span> == <span class="number">1</span>) cout&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">   <span class="keyword">else</span> cout &lt;&lt; res*(res - <span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
<p>###第二题</p>
<p><a href="https://www.luogu.com.cn/problem/P2339">click</a></p>
<p>状态：<span class="math inline">\(f[i][j][1/0]\)</span>表示对于<span
class="math inline">\(i\)</span>到<span
class="math inline">\(j\)</span>这段区间的作业还没有提交，下一次将提交<span
class="math inline">\(i(0)\)</span>或<span
class="math inline">\(j(1)\)</span>处的作业</p>
<p>转移：四个式子，<span
class="math inline">\(f[i][j][0]\)</span>与<span
class="math inline">\(f[i][j][1]\)</span>分别可以由左右两边的<span
class="math inline">\(i-1\)</span>和<span
class="math inline">\(j-1\)</span>转移，显然：</p>
<p><span class="math inline">\(f[i][j][0] = min(f[i][j][0], max(f[i -
1][j][0]+a[i].x-a[i - 1].x, a[i].t))\)</span></p>
<p><span class="math inline">\(f[i][j][0] = min(f[i][j][0], max(f[i][j +
1][1]+a[j + 1].x-a[i].x, a[i].t))\)</span></p>
<p><span class="math inline">\(f[i][j][1] = min(f[i][j][1], max(f[i -
1][j][0]+a[j].x-a[i - 1].x, a[j].t))\)</span></p>
<p><span class="math inline">\(f[i][j][1] = min(f[i][j][1], max(f[i][j +
1][1]+a[j + 1].x-a[j].x, a[j].t))\)</span></p>
<p>结果：<span class="math inline">\(min(f[i][i][0],
f[i][i][1])+abs(a[c].x-b)\)</span></p>
<p>给出AC代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> c, h, b, res = <span class="number">1</span>&lt;&lt;<span class="number">30</span>;</span><br><span class="line"><span class="type">int</span> f[<span class="number">1250</span>][<span class="number">1250</span>][<span class="number">6</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;<span class="type">int</span> x, t;&#125;a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">cmp</span><span class="params">(node s, node t)</span> </span>&#123;<span class="keyword">return</span> s.x &lt; t.x;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">scanf</span> (<span class="string">&quot;%d%d%d&quot;</span>, &amp;c, &amp;h, &amp;b);</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= c; ++ i) cin &gt;&gt; a[i].x &gt;&gt; a[i].t;</span><br><span class="line">   <span class="built_in">sort</span>(a+<span class="number">1</span>, a+c+<span class="number">1</span>, cmp);</span><br><span class="line">   <span class="built_in">memset</span>(f, <span class="number">0x7f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">   f[<span class="number">1</span>][c][<span class="number">0</span>] = <span class="built_in">max</span>(a[<span class="number">1</span>].x, a[<span class="number">1</span>].t), f[<span class="number">1</span>][c][<span class="number">1</span>] = <span class="built_in">max</span>(a[c].x, a[c].t);</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= c; ++ i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = c; j &gt;= i; -- j) &#123;</span><br><span class="line">         f[i][j][<span class="number">0</span>] = <span class="built_in">min</span>(f[i][j][<span class="number">0</span>], <span class="built_in">max</span>(f[i - <span class="number">1</span>][j][<span class="number">0</span>]+a[i].x-a[i - <span class="number">1</span>].x, a[i].t));</span><br><span class="line">         f[i][j][<span class="number">0</span>] = <span class="built_in">min</span>(f[i][j][<span class="number">0</span>], <span class="built_in">max</span>(f[i][j + <span class="number">1</span>][<span class="number">1</span>]+a[j + <span class="number">1</span>].x-a[i].x, a[i].t));</span><br><span class="line">         f[i][j][<span class="number">1</span>] = <span class="built_in">min</span>(f[i][j][<span class="number">1</span>], <span class="built_in">max</span>(f[i - <span class="number">1</span>][j][<span class="number">0</span>]+a[j].x-a[i - <span class="number">1</span>].x, a[j].t));</span><br><span class="line">         f[i][j][<span class="number">1</span>] = <span class="built_in">min</span>(f[i][j][<span class="number">1</span>], <span class="built_in">max</span>(f[i][j + <span class="number">1</span>][<span class="number">1</span>]+a[j + <span class="number">1</span>].x-a[j].x, a[j].t));</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= c; ++ i) res = <span class="built_in">min</span>(res, <span class="built_in">min</span>(f[i][i][<span class="number">1</span>], f[i][i][<span class="number">0</span>])+<span class="built_in">abs</span>(a[i].x-b));</span><br><span class="line">   cout &lt;&lt; res;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="第三题">第三题</h3>
<p><img
src="https://pic.imgdb.cn/item/6327e12c16f2c2beb13a7f0c.png" /></p>
<p>恶心程度显然....</p>
<p><img
src="https://pic.imgdb.cn/item/6327e14e16f2c2beb13aa763.png" /></p>
<p>给出自己的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">250</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ta, tb, tc;</span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">   <span class="type">int</span> x, y;</span><br><span class="line">   <span class="built_in">node</span>()&#123;&#125;;</span><br><span class="line">   <span class="built_in">node</span>(<span class="type">int</span> X, <span class="type">int</span> Y)&#123;x = X, y = Y;&#125;</span><br><span class="line">   <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> node a) <span class="type">const</span> &#123;<span class="keyword">return</span> x != a.x || y != a.y;&#125;</span><br><span class="line">   <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node a) <span class="type">const</span> &#123;<span class="keyword">return</span> x == a.x?y&lt;a.y:x&lt;a.x;&#125;</span><br><span class="line">&#125;a[N], b[N&lt;&lt;<span class="number">4</span>], c[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dx[] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="type">int</span> i, j;</span><br><span class="line">   tb = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= ta; ++ i) b[++ tb] = a[i];</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= ta; ++ i)</span><br><span class="line">      <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">8</span>; ++ j)</span><br><span class="line">         b[++ tb] = <span class="built_in">node</span>(a[i].x + dx[j], a[i].y + dy[j]);</span><br><span class="line">   <span class="built_in">sort</span>(b + <span class="number">1</span>, b + tb + <span class="number">1</span>);</span><br><span class="line">   j = tb, tb = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= j; ++ i)</span><br><span class="line">      <span class="keyword">if</span> (b[i] != b[i - <span class="number">1</span>])</span><br><span class="line">         b[++ tb] = b[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="type">int</span> i, j, t;</span><br><span class="line">   tc = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= tb; ++ i) &#123;</span><br><span class="line">      t = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">8</span>;j ++)&#123;</span><br><span class="line">      <span class="keyword">if</span> (!(a[ta] &lt; <span class="built_in">node</span>(b[i].x + dx[j] , b[i].y + dy[j]) </span><br><span class="line">	|| *<span class="built_in">lower_bound</span>(a + <span class="number">1</span> , a + ta + <span class="number">1</span> , <span class="built_in">node</span>(b[i].x + dx[j] , b[i].y + dy[j]))</span><br><span class="line">	 != <span class="built_in">node</span>(b[i].x + dx[j] , b[i].y + dy[j])))</span><br><span class="line">         t ++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (t == <span class="number">3</span> || (t == <span class="number">2</span> &amp;&amp; !(a[ta] &lt; b[i] || *<span class="built_in">lower_bound</span>(a + <span class="number">1</span> , a + ta + <span class="number">1</span> , b[i]) != b[i])))</span><br><span class="line">         c[++tc] = b[i];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">sort</span>(c + <span class="number">1</span>, c + tc + <span class="number">1</span>);</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= tc; ++ i) a[i] = c[i];</span><br><span class="line">   ta = tc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   cin &gt;&gt; ta &gt;&gt; T;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= ta; ++ i) cin &gt;&gt; a[i].x &gt;&gt; a[i].y;</span><br><span class="line">   <span class="built_in">sort</span>(a + <span class="number">1</span>, a + ta + <span class="number">1</span>);</span><br><span class="line">   <span class="keyword">while</span> (T --) <span class="built_in">work</span>(), <span class="built_in">solve</span>();</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ta);</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= ta; ++ i)</span><br><span class="line">      <span class="built_in">printf</span> (<span class="string">&quot;%d %d\n&quot;</span>, a[i].x, a[i].y);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
<p>#下午</p>
<p>讲课，数论与概率期望</p>
<p>关于数学的知识比较杂，首先是一些前置知识</p>
<h3 id="section">%</h3>
<p><span class="math inline">\((a+b)\;mod\;p =
(a\;mod\;p\;+b\;mod\;p)\;mod\;p\)</span></p>
<p><span class="math inline">\((a*b)\;mod\;p =
(a\;mod\;p\;*b\;mod\;p)\;mod\;p\)</span></p>
<p><span
class="math inline">\(a\;mod\;p=b\;mod\;p\Longleftrightarrow\;p\mid(a-b)\)</span></p>
<h3 id="快速幂">快速幂</h3>
<details>
<summary>
ksm_递归
</summary>
<pre><code>#define int long long
inline int ksm(int a, int b, int mod) &#123;
   if (!b) return a%mod;
   if (b&1) return a*ksm(a, b-1, mod);
   int tmp = ksm(a, (b>>1), mod)%mod;
   return tmp*tmp%mod;
&#125;
</code></pre>
</details>
<details>
<summary>
ksm_for
</summary>
<pre><code>inline int ksm(int a, int b, int mod) &#123;
   int res = 1;
   while(b) &#123;
      if (b&1) res = res*a%mod;
      a = a*a%mod;
      b >>= 1;
   &#125;
   return res;
&#125;
</code></pre>
</details>
<h3 id="基本算术定理">基本算术定理</h3>
<p>质因子分解的办法：</p>
<ul>
<li>试除法：枚举</li>
<li>试除法的优化（埃拉托色尼筛法）：预处理指数，枚举倍数</li>
<li>欧拉筛：在埃氏筛的基础上进行优化，线性筛的基础上记录下每个数的<strong>最小质因子</strong></li>
</ul>
<p>给出埃氏筛代码：</p>
<details>
<summary>
埃氏筛
</summary>
<pre><code>memset (v, 1, sizeof v);
v[1] = 0;
for (int i = 2; i <= N; ++ i) &#123;
   if (v[i]) prime[++ cnt] = i;
   for (int j = 1; j <= cnt && i*prime[j] <= N; ++ j)
      v[i*prime[j]] = 0;
&#125;
</code></pre>
</details>
<p>给出欧拉筛代码：</p>
<details>
<summary>
欧拉筛
</summary>
<pre><code>memset (v, 1, sizeof v);
v[1] = 0;
for (int i = 2; i <= N; ++ i) &#123;
   if (v[i]) prime[++ cnt] = i;
   for (int j = 1; j <= cnt && i*prime[j] <= N; ++ j) &#123;
      v[i*prime[j]] = 0;
      if (i%prime[j] == 0) break;
   &#125;
&#125;
</code></pre>
</details>
<p>考虑欧拉筛是如何优化的？在埃氏筛中，每一个数字可能会被多次筛到，浪费了时间复杂度，而欧拉筛中每个只会被筛到一次，且是由他的最小质因子筛出来的</p>
<p>考虑如下：</p>
<p><span class="math inline">\(i = 2\)</span>筛出<span
class="math inline">\(4\)</span>，<span class="math inline">\(i
=3\)</span>筛出<span class="math inline">\(6,9\)</span>，<span
class="math inline">\(i=4\)</span>筛出<span
class="math inline">\(8\)</span>，<span
class="math inline">\(i=5\)</span>筛出<span
class="math inline">\(10,15,25\)</span>，<span
class="math inline">\(i=6\)</span>筛出<span
class="math inline">\(12\)</span></p>
<p>显然每个被<span
class="math inline">\(i\)</span>筛出的数的最小质因子都是<span
class="math inline">\(i\)</span></p>
<p>枚举约数的办法：</p>
<ul>
<li>1.试除法：枚举<span class="math inline">\(1\)</span>到<span
class="math inline">\(\sqrt n\)</span></li>
<li>2.筛法：预处理，枚举<span class="math inline">\(1\)</span>到<span
class="math inline">\(n\)</span>的数，再枚举其倍数，则这个数是倍数的约数，可以用<span
class="math inline">\(vector\)</span>存起来，由调和级数可知复杂度为<span
class="math inline">\(O(n*ln_n)\)</span></li>
</ul>
<h3 id="公约数与公倍数">公约数与公倍数</h3>
<p>设<span class="math inline">\(A=p^{a_1}_1p^{a_2}_2...p^{a_n}_n,B =
p^{b_1}_1p^{b_2}_2...p^{b_n}_n\)</span></p>
<p>因此：</p>
<p><span class="math inline">\(gcd(A,B) =
p^{min(a_1,b_1)}_1p^{min(a_2,b_2)}_2...p^{min(a_n,b_n)}_n\)</span></p>
<p>$ lcm(A, B) =
p^{max(a_1,b_1)}_1p^{max(a_2,b_2)}_2...p^{max(a_n,b_n)}_n$</p>
<p><span class="math inline">\(gcd(A,B)*lcm(A,B) = A*B\)</span></p>
<details>
<summary>
GCD
</summary>
<pre><code>inline int gcd(int a, int b)&#123;return !b?a:gcd(b,a%b);&#125;
</code></pre>
</details>
<p>下面是一些例题：</p>
<h3 id="核聚变反应程度">核聚变反应程度</h3>
<p><a href="http://uoj.ac/problem/48">click</a></p>
<p>巧题，次大公约数一定是最大公约数除掉最小的质因数</p>
<p>甩一个<a
href="https://www.cnblogs.com/Memory-of-winter/p/9803373.html">题解</a></p>
<p>给出AC代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, len, a[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;<span class="keyword">return</span> !b?a:<span class="built_in">gcd</span>(b,a%b);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">scanf</span> (<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span> (<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">   <span class="type">int</span> now = a[<span class="number">1</span>];</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= now; ++ i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (now%i == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">while</span> (now%i == <span class="number">0</span>) now /= i;</span><br><span class="line">	 q.<span class="built_in">push_back</span>(i);</span><br><span class="line">         ++ len;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (now &gt; <span class="number">1</span>) q.<span class="built_in">push_back</span>(now), ++ len;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">      <span class="type">int</span> tmp = <span class="built_in">gcd</span>(a[<span class="number">1</span>], a[i]);</span><br><span class="line">      <span class="keyword">if</span> (tmp == <span class="number">1</span>) <span class="built_in">printf</span> (<span class="string">&quot;-1 &quot;</span>);</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++ i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp%q[i] == <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="built_in">printf</span> (<span class="string">&quot;%lld &quot;</span>, tmp/q[i]);</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="divisors">Divisors</h3>
<p><a href="https://darkbzoj.tk/problem/4146">click</a></p>
<p>开桶记录每个数字出现多少次</p>
<p>其中<span class="math inline">\((1,4)(4,1)\)</span>算两次</p>
<p>给出AC代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e6</span>+<span class="number">250</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, res, maxn;</span><br><span class="line"><span class="type">int</span> a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">      <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">      ++ b[a[i]];</span><br><span class="line">      maxn = <span class="built_in">max</span>(a[i], maxn);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= maxn; ++ i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (b[i]) &#123;</span><br><span class="line">         res += b[i]*(b[i]<span class="number">-1</span>);</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> j = i&lt;&lt;<span class="number">1</span>; j &lt;= maxn; j += i)</span><br><span class="line">            <span class="keyword">if</span> (b[j])</span><br><span class="line">            res += b[i]*b[j];</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   cout &lt;&lt; res;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="扩展欧几里得">扩展欧几里得</h3>
<p>是求方程<span
class="math inline">\(𝑎𝑥+𝑏𝑦=gcd(𝑎,𝑏)\)</span>的一组整数解的一种算法</p>
<p>对于一个方程：<span
class="math inline">\(a*x+b*y=gcd(a,b)\)</span>，我们有如下推导</p>
<p>设有式子<span class="math inline">\(a*x_1+b*y_1=gcd(a,b)\)</span></p>
<p>根据欧几里得算法可得：<span
class="math inline">\(b*x_2+(a\%b)*y_2=gcd(b,a\%b)\)</span></p>
<p>观察<span
class="math inline">\(b*x_2+(a\%b)*y_2\)</span>，这个式子,我们可以将<span
class="math inline">\((a\%b)\)</span>写作<span
class="math inline">\((a-\lfloor\frac{a}{b}\rfloor*b)\)</span></p>
<p>将括号打开常数<span
class="math inline">\(a,b\)</span>合并,合并之后的结果为 <span
class="math inline">\(a*y_2+b*(x_2-\lfloor\frac{a}{b}\rfloor*y_2)\)</span></p>
<p>由于欧几里得算法的原理<span
class="math inline">\(gcd(a,b)==gcd(b,a\%b)\)</span></p>
<p>我们将两式子联立,对比系数即可得到<span
class="math inline">\(x_1=y_2,y_1=x_2-\lfloor\frac{a}{b}\rfloor*y_2\)</span></p>
<p>附通解的求法：设得到的特殊解为<span class="math inline">\(x = x_0, y
= y_0\)</span></p>
<p>则通解为<span class="math inline">\(x = x_0+\dfrac {b} {gcd(a,b)}*t,
y = y_0 - \dfrac{a}{gcd(a, b)}*t\)</span>，其中<span
class="math inline">\(t\)</span>为正整数</p>
<p>考虑证明。</p>
<p>给出代码：</p>
<details>
<summary>
EXgcd
</summary>
<pre><code>inline void calc (int a, int b, int &x, int &y) &#123;
   if (!b) x = 1, y = 666;
   else calc (b, a%b, y, x), y -= a/b*x;
&#125;
</code></pre>
</details>
<h3 id="同余方程">同余方程</h3>
<p><a href="https://www.luogu.com.cn/problem/P1082">click</a></p>
<p>原式子<span class="math inline">\(ax \equiv 1 \pmod
b\Longleftrightarrow ax+by=1\)</span></p>
<p>题目保证有解，根据裴蜀定理可以知道<span
class="math inline">\(gcd(a,b) =1\)</span>，直接用<span
class="math inline">\(EXgcd\)</span>就可以</p>
<p>给出AC代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a, b, x, y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">calc</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (!b) x = <span class="number">1</span>, y = <span class="number">666</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="built_in">calc</span> (b, a%b, y, x); y -= a/b*x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">main</span> () &#123;</span><br><span class="line">   cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">   <span class="built_in">calc</span> (a, b, x, y);</span><br><span class="line">   x = (x%b+b)%b;</span><br><span class="line">   cout &lt;&lt; x;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1121324517 2000000000</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><strong>PS</strong>:y尽量从0开始，因为从0开始的话不容易爆<span
class="math inline">\(int\)</span></p>
<h3 id="乘法逆元">乘法逆元</h3>
<p><a href="https://www.luogu.com.cn/problem/P3811">click</a></p>
<p>若<span class="math inline">\(a*x\equiv 1 (mod\;b )\)</span>
并且<span class="math inline">\(a ,b\)</span> 互质.我们就称<span
class="math inline">\(x\)</span> 为 <span
class="math inline">\(a\)</span> 在<span class="math inline">\(mod
\;b\)</span>意义下的乘法逆元,记为<span
class="math inline">\(a^{-1}\)</span></p>
<p>求逆元的<a
href="https://www.cnblogs.com/zjp-shadow/p/7773566.html">click</a></p>
<ul>
<li>1.扩展欧几里得</li>
<li>2.费马小定理</li>
<li>3.线性求逆元</li>
</ul>
<h3 id="仪仗队">仪仗队</h3>
<p>把左下角看作$(0,0) <span
class="math inline">\(，右上角看作\)</span>(n-1,n-1)$
，那么能看到当且仅当横纵坐标互质</p>
<p>然后我们手动盖住上半部分，但是得漏出对角线，答案就是<span
class="math inline">\(1 +
\sum_\limits{i=1}^{n-1}\phi(i)\)</span>，又因为上半部分对称相等，所以重复算了<span
class="math inline">\(1\)</span>，因此要减去<span
class="math inline">\(1\)</span>,又因为左右两边的<span
class="math inline">\(2\)</span>没有算，因此要加2</p>
<p>所以总答案为：<span
class="math inline">\(2*\sum_\limits{i=1}^{n-1}\phi(i) + 1\)</span></p>
<h3 id="沙拉公主的困惑">沙拉公主的困惑</h3>
<p><a href="https://www.luogu.com.cn/problem/P2155">click</a></p>
<p>由于<span class="math inline">\(N!\)</span> 是<span
class="math inline">\(M!\)</span> 的倍数，而若<span
class="math inline">\(a\)</span> 与<span
class="math inline">\(b\)</span> 互质则<span
class="math inline">\(a+b\)</span> 与<span
class="math inline">\(b\)</span> 互质，故<span
class="math inline">\(N!\)</span> 中每$M! <span
class="math inline">\(个便有\)</span>φ(M!)$ 个与$M! $互质</p>
<p>然后答案呼之欲出：</p>
<p><span class="math inline">\(\dfrac {N!} {M!}* \phi(M!) = \dfrac {N!}
{M!}*M!*\sum_\limits {p_i \mid M!} \dfrac {p_i-1} {p_i} =
N!*\sum_\limits{p_i&lt;=M} \dfrac{p_i-1}{p_i}\)</span></p>
<p>然后手玩逆元</p>
<h3 id="欧拉定理">欧拉定理</h3>
<p><img
src="https://pic.imgdb.cn/item/6327e17716f2c2beb13ad09b.png" /></p>
<h3 id="longge问题">Longge问题</h3>
<p><a href="https://www.luogu.com.cn/problem/P2303">click</a></p>
<p>枚举最大公约数为d ，则数目就是<span class="math inline">\(\dfrac N
d\)</span> ，答案为<span class="math inline">\(\sum_\limits{d\mid
N}d*\phi(\dfrac N d)\)</span></p>
<p>因此枚举约数再求欧拉，时间复杂度大概是O(算不出来但是能过)</p>
<p>复杂度<span class="math inline">\(O(玄)\)</span></p>
<p>(我不会…..)</p>
<p>接下来是矩阵乘法</p>
<h3 id="斐波那契数列">斐波那契数列</h3>
<p><a href="https://www.luogu.com.cn/problem/P1962">click</a></p>
<p><img
src="https://img2020.cnblogs.com/blog/1307264/202008/1307264-20200806091125728-841762534.png" /></p>
<p>主要是我不会打矩形....</p>
<h3 id="路径计数">路径计数</h3>
<p>矩阵的<span class="math inline">\(k\)</span>次方就是答案</p>
<h1 id="晚上">晚上</h1>
<p>写博客补坑</p>
]]></content>
      <categories>
        <category>暑假日常</category>
      </categories>
      <tags>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title>8.07集训</title>
    <url>/2020/08/07/8.7%E9%9B%86%E8%AE%AD/</url>
    <content><![CDATA[<h1 id="上午">上午</h1>
<p>考试 <span id="more"></span> ### 第一题</p>
<p><span class="math inline">\(T\)</span>次询问，每次询问给定<span
class="math inline">\(n\)</span>，求 <span
class="math inline">\(\sum_\limits{i=1}^n \lfloor \dfrac n i
\rfloor\)</span></p>
<p>上来看到<span
class="math inline">\(2s\;1GB\)</span>，直接准备打表…..</p>
<p>于是我开始手算…..</p>
<p><span class="math inline">\(n =
1get1,n=2get3,n=3get5,n=4get8,n=5get10,n=6get14,n=7get16,\)</span></p>
<p><span class="math inline">\(n=8get20,n=9get23\)</span></p>
<p>我注意到，<span
class="math inline">\(n\)</span>为奇数的时候，比她小的偶数的<span
class="math inline">\(ans_{i-1}\)</span>就为<span
class="math inline">\(ans_i-2\)</span></p>
<p>于是我开始验证，嗯，<span
class="math inline">\(2,3\)</span>满足，<span
class="math inline">\(4,5\)</span>满足，<span
class="math inline">\(6,7\)</span>满足，我没有验证<span
class="math inline">\(8,9\)</span>！</p>
<p>可偏偏<span
class="math inline">\(8,9\)</span>就没有满足这个规律！</p>
<p>于是在我自以为正确的规律下，开始计算打表时间，计算最多可以达到多少</p>
<p><span class="math inline">\(1e7*1e7/1e9\)</span>需要三个多小时</p>
<p><span class="math inline">\(1e6*1e6/1e9\)</span>需要四分钟</p>
<p>但是<span
class="math inline">\(1e7\)</span>太诱人了，满分太诱人了，我又考虑各种优化打表程序</p>
<p>直到最后放弃打表<span
class="math inline">\(1e7\)</span>，但是为了<span
class="math inline">\(1e6\)</span>的打表程序，我还搞了搞常数优化</p>
<p><span class="math inline">\(45mins \;later\)</span></p>
<p>我注意到<span class="math inline">\(n
=8get20\)</span>，我仍旧以为是我手算错了，还在草稿纸上，用红笔改为了<span
class="math inline">\(21\)</span></p>
<p>交上去之后，首先是找不到源程序，搞得我一头雾水，后来把源程序的内存限制改为了<span
class="math inline">\(10000KB\)</span></p>
<p>（我的程序是<span class="math inline">\(7000多KB\)</span>）</p>
<p>我的代码能编译了，结果一片红，那一刻，我心里是真的凉</p>
<hr />
<p>整除分块只有四十分</p>
<p>考虑<span class="math inline">\(\lfloor \dfrac
ni\rfloor\)</span>的含义：<span
class="math inline">\(1\text~N\)</span>中<span
class="math inline">\(i\)</span>的倍数的数目</p>
<p>那么所求的就是<span
class="math inline">\(1\text~N\)</span>中所有数的倍数的数目，反过来就是<span
class="math inline">\(1\text~N\)</span>所有数的约数的数目</p>
<p>所求转化为<span
class="math inline">\(\sum_\limits{i=1}^nd(i)\)</span>，其中<span
class="math inline">\(d(i)\)</span>是<span
class="math inline">\(i\)</span>的约数的个数</p>
<p>线性筛可以满分</p>
<p>关于线性筛约数，我还不会，甩个链接<a
href="https://blog.csdn.net/ControlBear/article/details/77527115">click1</a><a
href="https://www2014.aspxhtml.com/post-8185">click2</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Tn = <span class="number">4e7</span>+<span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> N, T, p, cnt;</span><br><span class="line"><span class="type">int</span> res, last = <span class="number">-2</span>;</span><br><span class="line"><span class="type">int</span> a[Tn], v[Tn], f[Tn];</span><br><span class="line">LL sum[Tn]; <span class="type">int</span> prime[Tn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">scanf</span> (<span class="string">&quot;%d%d%d&quot;</span>, &amp;N, &amp;T, &amp;p);</span><br><span class="line">   f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= N; ++ i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!v[i]) &#123;</span><br><span class="line">         a[i] = <span class="number">1</span>;</span><br><span class="line">         f[i] = <span class="number">2</span>;</span><br><span class="line">         prime[++ cnt] = i;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= N; ++ j) &#123;</span><br><span class="line">         <span class="type">int</span> now = i * prime[j];</span><br><span class="line">         v[now] = <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) &#123;</span><br><span class="line">            a[now] = a[i] + <span class="number">1</span>;</span><br><span class="line">            f[now] = f[i]/(a[i]+<span class="number">1</span>)*(a[i]+<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         &#125; <span class="keyword">else</span> a[now] = <span class="number">1</span>, f[now] = f[i]*<span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++ i) sum[i] = sum[i - <span class="number">1</span>] + f[i];</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= T; ++ i) res ^= (last = sum[(last+i+p)%N+<span class="number">1</span>]);</span><br><span class="line">   cout &lt;&lt; res;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第二题">第二题</h3>
<p>一句话题意：小伙子和小姑娘玩一个游戏：在一个装有<span
class="math inline">\(w\)</span>个白球，<span
class="math inline">\(b\)</span>个黑球的袋子里，轮流摸球，摸到一个就扔一个，谁先拿到白球谁赢。小伙子为了赢，于是作弊：自己拿完球之后，如果袋子里面还有球，他就再拿一个扔掉，无论这个是白球或者黑球，他第二次摸的这个不计输赢</p>
<p>算小姑娘赢的概率</p>
<p>（概率dp）</p>
<p>设<span class="math inline">\(f[i][j]\)</span>表示袋子里还有<span
class="math inline">\(i\)</span>个白球和<span
class="math inline">\(j\)</span>个黑球时，Alice获胜的概率</p>
<p>则Alice获胜有三种情况：</p>
<ul>
<li>1.小姑娘直接摸出白球，概率<span class="math inline">\(\dfrac i
{i+j}\)</span></li>
<li>2.小姑娘运气不好，摸到了黑球，小伙子摸出了黑球，扔了一个白球</li>
<li>这时候概率显然：<span class="math inline">\(\dfrac i {i+j} \times
\dfrac{j - 1} {i+j-1} \times\dfrac i {i+j-2} \times
f[i-1][j-2]\)</span></li>
<li>3.小姑娘还是摸出黑球，小伙子摸出了一个黑球，扔掉了一个黑球</li>
<li>这时候概率显然：<span class="math inline">\(\dfrac i {i+j}\times
\dfrac {j-1}{i+j-1} \times \dfrac {j-2}{i+j-2} \times
f[i][j-3]\)</span></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span>+<span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> w, b;</span><br><span class="line"><span class="type">double</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">scanf</span> (<span class="string">&quot;%d%d&quot;</span>, &amp;w, &amp;b);</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= w; ++ i) f[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= b; ++ i) f[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= w; ++ i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= b; ++ j) &#123;</span><br><span class="line">         f[i][j] += (<span class="type">double</span>)i/(i + j);</span><br><span class="line">         <span class="keyword">if</span> (j &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            f[i][j] += f[i - <span class="number">1</span>][j - <span class="number">2</span>]*j/(i + j)*(j - <span class="number">1</span>)/(i + j - <span class="number">1</span>)*i/(i + j - <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">2</span>) f[i][j] += f[i][j - <span class="number">3</span>]*j/(i + j)*(j - <span class="number">1</span>)/(i + j - <span class="number">1</span>)*(j - <span class="number">2</span>)/(i + j <span class="number">-2</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span> (<span class="string">&quot;%.10lf\n&quot;</span>, f[w][b]);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第三题">第三题</h3>
<p>一句话题意：有<span class="math inline">\(n\)</span>个人要参观<span
class="math inline">\(m\)</span>个村庄，一开始每一个村庄都没有人，<strong>当一个人进入之后</strong>，会产生一个惊叹值，大小等于此人进去之后，该村庄的总人数</p>
<p>现在有<span
class="math inline">\(k\)</span>次清空村庄的机会，清空操作只能在一个人进入村庄并且产生惊叹值之后进行，求最小的惊叹值总和</p>
<p><strong>数据范围与提示</strong>：</p>
<p>对于<span class="math inline">\(40\%\)</span>的数据：<span
class="math inline">\(m = 1\)</span></p>
<p>对于<span class="math inline">\(60\%\)</span>的数据：<span
class="math inline">\(n\leq 1000\)</span></p>
<p>对于<span class="math inline">\(80\%\)</span>的数据：<span
class="math inline">\(n \leq 50000\)</span></p>
<p>对于<span class="math inline">\(100\%\)</span>的数据：<span
class="math inline">\(1\leq n \leq 1e6, 1 \leq m \leq 100, 1 \leq k \leq
500\)</span></p>
<p>我觉得是一个很好的题，数据给出<span class="math inline">\(m
=1\)</span>，部分<span
class="math inline">\(pts\)</span>的做法，可以很好的引申到正解</p>
<p>当<span
class="math inline">\(m=1\)</span>我们显然要将机会平均分配</p>
<p>设<span class="math inline">\(calc(n,x)\)</span>表示一个村庄内<span
class="math inline">\(n\)</span>个人平均分成<span
class="math inline">\(x\)</span>段的最小惊叹值（用<span
class="math inline">\(k\)</span>次机会，会将村庄分成<span
class="math inline">\(k+1\)</span>段）</p>
<p>那么我们可以<span class="math inline">\(O(1)\)</span>求出<span
class="math inline">\(calc(n,x) = (n\%x)\times sum(\lfloor\dfrac nx
\rfloor+1) + (x-n\%x)\times sum(\lfloor\dfrac nx \rfloor)\)</span></p>
<p>其中<span class="math inline">\(sum[x]=\dfrac {x(x+1)}
x\)</span>。比较科学的解释是：从<span
class="math inline">\(1\)</span>加到<span
class="math inline">\(x\)</span>，每一个数的和</p>
<p>当<span class="math inline">\(m \neq
1\)</span>的时候，显然要用分组背包啊</p>
<p>设<span class="math inline">\(f[i][j]\)</span>表示前<span
class="math inline">\(i\)</span>个村庄使用<span
class="math inline">\(j\)</span>次机会的最小惊叹值</p>
<p>则有<span class="math inline">\(f[i][j]=Min(f[i][j],
f[i-1][t]+calc(cnt[i],j-t+1))\)</span></p>
<p>其中<span class="math inline">\(cnt[i]\)</span>是桶，答案就是：<span
class="math inline">\(f[m][k]\)</span></p>
<p>时间复杂度：<span class="math inline">\(O(n+m\times k^2)\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"><span class="type">int</span> tong[N];</span><br><span class="line"><span class="type">int</span> f[<span class="number">110</span>][<span class="number">600</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x*(x+<span class="number">1</span>)/<span class="number">2</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;<span class="keyword">return</span> (x%y)*<span class="built_in">sum</span>(x/y+<span class="number">1</span>) + (y-x%y)*<span class="built_in">sum</span>(x/y);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">      <span class="type">int</span> x;</span><br><span class="line">      <span class="built_in">scanf</span> (<span class="string">&quot;%lld&quot;</span>, &amp;x);</span><br><span class="line">      ++ tong[x];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">   f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= k; ++ j) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> z = <span class="number">0</span>; z &lt;= j; ++ z) &#123;</span><br><span class="line">            f[i][j] = <span class="built_in">min</span>(f[i][j], f[i - <span class="number">1</span>][z]+<span class="built_in">calc</span>(tong[i], j - z + <span class="number">1</span>));</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   cout &lt;&lt; f[m][k];</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
<h1 id="下午">下午</h1>
<p>讲课，主要讲的数据结构</p>
<h1 id="晚上">晚上</h1>
<p>做题，上例题</p>
<h3 id="疯狂的馒头">疯狂的馒头</h3>
<p><a href="https://darkbzoj.tk/problem/2054">click</a></p>
<p>一句话题意：给你一些区间，让你在一些区间染色，输出最后的染色结果，数据量<span
class="math inline">\(1e6\)</span></p>
<p>正着来貌似不太容易，我们尝试想做概率dp一样，反着搞</p>
<p>因为倒着搞的话，每个颜色就固定了，不会再被更新，这样一个位置最多只需要染一次，染过就不需要再染</p>
<p>并查集的一个经典神助攻：<strong>删除一个数后快速找到它后面第一个没有删除的数（处理完一个位置后快速找打它后面第一个需要处理的位置）</strong>用并查集维护这个点往后最近的白色馒头是谁，然后时光倒流，直接往它的fa处跳就行了</p>
<p>这样就能保证每个位置只被染一次，时间复杂度<span
class="math inline">\(O(n+m)\)</span></p>
<p><strong>这个神助攻经常被用来“每个位置最多只会被处理一次”和“标记”和“快速找到最近的满足条件的位置”，常和离线、预处理、“正难则反”等结合，非常腻害</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="comment">// #define debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> T = <span class="number">1e7</span>+<span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> N, M, p, q;</span><br><span class="line"><span class="type">int</span> a[T], fa[T];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">return</span> tmp = fa[x]==x?fa[x]=x:fa[x]=<span class="built_in">Find</span>(fa[x]);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   cin &gt;&gt; N &gt;&gt; M &gt;&gt; p &gt;&gt; q;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N + <span class="number">1</span>; ++ i) fa[i] = i;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = M; i; -- i)&#123;</span><br><span class="line">      <span class="type">int</span> l = ((LL)i * p + q)%N+<span class="number">1</span>;</span><br><span class="line">      <span class="type">int</span> r = ((LL)i * q + p)%N+<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (l &gt; r) <span class="built_in">swap</span>(l, r);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="built_in">Find</span>(l); j &lt;= r; j = <span class="built_in">Find</span>(j))&#123;</span><br><span class="line">         a[j] = i, fa[j] = <span class="built_in">Find</span>(j+<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++ i) cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="区改区查">区改区查</h3>
<p><a href="https://loj.ac/problem/132">click</a></p>
<p>具体分析详见<a
href="https://www.cnblogs.com/yszhyhm/p/13395418.html">7.29</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x&amp;-x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>+<span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, q;</span><br><span class="line"><span class="type">int</span> sum1[N], sum2[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">jia</span> <span class="params">(<span class="type">int</span> x, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt;= n; i += <span class="built_in">lowbit</span>(i))</span><br><span class="line">      sum1[i] += val, sum2[i] += val*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">qujianjia</span> <span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> val)</span> </span>&#123;<span class="built_in">jia</span>(l, val), <span class="built_in">jia</span>(r+<span class="number">1</span>, -val);&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">chaxun</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="type">int</span> <span class="title">res</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = x; i; i -= <span class="built_in">lowbit</span>(i))</span><br><span class="line">      res += (x + <span class="number">1</span>)*sum1[i] - sum2[i];</span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">qujianchaxun</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">chaxun</span>(r) - <span class="built_in">chaxun</span>(l<span class="number">-1</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">scanf</span> (<span class="string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;q);</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">      <span class="type">int</span> x;</span><br><span class="line">      <span class="built_in">scanf</span> (<span class="string">&quot;%lld&quot;</span>, &amp;x);</span><br><span class="line">      <span class="built_in">qujianjia</span>(i, i , x);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; ++ i) &#123;</span><br><span class="line">      <span class="type">int</span> opt, l, r, x;</span><br><span class="line">      <span class="built_in">scanf</span> (<span class="string">&quot;%lld&quot;</span>, &amp;opt);</span><br><span class="line">      <span class="keyword">if</span> (opt&amp;<span class="number">1</span>) &#123;</span><br><span class="line">         <span class="built_in">scanf</span> (<span class="string">&quot;%lld%lld%lld&quot;</span>, &amp;l, &amp;r, &amp;x);</span><br><span class="line">         <span class="built_in">qujianjia</span>(l, r, x);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="built_in">scanf</span> (<span class="string">&quot;%lld%lld&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">         cout &lt;&lt; <span class="built_in">qujianchaxun</span>(l, r) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>暑假日常</category>
      </categories>
      <tags>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title>8.08集训</title>
    <url>/2020/08/08/8.8%E9%9B%86%E8%AE%AD/</url>
    <content><![CDATA[<h1 id="上午">上午</h1>
<p>考试 <span id="more"></span></p>
<h1 id="下午">下午</h1>
<p>讲图论，改题</p>
<h3 id="第一题">第一题</h3>
<p>给定一个长度为<span
class="math inline">\(n\)</span>的序列，求这个序列所有长度为<span
class="math inline">\(k\)</span>的子序列的最大值之和，答案对<span
class="math inline">\(1e9+7\)</span>取模</p>
<p>显然，观察题面发现是“子序列”，也就是可以不连续</p>
<p>所以我们首先排序，然后考虑<span
class="math inline">\(a[i]\)</span>对于答案造成的贡献，发现以<span
class="math inline">\(a[i]\)</span>为最大值的序列，<span
class="math inline">\(i-1\)</span>之前的东东他都可以造成贡献，变相的说，是在前<span
class="math inline">\(i-1\)</span>个数里面，选<span
class="math inline">\(k-1\)</span>个，然后这么多次方案，<span
class="math inline">\(a[i]\)</span>对于每个方案都有贡献，</p>
<p>于是答案呼之欲出啊：<span class="math inline">\(Ans = \sum_\limits {i
= k} ^nC_{i-1}^{k-1}\times
a[i]\)</span>，可惜在考场上没想出来，一直在想数据结构单调栈之类的去维护他，最后没办法，打了二十分暴力走人</p>
<p><strong>PS</strong>:估计只有我不太清楚<span
class="math inline">\(C_n^m = C_{n-1}^{m} + C_{n-1}^{m-1}\)</span>吧</p>
<p><strong>小贴士</strong>:搞不清楚组合数的规律的时候，试试杨辉三角？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">66</span>, mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line">LL c[N][<span class="number">66</span>], res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">   <span class="built_in">sort</span> (a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i) c[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; k; ++ j) &#123;</span><br><span class="line">         c[i][j] = (c[i - <span class="number">1</span>][j] + c[i - <span class="number">1</span>][j - <span class="number">1</span>])%mod;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = k; i &lt;= n; ++ i) res = (res + c[i - <span class="number">1</span>][k - <span class="number">1</span>]*a[i])%mod;</span><br><span class="line">   cout &lt;&lt; res;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第二题">第二题</h3>
<p>题目大意：在一个有<span
class="math inline">\(n\)</span>个站点的路上，对于<span
class="math inline">\(1\leq i &lt; n\)</span>，站点<span
class="math inline">\(i\)</span>可以一票到达站点<span
class="math inline">\(i+1,i+2, i+3......Min(i+a_i, n)\)</span></p>
<p>求任意两点<span class="math inline">\(i,j\)</span>从<span
class="math inline">\(i\text~j\)</span>的最少票数和，即求<span
class="math inline">\(\sum_\limits{i=1}^{n-1}\sum_\limits{j=i}^{n}
p(i,j)\)</span>其中<span class="math inline">\(p(i,j)\)</span>表示<span
class="math inline">\(i\text~j\)</span>的最少票数</p>
<p>状态：设<span class="math inline">\(f[i]\)</span>表示<span
class="math inline">\(\sum_\limits{j = i+1}^np(i,j)\)</span>，即<span
class="math inline">\(i\text~j\)</span>的最少票数和，</p>
<p>转移：</p>
<ul>
<li>对于<span
class="math inline">\((i,i+a_i\rbrack\)</span>，我们可以一票卖完</li>
<li>对于<span
class="math inline">\((i+a_i,n\rbrack\)</span>，选择一个合适的<span
class="math inline">\(j\)</span>作为跳板，跳到终点，显然选择一个<span
class="math inline">\({j+a[j]}_{max}\)</span>是最合适不过的了</li>
<li>故当<span class="math inline">\(i+a_i=n\)</span>时，<span
class="math inline">\(f[i] = n-i\)</span>，表示<span
class="math inline">\(i+1 \text~n\)</span>都可以一票走</li>
<li>而当<span
class="math inline">\(i+a_i&lt;n\)</span>时，用树状数组或线段树查询<span
class="math inline">\((i,i+a_i \rbrack\)</span>中，<span
class="math inline">\(j+a_i\)</span>最大的<span
class="math inline">\(j\)</span></li>
<li>转移呼之欲出：<span class="math inline">\(f[i] = a_i+f[j]-(a_i
-j)+(n-a_i)\)</span></li>
</ul>
<p><strong>PS</strong></p>
<p><span class="math inline">\(a[i] = min(a[i]+i, n)\)</span></p>
<p><span class="math inline">\(f[i] = a[i] - i\)</span></p>
<p>结果：<span class="math inline">\(Ans =
\sum_\limits{i=1}^{n-1}f[i]\)</span></p>
<p>给出AC代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x&amp;-x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, a[N], mp[N], t;</span><br><span class="line">LL f[N], res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">chenge</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt;= n; i += <span class="built_in">lowbit</span>(i)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[mp[i]] &lt; a[x]) &#123;</span><br><span class="line">         mp[i] = x;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="type">int</span> <span class="title">yhm</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = x; i; i -= <span class="built_in">lowbit</span>(i)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[yhm] &lt; a[mp[i]]) &#123;</span><br><span class="line">         yhm = mp[i];</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> yhm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n<span class="number">-1</span>; ++ i) &#123;</span><br><span class="line">      <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">      a[i] = <span class="built_in">min</span> (a[i]+i, n);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = n<span class="number">-1</span>; i; -- i) &#123;</span><br><span class="line">      f[i] = a[i] - i;</span><br><span class="line">      <span class="keyword">if</span> (a[i] &lt; n) t = <span class="built_in">ask</span>(a[i]), f[i] += f[t] - (a[i] - t) + (n - a[i]);</span><br><span class="line">      <span class="built_in">chenge</span>(i);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) res += f[i];</span><br><span class="line">   cout &lt;&lt; res;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第三题">第三题</h3>
<p>没时间了，贴上题解与代码吧</p>
<p>一句话题意：给定一个<span
class="math inline">\(1\text~n\)</span>的序列，<span
class="math inline">\(m\)</span>次询问，每次询问<span
class="math inline">\(\lfloor l_i, r_i
\rfloor\)</span>中选出两个不同的数所得的<span
class="math inline">\(gcd\)</span>的最大值</p>
<p>其中<span class="math inline">\(1 \leq n,m \leq 1e5\)</span></p>
<p><img
src="https://pic.imgdb.cn/item/6327df9716f2c2beb138de8a.png" /></p>
<p>给出代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">66</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;lv[N], lp[N];</span><br><span class="line"><span class="type">int</span> n, m, <span class="built_in">p</span>(<span class="number">1</span>), tot;</span><br><span class="line"><span class="type">int</span> a[N], d[N], f[N];</span><br><span class="line"><span class="type">int</span> pos[N], ans[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">   <span class="type">int</span> l, r, id;</span><br><span class="line">   <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;a) <span class="type">const</span> &#123;<span class="keyword">return</span> r &lt; a.r;&#125;</span><br><span class="line">&#125;q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = x; i; i -= (i&amp;-i))</span><br><span class="line">      f[i] = <span class="built_in">max</span>(f[i], val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">chaxun</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="type">int</span> <span class="title">res</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt;= n; i += (i&amp;-x)) </span><br><span class="line">      res = <span class="built_in">max</span>(res, f[i]);</span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">      cin &gt;&gt; a[i];</span><br><span class="line">      pos[a[i]] = i;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">      cin &gt;&gt; q[i].l &gt;&gt; q[i].r;</span><br><span class="line">      q[i].id = i;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">tot</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= n; j += i) d[++ tot] = pos[j];</span><br><span class="line">      <span class="built_in">sort</span>(d + <span class="number">1</span>, d + tot + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j &lt;= tot; ++ j) &#123;</span><br><span class="line">         lp[d[j]].<span class="built_in">push_back</span>(d[j - <span class="number">1</span>]);</span><br><span class="line">         lv[d[j]].<span class="built_in">push_back</span>(i);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">sort</span>(q + <span class="number">1</span>, q + m + <span class="number">1</span>);</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (<span class="type">int</span>)lp[i].<span class="built_in">size</span>(); ++ j) <span class="built_in">add</span>(lp[i][j], lv[i][j]);</span><br><span class="line">      <span class="keyword">while</span> (p &lt;= m &amp;&amp; q[p].r &lt;= i) &#123;</span><br><span class="line">         ans[q[p].id] = <span class="built_in">chaxun</span>(q[p].l);</span><br><span class="line">         ++ p;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
<h1 id="晚上">晚上</h1>
<p>做例题呗.....，还有<a
href="https://www.luogu.com.cn/problem/P3388">一道题</a>没有D出来</p>
<p>一个黄题这么操蛋.....</p>
<h3 id="明星牛">明星牛</h3>
<p><a href="https://www.luogu.com.cn/problem/P2341">click</a></p>
<p>近乎板子题，缩点之后，找出度为零的点<span
class="math inline">\(x\)</span>，答案就是<span
class="math inline">\(x\)</span>的<span
class="math inline">\(size\)</span></p>
<p><strong>PS</strong>：如果发现出度为零的<span
class="math inline">\(x\)</span>不止一个，那么<span
class="math inline">\(res = 0\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, res;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;<span class="type">int</span> to, nxt;&#125;e[N]; <span class="type">int</span> head[N], num;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">   ++ num;</span><br><span class="line">   e[num].to = v, e[num].nxt = head[u];</span><br><span class="line">   head[u] = num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;scc[N];</span><br><span class="line"><span class="type">int</span> tp, tot, cnt;</span><br><span class="line"><span class="type">int</span> dfn[N], low[N], sta[N], in[N], tar[N], d[N];</span><br><span class="line"><span class="comment">//tar[i] has showed the i belong which SCC</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">tarjan</span> <span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">   dfn[x] = low[x] = ++ tot; in[x] = <span class="number">1</span>, sta[++ tp] = x;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = e[i].nxt) &#123;</span><br><span class="line">      <span class="type">int</span> y = e[i].to;</span><br><span class="line">      <span class="keyword">if</span> (!dfn[y]) &#123;</span><br><span class="line">         <span class="built_in">tarjan</span>(y);</span><br><span class="line">         low[x] = <span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (in[y]) low[x] = <span class="built_in">min</span>(low[x], dfn[y]);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (dfn[x] == low[x]) &#123;</span><br><span class="line">      <span class="type">int</span> y; ++ cnt;</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">         y = sta[tp --]; in[y] = <span class="number">0</span>;</span><br><span class="line">         tar[y] = cnt;</span><br><span class="line">         scc[cnt].<span class="built_in">push_back</span>(y);</span><br><span class="line">      &#125; <span class="keyword">while</span> (x != y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">      <span class="type">int</span> u, v;</span><br><span class="line">      <span class="built_in">scanf</span> (<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">      <span class="built_in">add_edge</span>(u, v);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!dfn[i]) &#123;</span><br><span class="line">         <span class="built_in">tarjan</span>(i);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">1</span>; x &lt;= n; ++ x) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = e[i].nxt) &#123;</span><br><span class="line">         <span class="type">int</span> y = e[i].to;</span><br><span class="line">         <span class="keyword">if</span> (tar[x] == tar[y]) <span class="keyword">continue</span>;</span><br><span class="line">         <span class="keyword">else</span> d[tar[x]] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++ i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!d[i]) &#123;</span><br><span class="line">         <span class="keyword">if</span> (res) &#123;res = <span class="number">0</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">         res = scc[i].<span class="built_in">size</span>();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   cout &lt;&lt; res;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//the topic aim:find all the T.size(), and the T = (&quot;chudu&quot; == 0)</span></span><br><span class="line"><span class="comment">//how can I do?</span></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="佳肴">佳肴</h3>
<p><a href="https://www.luogu.com.cn/problem/P3243">click</a></p>
<p>这个题是一个拓扑排序，我们只需要把图倒着连一遍，然后跑一遍最大拓扑排序即可，把序列倒着输出就好了</p>
<p>正常的排序用队列，这里用优先队列</p>
<p>证明：</p>
<p>1 尽量靠前，然后2尽量靠前...
在反图反序列中就相当于1尽量靠后，然后2尽量靠后...这就相当于：能不选1就不选1，然后能不选2就不选2...</p>
<p>等价于：选最大的，然后再选接下来的最大的...</p>
<p><strong>PS</strong>：需要特判两个地方，第一个是是否有入度为零的点，第二个是拓扑排序完成之后，判断点的个数是否等于<span
class="math inline">\(n\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> T, n, m, num, tp, flag;</span><br><span class="line"><span class="type">int</span> a[N], z[N];</span><br><span class="line"><span class="type">int</span> deg[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> to, nxt;&#125;e[N]; <span class="type">int</span> head[N], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">   ++ cnt;</span><br><span class="line">   e[cnt].to = v, e[cnt].nxt = head[u];</span><br><span class="line">   head[u] = cnt; ++ deg[v];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">topsort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   priority_queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!deg[i]) &#123;</span><br><span class="line">         q.<span class="built_in">push</span>(i);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      flag = <span class="number">1</span>;</span><br><span class="line">      <span class="type">int</span> x = q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">      z[++ num] = x;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = e[i].nxt) &#123;</span><br><span class="line">         <span class="type">int</span> y = e[i].to;</span><br><span class="line">         <span class="keyword">if</span> (-- deg[y] == <span class="number">0</span>) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(y);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   cin &gt;&gt; T;</span><br><span class="line">   <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">      flag = <span class="number">0</span>, num = <span class="number">0</span>, tp = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span> a); </span><br><span class="line">      <span class="built_in">memset</span>(z, <span class="number">0</span>, <span class="keyword">sizeof</span> z);</span><br><span class="line">      <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">      <span class="built_in">memset</span>(deg, <span class="number">0</span>, <span class="keyword">sizeof</span> deg);</span><br><span class="line">      <span class="built_in">scanf</span> (<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">         <span class="type">int</span> x, y;</span><br><span class="line">         <span class="built_in">scanf</span> (<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">         <span class="built_in">add_edge</span>(y, x);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">topsort</span>();</span><br><span class="line">      <span class="keyword">if</span> (num == n) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= num; ++ i) a[num-i+<span class="number">1</span>] = z[i];</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= num; ++ i) cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">         <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;Impossible!&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>暑假日常</category>
      </categories>
      <tags>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title>8.09集训</title>
    <url>/2020/08/09/8.9%E9%9B%86%E8%AE%AD/</url>
    <content><![CDATA[<h1 id="上午">上午</h1>
<p>考试，被初中的dalao踩爆了 <span id="more"></span> # 下午</p>
<p>讲课，主要讲的树，树形dp，树剖，dfn序，树的直径，换根dp，树形背包各种树上的操作</p>
<h1 id="晚上">晚上</h1>
<p>听学长的“杂记”</p>
<p>外加改题：</p>
<h3 id="第一题">第一题</h3>
<p>有<span
class="math inline">\(n\)</span>个宽度为1的点，高度分别为<span
class="math inline">\(1\sim
n\)</span>的排列，我们将这些条按照某种排列顺序从左到右连接在一起就形成了一个柱状图</p>
<p><img
src="https://pic.imgdb.cn/item/6327dee116f2c2beb13809fd.png" /></p>
<p>（我也觉得特别丑.....）</p>
<p>当<span class="math inline">\(n\)</span>为8的时候，排列为：<span
class="math inline">\(6,2,3,1,8,4,5,7\)</span>，如上图所示</p>
<p>现给定<span class="math inline">\(n\)</span>与<span
class="math inline">\(x\)</span>，求<span
class="math inline">\(1\text~n\)</span>这个排列是否可以以某种方式排序之后，得到x这个排水量，其中<span
class="math inline">\(1 \leq n \leq 1e6, 1 \leq x \leq 1e15\)</span></p>
<p>知道正解之后感觉就是个普及组的T1，可是当时的我，把问题搞复杂了。。。。</p>
<p>最大情况是<span class="math inline">\(n\)</span>和<span
class="math inline">\(n-1\)</span>在两头的位置，中间排放<span
class="math inline">\(1\sim n - 2\)</span>，此时的答案为<span
class="math inline">\(maxx=1+...+n-2\)</span>，当<span
class="math inline">\(x&gt;maxx\)</span>时显然不行。</p>
<p>而当<span class="math inline">\(x \leq
maxx\)</span>时一定可以，我们强制<span
class="math inline">\(n\)</span>和<span
class="math inline">\(n-1\)</span>是容器的边，就相当于选择<span
class="math inline">\(1\text~n-2\)</span>中的数使得其组成<span
class="math inline">\(x\)</span></p>
<p>可以从大往小选，尽量选大的，选不了直接跳过，显然这种方法是正确的，没选的排序放到容器外面就保证不会积水。时间复杂度为<span
class="math inline">\(O(n)\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>+<span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, cnt;</span><br><span class="line">LL x;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   cin &gt;&gt; n &gt;&gt; x;</span><br><span class="line">   <span class="type">int</span> m = n - <span class="number">2</span>, maxx = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = m; i; -- i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (x &gt;= i) &#123;</span><br><span class="line">         x -= i;</span><br><span class="line">         a[n - <span class="number">1</span> - i] = i;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (x) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">         <span class="keyword">if</span> (!a[i]) cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">      cout &lt;&lt; n &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">         <span class="keyword">if</span> (a[i]) cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">      cout &lt;&lt; n<span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="第二题">第二题</h3>
<p><img
src="https://img2020.cnblogs.com/blog/1307264/202008/1307264-20200809203942478-1576170732.png" /></p>
<p>我懒...</p>
<p>以下是<a
href="https://www.cnblogs.com/oier/">ghj1222</a>dalao的讲解:(让我们来一起%%%ghj1222)</p>
<p>考虑到N很小，限制答案的值只有两点之间的曼哈顿距离，题目可以转化为：</p>
<p>给定一个N个点的完全图（无向图）（边权为原格点图的曼哈顿距离）</p>
<p>你要满足尽量大的边，使得这个边所连接的两个点分属不同的集合、</p>
<p>你就从大往小贪心，尽量满足大的边，用一个带权并查集维护一个连通块内点与点之间必须在同一集合/必须不在同一集合，</p>
<p>直到你扫到一条边，边连接两个点在同一集合且这条边与之前记录信息冲突，这条边就不能删，它的长度就是答案</p>
<p>至于统计方案数，并查集每个连通块中都能分成两个集合，你要把他分成A和B，就有两种情况，最后方案数就是<span
class="math inline">\(2^{连通块个数}\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 5010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> px[N] , py[N] , head[N &lt;&lt; <span class="number">2</span>] , vx[N * N / <span class="number">2</span>] , vy[N * N / <span class="number">2</span>] , nxt[N * N / <span class="number">2</span>] , cnt , f[N] , r[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x , <span class="type">int</span> y , <span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   vx[++cnt] = x , vy[cnt] = y , nxt[cnt] = head[z] , head[z] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(x == f[x]) <span class="keyword">return</span> x;</span><br><span class="line">   <span class="type">int</span> t = f[x];</span><br><span class="line">   f[x] = <span class="built_in">find</span>(t) , r[x] ^= r[t];</span><br><span class="line">   <span class="keyword">return</span> f[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> n , i , j , tx , ty , ans = <span class="number">1</span> , num , tmp;</span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span> , &amp;n) , num = n;</span><br><span class="line">   <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= n ; i ++ )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span> , &amp;px[i] , &amp;py[i]) , f[i] = i , r[i] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(j = <span class="number">1</span> ; j &lt; i ; j ++ )</span><br><span class="line">         <span class="built_in">add</span>(j , i , <span class="built_in">abs</span>(px[i] - px[j]) + <span class="built_in">abs</span>(py[i] - py[j]));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(i = <span class="number">20000</span> ; ~i ; i -- )</span><br><span class="line">   &#123;</span><br><span class="line">      tmp = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(j = head[i] ; j ; j = nxt[j])</span><br><span class="line">      &#123;</span><br><span class="line">         tx = <span class="built_in">find</span>(vx[j]) , ty = <span class="built_in">find</span>(vy[j]);</span><br><span class="line">         <span class="keyword">if</span>(tx != ty) f[tx] = ty , r[tx] = r[vx[j]] ^ r[vy[j]] ^ <span class="number">1</span> , tmp ++ ;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span>(r[vx[j]] == r[vy[j]]) <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(j) <span class="keyword">break</span>;</span><br><span class="line">      num -= tmp;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span> , i);</span><br><span class="line">   <span class="keyword">while</span>(num -- ) ans = ans * <span class="number">2</span> % <span class="number">1000000007</span>;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span> , ans);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第三题">第三题</h3>
<p>又是一道码农题</p>
<p><img
src="https://pic.imgdb.cn/item/6327df4816f2c2beb138860b.png" /></p>
<p><img
src="https://pic.imgdb.cn/item/6327df6116f2c2beb138a43b.png" /></p>
<p>数据量不超过15</p>
<p>显然是模拟：</p>
<p>大致思路：对于每一轮都扫一遍整个图形，最多的复杂度<span
class="math inline">\(O(15*15*10)\)</span>，每次都找出靠左靠下的联通块，然后消掉，把他上边的玩意往下掉，他右边的玩意往左挪窝</p>
<p>每次都这么搞，直到全图没有块或者不能消为止:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 20</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span> , <span class="type">int</span>&gt; pr;</span><br><span class="line">vector&lt;pr&gt; v[N * N];</span><br><span class="line"><span class="type">int</span> n , m , a[N][N] , b[N][N] , c[N][N] , tx[N] , ty , vis[N][N];</span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">ctoi</span><span class="params">(<span class="type">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> c == <span class="string">&#x27;R&#x27;</span> ? <span class="number">1</span> : c == <span class="string">&#x27;G&#x27;</span> ? <span class="number">2</span> : <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">itoc</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> a == <span class="number">1</span> ? <span class="string">&#x27;R&#x27;</span> : a == <span class="number">2</span> ? <span class="string">&#x27;G&#x27;</span> : <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floodfill</span><span class="params">(<span class="type">int</span> x , <span class="type">int</span> y , <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   v[k].<span class="built_in">push_back</span>(<span class="built_in">pr</span>(x , y)) , vis[x][y] = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">if</span>(x &gt; <span class="number">1</span> &amp;&amp; a[x - <span class="number">1</span>][y] == a[x][y] &amp;&amp; !vis[x - <span class="number">1</span>][y]) <span class="built_in">floodfill</span>(x - <span class="number">1</span> , y , k);</span><br><span class="line">   <span class="keyword">if</span>(x &lt; n &amp;&amp; a[x + <span class="number">1</span>][y] == a[x][y] &amp;&amp; !vis[x + <span class="number">1</span>][y]) <span class="built_in">floodfill</span>(x + <span class="number">1</span> , y , k);</span><br><span class="line">   <span class="keyword">if</span>(y &gt; <span class="number">1</span> &amp;&amp; a[x][y - <span class="number">1</span>] == a[x][y] &amp;&amp; !vis[x][y - <span class="number">1</span>]) <span class="built_in">floodfill</span>(x , y - <span class="number">1</span> , k);</span><br><span class="line">   <span class="keyword">if</span>(y &lt; m &amp;&amp; a[x][y + <span class="number">1</span>] == a[x][y] &amp;&amp; !vis[x][y + <span class="number">1</span>]) <span class="built_in">floodfill</span>(x , y + <span class="number">1</span> , k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> T , cc;</span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span> , &amp;T);</span><br><span class="line">   <span class="keyword">for</span>(cc = <span class="number">1</span> ; cc &lt;= T ; cc ++ )</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="type">int</span> i , j , cnt , sum = <span class="number">0</span> , step;</span><br><span class="line">      vector&lt;pr&gt;::iterator it;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span> , &amp;n , &amp;m) , cnt = n * m;</span><br><span class="line">      <span class="keyword">for</span>(i = n ; i &gt;= <span class="number">1</span> ; i -- )</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span> , str + <span class="number">1</span>);</span><br><span class="line">         <span class="keyword">for</span>(j = <span class="number">1</span> ; j &lt;= m ; j ++ ) a[i][j] = <span class="built_in">ctoi</span>(str[j]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Game %d:\n\n&quot;</span> , cc);</span><br><span class="line">      <span class="keyword">for</span>(step = <span class="number">1</span> ; cnt ; step ++ )</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">memset</span>(vis , <span class="number">0</span> , <span class="built_in">sizeof</span>(vis));</span><br><span class="line">         <span class="type">int</span> mx = <span class="number">0</span> , pi , id = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span>(j = <span class="number">1</span> ; j &lt;= m ; j ++ )</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= n ; i ++ )</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="keyword">if</span>(a[i][j] &amp;&amp; !vis[i][j])</span><br><span class="line">               &#123;</span><br><span class="line">                  id ++ , v[id].<span class="built_in">clear</span>() , <span class="built_in">floodfill</span>(i , j , id);</span><br><span class="line">                  <span class="keyword">if</span>(mx &lt; (<span class="type">int</span>)v[id].<span class="built_in">size</span>()) mx = v[id].<span class="built_in">size</span>() , pi = id;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(mx &lt; <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;Move %d at (%d,%d): removed %d balls of color %c, got %d points.\n&quot;</span> , step , v[pi][<span class="number">0</span>].first , v[pi][<span class="number">0</span>].second , mx , <span class="built_in">itoc</span>(a[v[pi][<span class="number">0</span>].first][v[pi][<span class="number">0</span>].second]) , (mx - <span class="number">2</span>) * (mx - <span class="number">2</span>));</span><br><span class="line">         sum += (mx - <span class="number">2</span>) * (mx - <span class="number">2</span>) , cnt -= mx;</span><br><span class="line">         <span class="keyword">for</span>(it = v[pi].<span class="built_in">begin</span>() ; it != v[pi].<span class="built_in">end</span>() ; it ++ ) a[it-&gt;first][it-&gt;second] = <span class="number">0</span>;</span><br><span class="line">         <span class="built_in">memset</span>(b , <span class="number">0</span> , <span class="built_in">sizeof</span>(b)) , <span class="built_in">memset</span>(tx , <span class="number">0</span> , <span class="built_in">sizeof</span>(tx)) , <span class="built_in">memset</span>(c , <span class="number">0</span> , <span class="built_in">sizeof</span>(c)) , ty = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= n ; i ++ )</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">1</span> ; j &lt;= m ; j ++ )</span><br><span class="line">               <span class="keyword">if</span>(a[i][j] != <span class="number">0</span>)</span><br><span class="line">                  b[++tx[j]][j] = a[i][j];</span><br><span class="line">         <span class="keyword">for</span>(j = <span class="number">1</span> ; j &lt;= m ; j ++ )</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="keyword">if</span>(tx[j] != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">               ty ++ ;</span><br><span class="line">               <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= n ; i ++ ) c[i][ty] = b[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt;= n ; i ++ )</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">1</span> ; j &lt;= m ; j ++ )</span><br><span class="line">               a[i][j] = c[i][j];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(!cnt) sum += <span class="number">1000</span>;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Final score: %d, with %d balls remaining.\n\n&quot;</span> , sum , cnt);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>暑假日常</category>
      </categories>
      <tags>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title>9.1集训</title>
    <url>/2020/09/01/9.1/</url>
    <content><![CDATA[<p>今天做了两道题 <span id="more"></span> 第一道 UVA10228 A Star not a Tree?</p>
<p>模拟退火的板子题，细节：i，j这种变量务必不要开全局</p>
<p>很难调</p>
<p>其次，注意审题，两个回车就很烦人</p>
<p>第二道 点分治1</p>
<p>点分治的模板题，</p>
<p>work里怎么写呢？ 假设我们要找的距离是<span
class="math inline">\(l\)</span>,我们可以先计算出子树里的点每一个点到子树重心的距离(如果不知道重心什么可以先去学一下，这里推荐一篇网上的博客<a
href="http://blog.csdn.net/ALPS233/article/details/51398629">这里</a>，讲的还是比较清晰的ORZ)，并将这些距离和对应的点属于中心的哪一个儿子下面打包在一起，按照距离从小到大排序。然后我们从小到大枚举每一个距离，并且二分查找能与其组合为lll的距离。并从中挑选出一个所属儿子不同的距离，那么<span
class="math inline">\(l\)</span>就找到了。</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title>9.12集训</title>
    <url>/2020/09/12/9.12/</url>
    <content><![CDATA[<p>考试 <span id="more"></span> bzoj2500幸福的道路</p>
<p>考虑分为两个子任务</p>
<ul>
<li>求出每个点在树上距离最远的距离</li>
<li>求出一段最大值与最小值之差不超过m的最长的一段区间</li>
</ul>
<p>第一个任务跑一边换根dp就好</p>
<p>第二个任务是Pilots，维护两个单调队列，发现差值大于m的时候，就弹弹弹</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">66</span>;</span><br><span class="line"><span class="type">int</span> n, m, res, pre;</span><br><span class="line"><span class="type">int</span> l1, r1, l2, r2, q1[N], q2[N];</span><br><span class="line"><span class="type">int</span> f[N], g[N][<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, y, z, fuck;</span><br><span class="line">    <span class="keyword">for</span> (i = head[x]; i; i = nex[i])</span><br><span class="line">    &#123;</span><br><span class="line">        y = to[i], z = len[i];</span><br><span class="line">        <span class="built_in">dfs1</span>(y);</span><br><span class="line">        fuck = g[y][<span class="number">1</span>] + z;</span><br><span class="line">        <span class="keyword">if</span> (fuck &gt; g[x][<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            g[x][<span class="number">2</span>] = g[x][<span class="number">1</span>];<span class="comment">//ci max</span></span><br><span class="line">            g[x][<span class="number">1</span>] = fuck;<span class="comment">//max</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fuck &gt; g[x][<span class="number">2</span>] &amp;&amp; fuck &lt; g[x][<span class="number">1</span>]) g[x][<span class="number">2</span>] = fuck;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, y, z, fuck;</span><br><span class="line">    <span class="keyword">for</span> (i = head[x]; i; i = nex[i])</span><br><span class="line">    &#123;</span><br><span class="line">        y = to[i], z = len[i];</span><br><span class="line">        fuck = g[x][<span class="number">1</span>] == g[y][<span class="number">1</span>] + z ? g[x][<span class="number">2</span>] : g[x][<span class="number">1</span>];</span><br><span class="line">        fuck = <span class="built_in">max</span>(fuck, f[x]);</span><br><span class="line">        fuck += z;</span><br><span class="line">        f[y] = fuck;</span><br><span class="line">        <span class="built_in">dfs2</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, y, z;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        y = <span class="built_in">read</span>(), z = <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">add</span>(y, i, z);</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">1</span>] = <span class="number">0</span>, <span class="built_in">dfs1</span>(<span class="number">1</span>), <span class="built_in">dfs2</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) f[i] = <span class="built_in">max</span>(f[i], g[i][<span class="number">1</span>]); <span class="comment">// step 1</span></span><br><span class="line"></span><br><span class="line">    l1 = l2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (l1 &lt;= r1 &amp;&amp; f[i] &lt; f[q1[r1]]) -- r1;</span><br><span class="line">        q1[++ r1] = i;</span><br><span class="line">        <span class="keyword">while</span> (l2 &lt;= r2 &amp;&amp; f[i] &gt; f[q2[r2]]) -- r2;</span><br><span class="line">        q2[++ r2] = i;</span><br><span class="line">        <span class="keyword">while</span> (f[q2[l2]] - f[q1[l1]] &gt; m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (q2[l2] &lt; q1[l1]) pre = q2[l2], ++ l2;</span><br><span class="line">            <span class="keyword">else</span> pre = q1[l1], ++ l1;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">max</span>(res, i - pre);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">put</span>(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.luogu.com.cn/problem/P3572">PTA-Little
Bird</a></p>
<p>简单dp</p>
<p>但是需要用单调队列来优化</p>
<p><a href="https://www.luogu.com.cn/problem/P3118">Moovie Mooving
G</a></p>
<p>这题壮压，并且用到bfs的搜索</p>
<p>bfs找到的第一个<span
class="math inline">\(f[S]\)</span>超过l就是正解了——因为宽搜保证看的电影数量递增</p>
<p><a
href="https://www.cnblogs.com/GXZlegend/p/8509480.html">bzoj2121字符串游戏</a></p>
<p>区间dp</p>
<p>状态：</p>
<p><span class="math inline">\(f[l][r]\)</span>表示<span
class="math inline">\(l,r\)</span>这段区间能否被删除</p>
<p><span class="math inline">\(g[l][r][i][j]\)</span>表示<span
class="math inline">\(l,r\)</span>这段区间能否删成第<span
class="math inline">\(i\)</span>个字符串的前<span
class="math inline">\(j\)</span>个字符</p>
<p>考虑匹配到中间一块，或者是把这段区间劈开，分成两段</p>
<p>如果进行匹配的话转移为 <span
class="math inline">\(g[l][r][i][j]=g[l][r-1][i][j-1]\)</span>，前提条件，<span
class="math inline">\(str[r] == w[i][j]\)</span>即区间右端点和第
<em>i</em> 个串的第 <em>j</em> 个字符相同</p>
<p>如果考虑劈开的话，转移为：<span class="math inline">\(g[l][r][i][j]=
g[l][k-1][i][j]\)</span>&amp;&amp;<span
class="math inline">\(f[k][r]\)</span></p>
<p>考虑答案， <span class="math inline">\(h[i] = h[i - 1] +
1\)</span>或者<span class="math inline">\(h[i] = h[j-1]\)</span></p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title>9.10集训</title>
    <url>/2020/09/10/9.10/</url>
    <content><![CDATA[<p>考试 <span id="more"></span> 关于一道数位dp</p>
<p>满足在它C进制下的各位数字之和可以整除这个数字本身</p>
<p>几乎就是数位dp板子题目</p>
<ul>
<li>前缀和思想</li>
<li>考虑对sum进行枚举</li>
<li>开ll</li>
<li>memset慢</li>
<li>limit限制可以继承的条件：自己当前是1，并且现在到了up</li>
</ul>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title>9.11集训</title>
    <url>/2020/09/11/9.11/</url>
    <content><![CDATA[<p>第一个 软件安装 <span id="more"></span> 是一个树形dp加tarjan缩点</p>
<p>注意缩点完成之后建立新图的时候，要与跟连边</p>
<p>第二个 股票交易</p>
<p>如果不优化的话，上来一大堆讨论</p>
<p>其中发现有两种情况可以用单调队列来优化</p>
<p>第三个 消耗战</p>
<p>是一个虚树+树形dp</p>
<p>这个树形dp很好写，但是虚树不好搞</p>
<p>大致思想：每次询问，我们如果对原树进行遍历的话，复杂度过高，无法接受</p>
<p>考虑将其中有用的点搞出来，我们遍历的时候，对这些点遍历即可，可大大缩减时间复杂度</p>
<p>考虑如何构建虚数：</p>
<p>构建一个栈，在不断弹栈的过程就是建立虚树的过程（先按照dfn序排序，防止反复跳</p>
<p>当前：sta[1] = root, sta[top]</p>
<p>新加进来一个x，考虑x与原来sta[top]的影响，对他俩求一个lca，如果lca为sta[top]，直接加进来就可以了</p>
<p>如果不是的话，大力讨论</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title>9.13集训</title>
    <url>/2020/09/13/9.13/</url>
    <content><![CDATA[<p>考试 <span id="more"></span> 第一题是个走迷宫</p>
<p>注意：判断有没有走过，别打tag标记，就用最简朴的vis数组来判断</p>
<p>坑点：开始为0与1</p>
<p>第二个是个类似选择数字的题目</p>
<p><span class="math inline">\(f[i] = min(f[i], f[i - 1] + abs(a[j] -
a[i]))\)</span></p>
<p><span
class="math inline">\(O(n^2)\)</span>可做70分，但是用权值线段树可以优化到100分</p>
<p>第三个是一个字符串问题</p>
<p>裸字符串可以30分</p>
<p>考虑优化：树剖</p>
<p>用类似倍增的思想，跳过一些不必要的串，在查询的时候特判id到底是不是大于n</p>
<p>不大于n说明不需要拼接，大于n的话需要拼接，就一直跳while</p>
<p>第四个是个原题</p>
<p>同花顺</p>
<p>考虑排序方式：先按花色，花色相同的按照点数来排序，然后考虑每一张牌作为结尾需要更换多少张牌</p>
<p>显然一定这副牌有n张</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= cnt; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">   now = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; (<span class="type">int</span>)v[i].<span class="built_in">size</span>(); ++ j)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">while</span>(v[i][now] &lt; v[i][j] - n + <span class="number">1</span>) ++ now;</span><br><span class="line">      res = <span class="built_in">max</span>(res, j - now + <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; n - res;</span><br></pre></td></tr></table></figure>
<p>然后通过上面的代码我们可以发现一个精妙绝伦地方：题目要求最小值，我们求出满足某张牌为结尾的，最多可以满足的牌数，让总数n减去这些最多可以满足的，剩下的就是最少需要更换的</p>
<p>其中now是左端点，j是右端点，j-now+1是区间长度</p>
<p>因为保证同花顺是递增的，所以<span
class="math inline">\(while(v[i][now] &lt; v[i][j] - n + 1) ++
now\)</span>，now就是在找，最多可以到哪里，就是now之前的都不合题意，now之后的，j之前的，满足v[i][j]作为结尾的牌</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title>9.20集训</title>
    <url>/2020/09/20/9.20/</url>
    <content><![CDATA[<p>9.14~9.20</p>
<p>搁置了一周的总结 <span id="more"></span> - 14：数论</p>
<p>推式子，与中国剩余定理</p>
<p>超能粒子炮</p>
<p>Longge问题</p>
<p>以及gcd的相关推理</p>
<ul>
<li>15：组合数学</li>
</ul>
<p>上学路线</p>
<p>排队</p>
<p>情侣组合问题</p>
<ul>
<li>16：数据结构</li>
</ul>
<p>加深对线段树的理解</p>
<ul>
<li>17：数据结构</li>
</ul>
<p>加深对分块还有单调栈与队列的理解</p>
<ul>
<li>18：数据结构</li>
</ul>
<p>加深对分块还有单调栈与队列的理解</p>
<ul>
<li>19：字符串，图论</li>
</ul>
<p>透彻AC自动机，透彻差分约束与最小生成树</p>
<ul>
<li>20：图论</li>
</ul>
<p>透彻拓扑排序</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title>9.2集训</title>
    <url>/2020/09/02/9.2/</url>
    <content><![CDATA[<p>今天做了三个题目 <span id="more"></span> 第一个hdu1848</p>
<p>显然，是个简单的sg函数题目</p>
<p>注意时间戳优化，与mex取区间最小值</p>
<p>第二个是小约翰的游戏</p>
<p>几乎是anti-nim的模板</p>
<p>当前状态不能拿是赢的话，显然</p>
<ul>
<li><p>每一堆石子只有一个时 且异或和为0</p></li>
<li><p>存在至少一堆石子多于一个时 且异或和不为0</p></li>
</ul>
<p>第三个是分裂游戏</p>
<p>是个multi-nim</p>
<p>注意换行！！！</p>
<ul>
<li><p>Multi-SG游戏规定
在符合拓扑原则的前提下一个单一游戏的后继可以是多个单一游戏</p></li>
<li><p>Multi-SG游戏其他规则同一般SG</p></li>
</ul>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title>9.14集训</title>
    <url>/2020/09/14/9.14/</url>
    <content><![CDATA[<p>今天做了几道数学题 <span id="more"></span> 第一道 hankson的趣味题</p>
<p><span class="math inline">\(\because gcd(x,a_0)=a_1\)</span></p>
<p><span class="math inline">\(\therefore
\gcd(x/a_1,a_0/a_1)=1\)</span></p>
<p><span class="math inline">\(\because lcm(x,b_0)=b_1\)</span></p>
<p><span class="math inline">\(\therefore gcd(x,b_0) = x\times b_0 /
lcm(x, b_0) = x\times b_0 / b_1\)</span></p>
<p><span class="math inline">\(\therefore
gcd(x/(x*b_0/b_1),b_0/(x*b_0/b_1))=1\)</span></p>
<p><span class="math inline">\(\therefore
gcd(b_1/b_0,b_1/x)=1\)</span></p>
<p>然后<span class="math inline">\(\sqrt n\)</span>枚举约数，注意<span
class="math inline">\(i \% a_1==0\)</span>的条件</p>
<p>第二道是组合数问题</p>
<p>考虑前缀和</p>
<p>还有递推边界：<span class="math inline">\(f[0][0] =f[1][0]=f[0][1]
=1\)</span></p>
<p>第三道货币系统</p>
<p>考虑<strong>筛</strong></p>
<p>哪些数字不能被数组内的数字筛到，就得计数器++</p>
<p>用时间戳和桶来优化</p>
<p>第四道是解方程</p>
<p>运用秦九韶的结合律</p>
<p>第五道是Longge的问题</p>
<p><img
src="https://pic.imgdb.cn/item/6327dbab16f2c2beb13328da.png" /></p>
<p>第六道是中国剩余定理(CRT)/曹冲养猪</p>
<p><img
src="https://pic.imgdb.cn/item/6327dbcc16f2c2beb133670c.png" /></p>
<p>第七道是能量采集</p>
<p>预处理出欧拉函数前缀和，然后用整除分块，这个题目就O(min⁡(n,m))地解决了。</p>
<p>还有一道是BZOJ的欧拉心算</p>
<p><span
class="math display">\[\sum_{i=1}^n\sum_{j=1}^n\sum_{d=1}^n[gcd(i,j)=d]phi[d]\]</span></p>
<p><span
class="math display">\[=\sum_{d=1}^nphi[d]*2\sum_{i=1}^{n/d}\sum_{j=1}^{n/d}(phi[i]-1)\]</span></p>
<p>咦？后边不就是仪仗队吗？</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title>9.21集训</title>
    <url>/2020/09/21/9.21/</url>
    <content><![CDATA[<p>今天上午改题 <span id="more"></span> 毒瘤树剖题改过了</p>
<p>还透彻了割点与割边</p>
<p>割点：判断顶点U是否为割点，用U顶点的dnf值和它的所有的孩子顶点的low值进行比较，如果存在至少一个孩子顶点V满足low[v]
&gt;=
dnf[u]，就说明顶点V访问顶点U的祖先顶点，必须通过顶点U，而不存在顶点V到顶点U祖先顶点的其它路径，所以顶点U就是一个割点。对于没有孩子顶点的顶点，显然不会是割点。</p>
<p>桥（割边）：low[v] &gt; dnf[u] 就说明V-U是桥</p>
<p>下午考试</p>
<p>其中原题还是做对了，第一题是个假贪心，正解是暴力</p>
<p>第三题是树剖，在lca那里操作一下</p>
<p>第二题不会</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title>9.22</title>
    <url>/2020/09/22/9.22/</url>
    <content><![CDATA[<ul>
<li><p>透彻pair与map的合理利用来处理重边 <span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pr;</span><br><span class="line">map&lt;pr, <span class="type">bool</span>&gt;existd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">    x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">if</span> (existd[<span class="built_in">pr</span>(x, y)] == <span class="literal">true</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">add_edge</span>(x, y), <span class="built_in">add_edge</span>(y, x);</span><br><span class="line">    </span><br><span class="line">    existd[<span class="built_in">pr</span>(x, y)] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>割点</p></li>
</ul>
<p>割点不需要判断什么儿子父亲</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">flag</span><span class="params">(<span class="number">0</span>)</span>, i, y</span>;</span><br><span class="line">    dfn[x] = low[x] = ++ num;</span><br><span class="line">    <span class="keyword">for</span> (i = head[x]; i; i = nex[i])</span><br><span class="line">    &#123;</span><br><span class="line">        y = ver[i];</span><br><span class="line">        <span class="keyword">if</span> (! dfn[y])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(y);</span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">            <span class="keyword">if</span> (low[y] &gt;= dfn[x])</span><br><span class="line">            &#123;</span><br><span class="line">                ++ flag;</span><br><span class="line">                <span class="keyword">if</span> (x != root || flag &gt; <span class="number">1</span>) cut[x] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> low[x] = <span class="built_in">min</span>(low[x], dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>if (x != root || flag &gt; 1) cut[x] = true;</p>
<p>很巧妙的一句话，考虑if不成立的条件，x不为root，并且flag大于1</p>
<ul>
<li>割边</li>
</ul>
<p>需要来判断另一条边</p>
<p>令cnt从2开始计数</p>
<p>2 XOR 1 = 3，3 XOR 1 = 2</p>
<ul>
<li>曾经做过的一道原题，见7.30</li>
</ul>
<p>其中t数组的运用太niub了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fuck</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, l, r, tot;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) f[i] = g[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            sum[i][j] = a[i][j];</span><br><span class="line">            sum[i][j] += sum[i][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (l = <span class="number">1</span>; l &lt;= n; ++ l)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (r = l; r &lt;= n; ++ r)</span><br><span class="line">        &#123;</span><br><span class="line">            tot = <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; p; ++ i) t[i] = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            &#123;</span><br><span class="line">                tot += sum[i][r] - sum[i][l - <span class="number">1</span>];</span><br><span class="line">                tot %= p;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (t[tot] != <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    f[r] = <span class="built_in">max</span>(f[r], (r - l + <span class="number">1</span>) * (i - t[tot]));</span><br><span class="line">                    g[l] = <span class="built_in">max</span>(g[l], (r - l + <span class="number">1</span>) * (i - t[tot]));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> t[tot] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; -- i) g[i] = <span class="built_in">max</span>(g[i], g[i + <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; ++ i) res = <span class="built_in">max</span>(res, f[i] + g[i + <span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于旋转矩形那里，直接swap就得了</p>
<ul>
<li>考试题</li>
</ul>
<p>大致题意：
每次可以选择一行或者一列加上1，令3，6，9，12为好数，问最多可以有多少个好数？</p>
<p>一道考试题的暴力思路</p>
<p>首先对所有数字mod3，因为我们只需要知道这个数字变为3的倍数需要加上几最后对这个矩阵扫一遍，统计零的个数就是答案</p>
<p>对同一个数字在某一行或者某一列记录他出现的次数，对于出现最多次数的数字，判断其与当前行（或者列）零出现的次数</p>
<p>如果比零出现的次数多，说明使得这一行（或者列）出现次数最多的数字变为0（也就是成为3的倍数）之后，得到的0比原来更多
反之就不操作</p>
<p>do_while什么时候结束？就是当所有行或者列里面，零出现的次数都是最多的，也就意味着再进行操作就不优了</p>
<p>这种做法在数值属于[1,12]期间的时候，是可以AC的</p>
<p>但是他的数值可以变为负数，可以大于12</p>
<p>正解是搜索</p>
<ul>
<li>另一道考试题目</li>
</ul>
<p>在维护最大值的时候</p>
<p>多考虑优先队列大根堆</p>
<p>其中如果需要查找前后值的话，考虑链表</p>
<p>其中维护链表的时候，总之务必搞清楚先nex还是pre</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title>9.25</title>
    <url>/2020/09/25/9.25/</url>
    <content><![CDATA[<p>今天考试了，顺带做了几道以前遗留的题目</p>
<span id="more"></span>
<ul>
<li>考试第一题</li>
</ul>
<p>有 n+1
艘船，告诉你每艘船距离终点的长度、船身的长度和最高行驶速度。在行驶的过程中不允许超越（即后面的船最多也只能
船头贴着前一辆船的船尾，然后以同样的速度前进），问这些船均驶过终点需要多长时间</p>
<p>就是一个sb模拟或者说是贪心题</p>
<p>t要取max</p>
<ul>
<li>考试第二题</li>
</ul>
<p>拓展知识点：欧拉回路中所有的点度数一定为偶数，奇度数的点一定是成对出现，并且每一次连虚边，都会使得两个奇度数的点消失</p>
<p>注意要先便利虚边，因为这样会使得连得边尽量少</p>
<ul>
<li>选择数字</li>
</ul>
<p>给定一行n个非负整数a[1]..a[n]。现在你可以选择其中若干个数，但不能有超过k个连续的数字被选择。你的任务是使得选出的数字的和最大</p>
<p>转移式子好推，但是需要单调队列优化来求出最大值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fuck</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    d[x] = f[x - <span class="number">1</span>] - sum[x];</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r &amp;&amp; q[l] + k &lt; x) ++ l;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r &amp;&amp; d[x] &gt; d[q[r]]) -- r;</span><br><span class="line">    q[++ r] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    n = <span class="built_in">read</span>(), k = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">read</span>();</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fuck</span>(i);</span><br><span class="line">        f[i] = d[q[l]] + sum[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">put</span>(f[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>GCD</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i ++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = i * <span class="number">2</span>; j &lt; N; j += i)</span><br><span class="line">        f[j] += i * phi[j / i]; </span><br></pre></td></tr></table></figure>
<p>我们考虑什么时候因子x会加贡献，当n为x的倍数的时候就又会产生贡献，就像上边那样</p>
<p>构造前缀和就可</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title>9.26</title>
    <url>/2020/09/26/9.26/</url>
    <content><![CDATA[<p>上午改题加透彻树形dp</p>
<ul>
<li>树形dp的最小点覆盖与最小边覆盖大有千秋</li>
</ul>
<span id="more"></span>
<p>最小边覆盖只需要考虑：这条边是由他还是他儿子控制，即边的两个端点</p>
<p>而最小点覆盖：需要考虑一个点是由他儿子还是他自己或者是他父亲节点控制，状态有三维</p>
<p>其中最小边覆盖，一定包含所有边与点</p>
<p>而最小点覆盖，一定包含所有点，但是不一定包含所有边，例子不难举出反例</p>
<p>P2016战略游戏是需要全部边被占，包含全部点被占的情况，而保安站岗并不一定所有边都会被占</p>
<ul>
<li>考试第一题</li>
</ul>
<p>一个一元二次<del>sb</del>算术题，但是要考虑精度问题，在<span
class="math inline">\([x, x+1]\)</span>之间都要算一下</p>
<ul>
<li>考试第二题</li>
</ul>
<p>大致题意：每次可以选择一条边在其一端加1，在另一端点减1，但是有一个权值范围，求<span
class="math inline">\(\sum i \times val[i]\)</span></p>
<p>由于在第一题浪费太多时间，看第二题的时候第一反应是写暴力，但是tm暴力部分分比正解还要难写难调</p>
<p>solution：搜出所有联通块，显然在一个联通块里面所有的点都是可达的，无论通过何种操作，我们都可以使得一个点加1一个点减1</p>
<p>所以，贪心的倒序枚举点的编号，尽量满足编号大的，所有联通块所贡献出来的和就是答案</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">fuck</span><span class="params">(<span class="type">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(v[x].<span class="built_in">begin</span>(), v[x].<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> s = v[x].<span class="built_in">size</span>(), <span class="built_in">ret</span>(<span class="number">0</span>), i, y;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; s; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        y = v[x][i];</span><br><span class="line">        val[y] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    w[x] -= s;</span><br><span class="line">    <span class="keyword">for</span> (i = s - <span class="number">1</span>; i &gt;= <span class="number">0</span>; -- i)</span><br><span class="line">    &#123;</span><br><span class="line">        y = v[x][i];</span><br><span class="line">        val[y] += <span class="built_in">min</span>(L - <span class="number">1</span>, w[x]);</span><br><span class="line">        <span class="keyword">if</span> (val[y] != L) w[x] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> w[x] -= (L - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (w[x] &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; s; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        y = v[x][i];</span><br><span class="line">        ret = ret + y * val[y];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title>9.23</title>
    <url>/2020/09/23/9.23/</url>
    <content><![CDATA[<ul>
<li>染色</li>
</ul>
<p>一道贪心好题</p>
<p>可以被hack的贪心思想是：每次都选权值最大的节点 <span id="more"></span>
正确贪心：搞一个综合权值</p>
<p>每次儿子弄完之后，立马与他的父亲合并</p>
<ul>
<li>Vim</li>
</ul>
<p>vim相关知识</p>
<p>vim可以有行号:set nu</p>
<p>vim在普通模式下键不可以随便按，每个都有不同的功能：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">w 下一个单词</span><br><span class="line">b 上一个单词</span><br><span class="line">x 删一个</span><br><span class="line">dd 删除一行</span><br><span class="line">ndd 删除n行</span><br><span class="line">gg 跳到开头</span><br><span class="line">G 跳到结尾</span><br><span class="line">nG 跳到第n行</span><br><span class="line">y 复制</span><br><span class="line">yn 复制n行</span><br><span class="line">p 粘贴</span><br><span class="line">ddp 可以交换上下行</span><br><span class="line">0 行首</span><br><span class="line">shift + $ 行尾</span><br><span class="line">i 插入模式</span><br><span class="line">I 在行首插入</span><br><span class="line">A 在行末插入</span><br><span class="line">h j k l</span><br><span class="line">分别上向左 向下 向上 向右</span><br><span class="line">Ctrl + o 跳到上次操作的地方</span><br></pre></td></tr></table></figure>
<p>养成按ESC的习惯，多在普通模式与插入模式之间切换</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title>9.3集训</title>
    <url>/2020/09/03/9.3/</url>
    <content><![CDATA[<p>第一道题 江南乐 <span id="more"></span> 是一道博弈论的题目，学长讲了。</p>
<p>multi-nim</p>
<p>将数量为m的一堆划分为i堆，将会划分出$m i <span
class="math inline">\(堆个数为m的堆，和\)</span>m - m i i<span
class="math inline">\(堆个数为\)</span>m+1$的堆</p>
<p>枚举i，求出划分为i堆的sg函数，效率很低，考虑优化</p>
<p>根据的异或的性质可以得到，偶数个同样的数异或起来，等于没有异或</p>
<p>因此如果他是奇数，我们才去异或</p>
<p>并且应用到整除分块，<span class="math inline">\(\dfrac m {\dfrac m
i}\)</span> 为<span class="math inline">\(\dfrac m
i\)</span>值相同的<span class="math inline">\(i\)</span>的最大值</p>
<p><strong>！！！注意：优化find,是用此时的x标记后继状态,
找mex时寻找具有这个标记的x的后继状态.</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (sg[x] != <span class="number">-1</span>) <span class="keyword">return</span> sg[x];</span><br><span class="line"><span class="keyword">if</span> (x &lt; f) <span class="keyword">return</span> sg[x] = <span class="number">0</span>;</span><br><span class="line">sg[x] = <span class="number">0</span>; <span class="type">int</span> i, j, res;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= x; i = x / (x / i) + <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (j = i; j &lt;= <span class="built_in">min</span>(i + <span class="number">1</span>, x); ++ j)</span><br><span class="line">    &#123;</span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ((x % j) &amp; <span class="number">1</span>) res = res ^ <span class="built_in">yhm_find</span>(x / j + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> ((j - x % j) &amp; <span class="number">1</span>) res = res ^ <span class="built_in">yhm_find</span>(x / j);</span><br><span class="line">        s[res] = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (s[sg[x]] == x) ++ sg[x];</span><br><span class="line"><span class="keyword">return</span> sg[x];</span><br></pre></td></tr></table></figure>
<p>第二道是ddp"动态 DP"&amp;动态树分治</p>
<p>动态dp&amp;动态树分治</p>
<p>考虑思路：</p>
<ul>
<li>在树上搞出dp</li>
<li>转移到序列上</li>
<li>再搬回树上观察修改点所带来的影响</li>
<li>考虑优化，树剖跳轻儿子保证复杂度<span
class="math inline">\(O(logn)\)</span></li>
<li>于是考虑通过矩阵来优化新构造出的dp转移方程式</li>
</ul>
<p>其中下面这一局是树剖最经典的语句：<span
class="math inline">\(query(dfn[x], end[top[x]], 1, n, 1)\)</span></p>
<p>——把树弄到了序列上</p>
<p>第三道是MET-Meteors（整体二分）</p>
<p>考虑整体二分的思路来源</p>
<p>对于这道题，我们当然可以二分做，但是二分做复杂度过于高</p>
<p>考虑对整体二分</p>
<p>显然，对值域进行二分看起来是一个不错的选择</p>
<p>于是我们选择对值域进行二分</p>
<p>然后验证的时候，和正常二分无太大思想的差异</p>
<p>但是在递归去求解子区间的时候，需要注意，用线段树或者树状数组来维护，因为是log的</p>
<p>其中如果发现左半区间无解，往右半区间递归的时候</p>
<p>应该减去在左半区间已经达到的答案</p>
<p><strong>！！！注意：在修改之后，要进行复原</strong></p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title>9.24</title>
    <url>/2020/09/24/9.24/</url>
    <content><![CDATA[<ul>
<li>一道关于树剖的题</li>
</ul>
<p>大致题意：单点修改，区间询问某个颜色有多少个，其中颜色有100个
<span id="more"></span>
考虑对每个点都维护100个数组，每个数组记录每个颜色出现了多少次</p>
<p>单点修改的话：</p>
<p>可以按照区间修改来做，其中左端点与右端点都为同一个数字，不用down，但是需要up，up的时候，就是让父节点的颜色数组等于两个儿子节点颜色数组的相加</p>
<p>区间询问的话：</p>
<p>跳重链，对每一个链都统计答案</p>
<p>拓展：一道题叫色板游戏，都是对权值开数组，不过那个题是对一个颜色开一个数组来记录是否出现而不是多少次，在up的时候，应先让父节点的颜色数组都清空，然后再对儿子节点的颜色数组操作</p>
<ul>
<li>一道关于双指针的题目</li>
</ul>
<p>大致题意：给定四行变量，从四行变量中分别选出1个，使得不超过n，由于多少种选法？</p>
<p>如果暴力搞，<span
class="math inline">\(O(n^4)\)</span>，显然不合适</p>
<p>考虑两两结合来搞</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title>9.4集训</title>
    <url>/2020/09/04/9.4/</url>
    <content><![CDATA[<p>第一道题是 插头dp模板 <span id="more"></span> * 七种状态</p>
<ul>
<li><p>四进制</p></li>
<li><p>从1开始</p></li>
<li><p>HASH存储来优化</p></li>
<li><p>清空HASH</p></li>
<li><p>for (j = 1; j &lt;= cnt[now]; ++ j) vis[now][j] &lt;&lt;=
2;</p></li>
</ul>
<p>考虑到一行的末尾的时候，需要整体向左平移一位，四进制下，需要2</p>
<ul>
<li>异或两次就抵消</li>
</ul>
<p>第二道是邮递员</p>
<ul>
<li><p>考虑特判n=1，m=1的情况</p></li>
<li><p>特判n&gt;m的情况</p></li>
<li><p>__int128需要手写输出</p></li>
</ul>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title>9.27</title>
    <url>/2020/09/27/9.27/</url>
    <content><![CDATA[<p>考试透彻期望与lca</p>
<p>osu系列题目</p>
<span id="more"></span>
<ul>
<li>考试第一题，仓鼠找suger</li>
</ul>
<p>有解的情况是<span class="math inline">\(d1 + d2 == d3 || r1 + r2 ==
r3\)</span></p>
<p>倍增求lca即可，注意距离是<span class="math inline">\(dis = dep[x] +
dep[y] - 2 \times dep[lca(x, y)]\)</span></p>
<ul>
<li>考试第二题，一个数据结构题</li>
</ul>
<p>给你一个随机生成的 1~n 的排列，并定义区间[l,r]的价值为<span
class="math inline">\(C_{l,r} = max(a_i-a_j|l \leq i,j \leq
j)\)</span></p>
<p>部分分很好拿，但是正解并不容易做，有很多种做法，单调栈，单调队列，ST表都可以做，几乎只要是可以维护最大值最小值的数据结构都可以做</p>
<p>这里只介绍ST表的做法，一个<span
class="math inline">\(O(nlogn)\)</span>预处理，<span
class="math inline">\(O(1)\)</span>查询的数据结构</p>
<p>先预处理ST表</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pres_dou</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) f[i][<span class="number">0</span>] = a[i], g[i][<span class="number">0</span>] = a[i];</span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">log</span>(n) / <span class="built_in">log</span>(<span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; t; ++ j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n - (<span class="number">1</span> &lt;&lt; j) + <span class="number">1</span>; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i][j - <span class="number">1</span>], f[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">            g[i][j] = <span class="built_in">min</span>(g[i][j - <span class="number">1</span>], g[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查询的时候，考虑求出一个最大的<span
class="math inline">\(k\)</span>，使得<span class="math inline">\(l \leq
2^k\leq r\)</span>， 有重叠也无妨</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query_maxv</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="built_in">log</span>(r - l + <span class="number">1</span>) / <span class="built_in">log</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(f[l][k], f[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回到这个题，我们求出每一个数的最小贡献，与最大贡献，并使之加和</p>
<p>答案就是最大贡献与最小贡献的差</p>
<p>其中，在求答案的时候，考虑这个数左右两边的端点，显然他左边的，他都可以贡献，他右边的，他也可以贡献，并且跨越他的区间，他也会贡献，代码呼之欲出：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fuck_minv</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r || l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> minv = <span class="built_in">query_minv</span>(l ,r);</span><br><span class="line">    res_minv += <span class="number">1ll</span> * (<span class="number">1ll</span> * (pos[minv] - l) * (r - pos[minv]) + (<span class="number">1ll</span> * pos[minv] - l) + (r - pos[minv])) * minv;</span><br><span class="line">    <span class="built_in">fuck_minv</span>(l, pos[minv] - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">fuck_minv</span>(pos[minv] + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>OSU的期望</li>
</ul>
<p>显然对于<span
class="math inline">\(n^3\)</span>不好推，我们从一维的入手</p>
<p>设<span
class="math inline">\(a[i]\)</span>为前i位中，第i位为1的长度的期望：</p>
<p><span class="math display">\[a[i] = (a[i-1]+1)]\times
p[i]\]</span></p>
<p>然后推平方，设<span
class="math inline">\(b[i]\)</span>为前i位中，第i位为1的长度的平方的期望：</p>
<p><span class="math display">\[b[i] = (b[i -1]+2*a[i-1]+1)\times
p[i]\]</span></p>
<p><span class="math inline">\(tag:\)</span>期望线性眼神：<span
class="math inline">\(x^2-&gt;(x+1)^2-&gt;x^2+2x+1\)</span></p>
<p>然后推立方，设<span
class="math inline">\(f[i]​\)</span>为前i位中，第i位为1的长度的立方的期望：</p>
<p><span class="math display">\[f[i]  = (f[i -1] + 3\times b[i
-1]＋3\times a[i - 1]+ 1)\times p[i]​\]</span></p>
<p>但是这并不是答案，这都是<strong>第i位</strong>，答案要求<strong>前i位</strong>，还需要过渡一下</p>
<p><span class="math display">\[f[i]  = (f[i -1] + 3\times b[i
-1]＋3\times a[i - 1]+ 1)\times p[i]+ f[i -1]\times
(1-p[i])​\]</span></p>
<p><span class="math display">\[f[i]  = f[i - 1]+(3\times b[i
-1]＋3\times a[i - 1]+ 1)\times p[i]\]</span></p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title>9.6集训</title>
    <url>/2020/09/06/9.6/</url>
    <content><![CDATA[<p>今天首先把线段树两个板子题目，独立的用结构体写出来了 <span id="more"></span>
以前都是用的数组写的，但是显然数组很麻烦，</p>
<p>今天总算改成结构体了</p>
<p>两个题，共计200行代码，码码码码…</p>
<p>然后做一道整体二分的题目MET-Meteors</p>
<ul>
<li><span class="math inline">\(a[i].top -= tmp, str[++ cntr] =
a[i];\)</span>先减再去赋值</li>
</ul>
<p>打比赛</p>
<p>Water Tree</p>
<p>树剖的题目，不用去建立树</p>
<p>还有，<span class="math inline">\(add\)</span>或者<span
class="math inline">\(updata\)</span>的时候，一定是对dfn搞</p>
<p>tid是反着的，是用于build的时候用的</p>
<p>魔法树</p>
<ul>
<li>路径加，就跳重链</li>
<li>区间询问直接上线段树</li>
</ul>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title>9.8集训</title>
    <url>/2020/09/08/9.8/</url>
    <content><![CDATA[<p>火柴排队一题 <span id="more"></span> - 离散化的时候</p>
<p><span class="math inline">\(a[i] = f[i].rank\)</span>这才是离散化</p>
<ul>
<li>求逆序对用树状数组</li>
</ul>
<p>两种写法，一种是先插入后查询，统计答案的时候不需要加加减减</p>
<p>另一种是先查询，后插入，不过需要<span class="math inline">\(i -
query(a[i]) -1\)</span></p>
<p>货车运输一题</p>
<p>是真tm恶心，真tm细节</p>
<ul>
<li>求lca的时候，无论是中途return还是最后的return都必须返回权值，返回结点编号是没有用的</li>
<li>什么时候用fa，必定会伴随着w的出现</li>
<li>在最小生成树里面，加边的时候，应该是对结构体伴随着的点加边，而不是后来find到的</li>
<li>dfs里面的for要从1开始而不是0</li>
<li>先取min再跳</li>
</ul>
<p>推荐例题：<a href="https://darkbzoj.tk/problem/3732">click</a></p>
<p>货车运输的即视感</p>
<p>与货车运输相反的一个题</p>
<p>修改点：</p>
<ul>
<li>min变为max</li>
<li>比较符号修改</li>
<li>res不要初始化为INF了</li>
</ul>
<p>今天做了dp</p>
<p>有简单的有难的</p>
<p>第一道Coloring Brackets</p>
<p>是一个区间dp</p>
<ul>
<li>碰到括号就想栈</li>
<li>第一道大法师与动规结合的题目</li>
</ul>
<p>状态：<span
class="math inline">\(f[l][r][i][j]\)</span>表示在l与r之间，且l为i颜色，r为j颜色时候所能获得的最大价值</p>
<p>规定用0表示没有颜色，1是红色，2是蓝色</p>
<ul>
<li>考虑三种情况</li>
</ul>
<p><span class="math inline">\(l+1=r\)</span>这是边界<span
class="math inline">\(f[l][r][0][1] = f[l][r][0][2] = f[l][r][1][0] =
f[l][r][2][0] = 1\)</span></p>
<p><span class="math inline">\(mch[l]=r\)</span>接下来<span
class="math inline">\(dfs(l+1,r-1)\)</span>既然两边匹配了，考虑进一步往里边缩</p>
<p><span class="math inline">\(if (j != 1) (f[l][r][0][1] += f[l + 1][r
- 1][i][j]) \%= mod;\)</span> <span class="math inline">\(if (j != 2)
(f[l][r][0][2] += f[l + 1][r - 1][i][j]) \%= mod;\)</span> <span
class="math inline">\(if (i != 1) (f[l][r][1][0] += f[l + 1][r -
1][i][j]) \%= mod;\)</span> <span class="math inline">\(if (i != 2)
(f[l][r][2][0] += f[l + 1][r - 1][i][j]) \%= mod;\)</span></p>
<p>啥也不是，<span
class="math inline">\(dfs(l,mch[l])\;and\;dfs(mch[l]+1,r)\)</span></p>
<p><span class="math inline">\(if ((j == 1\)</span> &amp;&amp; <span
class="math inline">\(p == 1) || (j == 2\)</span> &amp;&amp; <span
class="math inline">\(p == 2)) continue;\)</span> <span
class="math inline">\((f[l][r][i][q] += f[l][mch[l]][i][j] * f[mch[l] +
1][r][p][q]) \%= mod\)</span></p>
<p>因为两个相邻的颜色不能一样，所以要特判</p>
<p>第二道是[IOI1998]Polygon</p>
<p>也是一个区间dp</p>
<p>乘积最大的即视感</p>
<ul>
<li>考虑断环成链</li>
<li>初始化先大面再i=i</li>
<li>考虑dp</li>
</ul>
<p>记录f数组为最大的贡献，g数组为最小的贡献</p>
<p>因为涉及到负负得正的情况，加法转移一眼就出来了</p>
<p>乘法转移就很冗杂：</p>
<p><span class="math inline">\(q = f[i][k] * f[k + 1][j], w = g[i][k] *
g[k + 1][j]\)</span> <span class="math inline">\(e = f[i][k] * g[k +
1][j], r = g[i][k] * f[k + 1][j]\)</span> <span class="math inline">\(q
= max(q, w), e = max(e, r)\)</span> <span class="math inline">\(q =
max(q, w)\)</span> <span class="math inline">\(f[i][j] = max(f[i][j],
q);\)</span></p>
<p>左边最大<span
class="math inline">\(\times\)</span>右边最大，左边最大<span
class="math inline">\(\times\)</span>右边最小</p>
<p>左边最小<span
class="math inline">\(\times\)</span>右边最大，左边最小<span
class="math inline">\(\times\)</span>右边最小</p>
<p>g数组同理</p>
<ul>
<li><p>输出答案时候顺着扫一遍就可</p></li>
<li><p>输入时候，考虑多<span
class="math inline">\(getchar\)</span>因为有空格，并且不要用快读，碰到要一起读字符和数字的题目就不要用快读了</p></li>
</ul>
<p>第三道是时态同步</p>
<p>是一个树形dp</p>
<p><span class="math inline">\(f[] show\;the\;longest\;distance\;form
&quot;the&quot; tree&#39;s Root\;to\;its\;sons.\)</span></p>
<p>就是当前以x为根的子树中的最长链的长度，然后答案统计的时候</p>
<p><span class="math inline">\(res+=f[x] -(f[y]+edge(x,y))\)</span></p>
<p>第四道是一个完全背包</p>
<p>考虑完全背包与01背包的区别</p>
<ul>
<li>完全背包是正着扫，因为你现在用的状态可能就是原来已经买过一件的，你可以选择多次用这同一件来填充价值</li>
<li>而01背包是每次只能用一个，因此倒着扫，保证不会用到原来的状态</li>
</ul>
<p>！！！！！！01背包也可以AC</p>
<p>第五道是最长公共子序列 q[x] =
y,表示x在A中出现在了B哪个地方（将A序列的数字在B序列中的位置表示出来——）</p>
<p>我们要求这个数组的最长上升子序列即为这两个序列的最长公共子序列，我不会证明，但是我知道这么做是对的</p>
<p><span
class="math inline">\(n^2\)</span>复杂度过不去啊，所以我们只能借用STL的lower_bound来log优化一下</p>
<p>mp数组其实是一个不断覆盖的过程</p>
<p>我们保证mp一定是一个递增的序列，因此我们可以直接用res去更新pos</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title>9.7集训</title>
    <url>/2020/09/07/9.7/</url>
    <content><![CDATA[<p>上午考试，满分300分 <span id="more"></span> 第一题切了</p>
<p>第二题60分暴力</p>
<p>第三题70分暴力</p>
<p><strong>预计230分</strong></p>
<p>但是我第三题少打了一个头文件，（这次没用bits/stdc++.h)编译错误了</p>
<p>实际得分<strong>160</strong></p>
<p>第二题：</p>
<p>暴力接近正解</p>
<p>还是对于每一个数字都往后扫</p>
<p>碰到1就要开始操作</p>
<ul>
<li>跳1的长度</li>
<li><span class="math inline">\(1 \leq \dfrac p k- s\)</span></li>
</ul>
<p>如果不是1，并且发现已经计算出来的答案已经超过最大值就break</p>
<p>第三题考虑正解：</p>
<p><del>输出样例</del></p>
<p>但是输出样例的确就AC了</p>
<p>因为你考虑<span class="math inline">\(a\;XOR\;b=c\)</span></p>
<p>如果<span class="math inline">\(c\)</span>在<span
class="math inline">\(A\)</span>中，<span
class="math inline">\(c\;XOR\;b=a\)</span></p>
<p>如果<span class="math inline">\(c\)</span>在<span
class="math inline">\(B\)</span>中，<span
class="math inline">\(a\;XOR\;c=b\)</span></p>
<p>必定成对出现，要么是零，要么是2的倍数</p>
<p>而最后答案判奇偶，显然是<strong>0</strong></p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title>9.5集训</title>
    <url>/2020/09/05/9.5/</url>
    <content><![CDATA[<p>没做太多题目，在透彻知识点 <span id="more"></span> 第一道是LOJ分块6</p>
<p>单点插入单点查询</p>
<p>考虑数组查询<span class="math inline">\(O(1)\)</span>插入<span
class="math inline">\(O(n)\)</span>，链表插入<span
class="math inline">\(O(1)\)</span>，查询<span
class="math inline">\(O(n)\)</span></p>
<p>考虑兼顾二者的性质，而块状链表很好的解决了这个问题，但是链表不好写，考虑用动态数组</p>
<p>此题每块内可以放一个动态的数组，每次插入时先找到位置所在的块，再暴力插入，把块内的其它元素直接向后移动一位，当然用链表也是可以的</p>
<p>每根号n次插入后，重新把数列平均分一下块，重构需要的复杂度为O(n)，重构的次数为√n，所以重构的复杂度没有问题，而且保证了每个块的大小相对均衡</p>
<ul>
<li>查询函数<span class="math inline">\(return \; pr(x, b -
1)\)</span></li>
</ul>
<p><span class="math inline">\(b-1\)</span>是因为<span
class="math inline">\(vector\)</span>是从0开始计数的</p>
<ul>
<li>关于快读快输</li>
</ul>
<details>
<summary>
put
</summary>
<pre><code>inline void put(int x)
&#123;
   if (! x) putchar('0');
   int num(0); char c[66];
   while (x) c[++ num] = x % 10 + 48, x /= 10;
   while (num) putchar(c[num --]);
   putchar('\n');
&#125;
</code></pre>
</details>
<p>快输没问题</p>
<p>考虑两个版本的快读</p>
<details>
<summary>
read
</summary>
<pre><code>inline int read()
&#123;
   int s(0), w(1);
   char ch = getchar();
   while (ch < '0' || ch > '9') &#123;if (ch == '-') w = -1; ch = getchar();&#125;
   while (ch >= '0' && ch <= '9') s = s * 10 + ch - '0', ch = getchar();
   return s * w;
&#125;
</code></pre>
</details>
<p>第一种,显然好理解，先读入，判断是不是自负并且判负数</p>
<details>
<summary>
read
</summary>
<pre><code>LL in()
&#123;
   LL x = 0, f = 1; char ch;
   while(!isdigit(ch = getchar()))(ch == '-') && (f = -f);
   for(x = ch ^ 48; isdigit(ch = getchar()); x = (x << 1) + (x << 3) + (ch ^ 48));
   return x * f;
&#125;
</code></pre>
</details>
<p>其中<span
class="math inline">\(isdigit\)</span>判断是不是字母，后边的&amp;&amp;代替了if</p>
<p>第二个for中的<span class="math inline">\(x = (x &lt;&lt; 1) + (x
&lt;&lt; 3)\)</span>相当于<span class="math inline">\(x *
10\)</span></p>
<p>其中</p>
<p>$ x &lt;&lt;1 =x ,x&lt;&lt;3=x$</p>
<p><span class="math inline">\(\therefore (x&lt;&lt;1)+(x&lt;&lt;3) = x
\times 2 + x \times 8 = x \times 10\)</span></p>
<p>至此完成转化</p>
<p>第二道是模拟退火的题目</p>
<p>考虑可以更新答案的情况：</p>
<ul>
<li>当前算出来的比原来的优</li>
<li>当前跑出来的rand值比原来优</li>
</ul>
<details>
<summary>
固定格式
</summary>
<pre><code>T = 19260, delta = 0.998
while (T > 1e-6)
&#123;
   //do sth...
   T *= delta;
&#125;
</code></pre>
</details>
<p>第三道是点分治</p>
<p>算上主函数一共十个函数。。。</p>
<ul>
<li><p><span class="math inline">\(main\)</span>里面初始化的时候<span
class="math inline">\(f[rt] = yhm_{size} =
n\)</span>初始化必须把f包含</p></li>
<li><p><span class="math inline">\(getroot\)</span>找重心，使之成为<span
class="math inline">\(log\)</span></p></li>
<li><p><span class="math inline">\(solve\)</span>函数<span
class="math inline">\(siz[rt] = yhm_size =
siz[y]\)</span>，所谓的根一直都在更新，并且每次只会进入根（重心）</p></li>
<li><p><span
class="math inline">\(dfs\)</span>函数把当前的小子树遍历一遍，并用一个二元组记录了这个节点到1的距离且来自哪里</p></li>
<li><p><span
class="math inline">\(cmp\)</span>函数把二元组以距离为关键字排序了</p></li>
<li><p><span class="math inline">\(work\)</span></p></li>
</ul>
<p>首先把自己的儿子们的重心以及他们的大小都遍历出来</p>
<p>二元组多一位是防止边界出锅</p>
<p>然后就是双指针查找</p>
<ul>
<li><span
class="math inline">\(search\)</span>函数是在二分查找第一个小与等于<span
class="math inline">\(a[i] - dis[l].d\)</span>的值</li>
</ul>
<p>保证是<span class="math inline">\(log\)</span></p>
<p>第四道是树链剖分</p>
<p>以前没有做过，也没有学会</p>
<p>今天先透彻了思想，写了一道模板题目（将近200行…</p>
<p>本质是把树上问题转化为序列问题</p>
<p>然后在序列上跑线段树</p>
<p>考虑四个操作</p>
<ul>
<li>将树从x到y结点最短路径上所有节点的值都加上z</li>
<li>求树从x到y结点最短路径上所有节点的值之和</li>
<li>将以x为根节点的子树内所有节点值都加上z</li>
<li>求以x为根节点的子树内所有节点值之和</li>
</ul>
<p>肯定首先要预处理一些东西</p>
<p>跑第一遍<span class="math inline">\(dfs\)</span>处理出<span
class="math inline">\(dep,son,fa,siz\)</span>就是各个节点的深度，自己的重儿子，自己的父亲，自己的节点大小</p>
<p>第二遍<span
class="math inline">\(dfs\)</span>处理出了重儿子轻儿子的编号，以及各个链的链顶是谁</p>
<p>考虑初始化建立线段树</p>
<p>其次对于第一个和第二个操作</p>
<p>当我们要处理任意两点间路径时，设所在链顶端的深度更深的那个点为x点</p>
<ul>
<li>ans加上x点到x所在链顶端 这一段区间的点权和</li>
<li>把x跳到x所在链顶端的那个点的上面一个点</li>
</ul>
<p>不停执行这两个步骤，直到两个点处于一条链上，这时再加上此时两个点的区间和即可</p>
<p>然后跑完这个之后，还要比较一下，把最后那条<span
class="math inline">\(x,y\)</span>同在的链算上答案</p>
<p>其中加权操作与查询操作同理</p>
<p>对于第三个和第四个操作</p>
<p>显然，这一段区间是连续的，考虑左边界为x所在的位置（<span
class="math inline">\(id\)</span>）</p>
<p>显然，右边界就是<span class="math inline">\(id[x] + siz[x] -
1\)</span>，减1是因为<span
class="math inline">\(siz[x]\)</span>包含了x本身</p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title>9.9集训</title>
    <url>/2020/09/09/9.9/</url>
    <content><![CDATA[<p>今天做了三个题 <span id="more"></span> 第一个是一个数位dp</p>
<p>吉哥系列故事——恨7不成妻 HDU - 4507</p>
<p>考虑三个条件</p>
<ul>
<li>整数某一位是7</li>
</ul>
<p>简单，直接continue</p>
<ul>
<li>整数的每一位加起来的和是7的整数倍</li>
</ul>
<p>维护一个sum即可</p>
<ul>
<li>这个整数是7的整数倍</li>
</ul>
<p>当前枚举的数i，是第pos位，那么对求和的贡献就是<span
class="math inline">\(i*10^{pos}\)</span></p>
<p>则对于一个pos位的与7无关的数X有<span class="math inline">\(X=(
A\times10 ^
{pos}+B)^2\)</span>,A是你当前pos位枚举的值，B是一个子问题，展开得到<span
class="math inline">\(A \times A \times 10 ^ 2 \times pos+2 \times A
\times 10 ^{pos} \times B+B^2\)</span></p>
<p>第二个是壮压dp</p>
<p>P2704 [NOI2001]炮兵阵地</p>
<ul>
<li>空间不够</li>
</ul>
<p>需要用滚动数组，因为是状态压缩两行，所以我们<span
class="math inline">\(i\%3\)</span></p>
<ul>
<li><p>预处理</p></li>
<li><p>考虑能放的条件</p></li>
</ul>
<p><span class="math inline">\(j\)</span>&amp;<span
class="math inline">\((j&lt;&lt;1\;or\;2)\)</span></p>
<p>1位是左边一格子，2位是左边两格子</p>
<p><span class="math inline">\(dp[L][S][i]\)</span>表示当前状态是
S，上一行的状态是 L，当前考虑到了第 i 行</p>
<p><span
class="math inline">\(dp[L][S][i]=max(dp[L][S][i],dp[FL][L][i-1]+Sum[S])\)</span>
这里 FL 表示上上行的状态，Sum[S] 表示当前状态 S 里面包含几个 1</p>
<ul>
<li>判断每个位置是不是山丘</li>
</ul>
<p>只要把每一行的输入都转成一个二进制数(平原是
0，山丘是1)，然后直接跟待判断的状态做一次位运算即可，就是
S&amp;a[i]，如果位运算结果不是零，说明有些位置放在了山丘上，也就是说当前状态不合法</p>
<p>第三个题是区间dp</p>
<p>P5336 [THUSC2016]成绩单</p>
<p>设<span class="math inline">\(f[l][r][x][y]\)</span>表示区间<span
class="math inline">\([l,r]\)</span>没取走的当中最大的是y,最小的是x的最小代价</p>
<p>考虑转移：</p>
<ul>
<li>从<span
class="math inline">\([l,r-1]\)</span>转移，就是把这个归为上一个的那一砣</li>
<li>考虑枚举一个k，<span class="math inline">\(f[l][r][x][y] =
min(f[l][r][x][y], f[l][k][x][y] + g[k + 1][r])\)</span></li>
<li><span class="math inline">\(g[k+1][r]\)</span>表示<span
class="math inline">\(min(f[k+1][r][x][y])\)</span></li>
</ul>
<p>还有个坑点：离散化</p>
<p>闲散时间D昨天树剖的bug</p>
<p>找到漏洞：</p>
<ul>
<li>query函数没写return</li>
<li>跳的时候是top数组</li>
<li>两个dfs的名字不要互相引用</li>
<li>读入字符和数字都有的时候，不能用快读！！！</li>
<li>取最大值的时候，一定要给res赋极小值</li>
</ul>
<p>如果出题人卡你负数，就凉了</p>
<p>Seating G</p>
<p>考虑down的时候</p>
<p><strong>如果tag为0就要return</strong></p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP-S2020第二轮总结</title>
    <url>/2020/11/09/CSP-S2020%E7%AC%AC%E4%BA%8C%E8%BD%AE%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>这是一篇考后的反思与总结 <span id="more"></span></p>
<p><strong>T1</strong></p>
<p>上来看题目花了0.5h（加上配置Vim和写freopen共花费了花了0.75h），看完题目有思路之后准备着手写代码的时候已经过去将近1h了</p>
<p>灾难就此发生，原计划是1h/1t，现在已经超过了预期时间，<strong>此时最优策略是抛弃当前这个题，理理头绪接着按原计划进行考试，这样对于之后的每个题我都不用紧张，有足够的时间去想正解写暴力打对拍</strong></p>
<p>但是当时脑袋一热，冲！</p>
<p>于是又在第一题花了1h实现代码</p>
<p>T1写的差不多的时候，整场考试已经过去一半了</p>
<p><strong>其实如果发现题意很羞涩难懂，可以先跳过，先做别的</strong></p>
<p>T2</p>
<p>写完T1去了趟厕所，针对当前状况冷静分析一波：目前我已经把T2的时间用来写T1了，也就是说，我还有2h，要写3个题的暴力！！！</p>
<p>又突然意识到<strong>这次不是模拟考试</strong>！！！心态于是开始发生了巨大变化</p>
<p><strong>格外</strong>紧张的读T2题面，感觉可做，但是时间不允许我做</p>
<p>于是写暴力，过了两个样例，我甚至没有时间自己手造样例</p>
<p>只好把自己的代码的几个与答案有关的中间变量输出了一下，肉眼差错</p>
<p>T3</p>
<p>你中有我？我中有你？一眼不可做</p>
<p>维护单点修改，区间修改？要写线段树吗？</p>
<p>太浪费时间了，算了直接for吧</p>
<p>写完之后看到n=10的一个样例过了心里略微很稳</p>
<p>T4</p>
<p>“绝对聪明”，博弈论吗？但是怎么那么像贪心啊？</p>
<p>于是开始码，咦，为什么我第二个样例过不去啊</p>
<p>我慌了，我怀疑自己第一个样例估计也是假了</p>
<p>于是开始dddd…</p>
<p>直到end也没能把第二个样例调出来只好交上只过了样例一的代码</p>
<p>在6点29分的时候我删掉了调试痕迹，并在检查freopen无误后用颤抖的手完成了压缩包的解压</p>
<hr />
<p>总的来说，这次应有以下几点注意：</p>
<ul>
<li>1.看数据点开ll</li>
<li>2.合理分配时间</li>
</ul>
<p>给自己<strong>强制</strong>规定好对一个题的时间限度，超过了预期时间无论做没做出来都要<strong>果断</strong>弃坑</p>
<p>平均1h/1t
如果这个题目做的时间超过了1.25h且<strong>对于达到自己对此题的预期分数还有较大难度</strong>就弃疗</p>
<p>碰到大模拟或者理解题意就很费劲的题目就<strong>暂时</strong>跳过</p>
<ul>
<li><strong>3.做题策略&gt;做题细节&gt;做题能力</strong></li>
</ul>
<p>如何评价这次考试题目？</p>
<p><img
src="https://pic.downk.cc/item/5fa8f0d91cd1bbb86b758455.png" /></p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title>CF888E</title>
    <url>/2020/09/21/CF888E/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/CF888E">click</a></p>
<p>今天听了钟皓曦大神的讲解，扫了一眼题解区，大家都是在论述折半搜索
<span id="more"></span>
但是对于排完序之后的数组，进行互相匹配的时候，几乎说的都不是太透彻（个人观点，随便来喷）</p>
<p>于是我决定写一篇较为详细且严谨的题解</p>
<p>考虑当前有一个p属于对于前一半进行dfs得到的数组里面的一个数字，</p>
<p>考虑当前有一个q属于对于后一半进行dfs得到的数组里面的一个数字，</p>
<p>显然，我们知道：<span
class="math inline">\(p&lt;m,q&lt;m\)</span>，因此可以推出<span
class="math inline">\(p+q&lt;2\times m\)</span></p>
<p>我们也知道我们的答案是<span
class="math inline">\((p+q)\;mod\;m\)</span>，因此需要来讨论<span
class="math inline">\(p+q\)</span>的大小对m造成的影响</p>
<p>第一种情况：</p>
<ul>
<li><span class="math inline">\(m&lt;p+q&lt;2\times m\)</span></li>
<li>此时显然<span
class="math inline">\(p+q\)</span>往大里取最好，因为取的值越大，在<span
class="math inline">\(mod\;m\)</span>之后所得到的结果越大</li>
</ul>
<p>第二种情况：</p>
<ul>
<li><span class="math inline">\(p+q&lt;m\)</span></li>
<li><span
class="math inline">\(O(n^2)\)</span>匹配来找答案，显然不优，此时需要搞一个双指针来优化</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(sum1 + <span class="number">1</span>, sum1 + cnt1 + <span class="number">1</span>), <span class="built_in">sort</span>(sum2 + <span class="number">1</span>, sum2 + cnt2 + <span class="number">1</span>);</span><br><span class="line">l = cnt1, r = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (r = <span class="number">1</span>; r &lt;= cnt2; ++ r)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">while</span> (sum1[l] + sum2[r] &gt;= mod) -- l;</span><br><span class="line">   res = <span class="built_in">max</span>(res, sum1[l] + sum2[r]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将两个数组排序，初始化的时候l指向sum1数组的末尾（最大值），r指向sum2数组的开头（最小值）</p>
<p>考虑对于sum2数组中的每一个数字，在sum1中找到某一个数字，使得两者加起来在小于m的情况下最大</p>
<p>具体实现见代码。</p>
<p>此外，给出证明：由于sum1与sum2数组是递增序列，所以一遍扫过来，找到的一定是最优解</p>
<p>如果<span class="math inline">\(sum1[l] +
sum2[r]&gt;m\)</span>，显然，<span class="math inline">\(sum1[l]
+sum2[r+1]\)</span>也一定是大于m的，l递减显然没有问题</p>
<p>代码给出:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//东方之珠 整夜未眠！</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e7</span>+<span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt1, cnt2, n, mid, m;</span><br><span class="line"><span class="type">int</span> sum1[N], sum2[N], a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> now, <span class="type">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (now &gt; mid) &#123;sum1[++ cnt1] = sum; <span class="keyword">return</span>;&#125;</span><br><span class="line">   <span class="built_in">dfs1</span>(now + <span class="number">1</span>, sum);</span><br><span class="line">   <span class="built_in">dfs1</span>(now + <span class="number">1</span>, (sum + a[now]) % m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> now, <span class="type">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (now &gt; n) &#123;sum2[++ cnt2] = sum; <span class="keyword">return</span>;&#125;</span><br><span class="line">   <span class="built_in">dfs2</span>(now + <span class="number">1</span>, sum);</span><br><span class="line">   <span class="built_in">dfs2</span>(now + <span class="number">1</span>, (sum + a[now]) % m); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> i, l, r, <span class="built_in">res</span>(<span class="number">0</span>);</span><br><span class="line">   <span class="built_in">scanf</span> (<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, a + i), a[i] %= m;</span><br><span class="line">   mid = (n &gt;&gt; <span class="number">1</span>);</span><br><span class="line">   <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>), <span class="built_in">dfs2</span>(mid + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">   <span class="built_in">sort</span>(sum1 + <span class="number">1</span>, sum1 + cnt1 + <span class="number">1</span>), <span class="built_in">sort</span>(sum2 + <span class="number">1</span>, sum2 + cnt2 + <span class="number">1</span>);</span><br><span class="line">   l = cnt1, r = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (r = <span class="number">1</span>; r &lt;= cnt2; ++ r)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">while</span> (sum1[l] + sum2[r] &gt;= m) -- l;</span><br><span class="line">      res = <span class="built_in">max</span>(res, sum1[l] + sum2[r]);</span><br><span class="line">   &#125;</span><br><span class="line">   res = <span class="built_in">max</span>(res, (sum1[cnt1] + sum2[cnt2]) % m);</span><br><span class="line">   cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>IncDecSequence</title>
    <url>/2022/10/17/IncDecSequence/</url>
    <content><![CDATA[<p>题目大意：对于给定序列，每次可以选取一段区间进行统一的加一或者减一，Q1最少操作多少次可以使得整个序列数字统一。Q2最终可以得到多少种结果。<span id="more"></span></p>
<p>对于区间操作，容易想到差分</p>
<p>所以我们就可以把问题转化了，对于该序列的差分序列以及第<span
class="math inline">\(c_{n+1}\)</span>项，如何使得除了<span
class="math inline">\(c_1\)</span>之外的项全为0</p>
<p>对于每次的选取区间，我们可以发现无非三种有意义的做法</p>
<blockquote>
<p><span class="math inline">\(c_2\)</span>至<span
class="math inline">\(c_n\)</span>，保证其一正一负的条件下，尽可能多的使用该方法</p>
<p><span class="math inline">\(c_1\)</span>与<span
class="math inline">\(c_i\)</span></p>
<p><span class="math inline">\(c_i\)</span>与<span
class="math inline">\(c_{i+1}\)</span></p>
</blockquote>
<p>设<span class="math inline">\(c_2\)</span>至<span
class="math inline">\(c_n\)</span>中正数和为p，负数和为q，通关正负配对的方式（也就是尽量用第一种方法）可以执行<span
class="math inline">\(min(p,q)\)</span>次</p>
<p>对于剩下的<span class="math inline">\(\left| p -
q\right|\)</span>个没有配对的，每一个可以选择与<span
class="math inline">\(c_1\)</span>或者<span
class="math inline">\(c_{n+1}\)</span>配对共需要<span
class="math inline">\(\left| p-q \right|\)</span></p>
<p>所以最少需要操作<span class="math inline">\(max(p,q)\)</span>次</p>
<p>然后考虑有多少种不同的合法序列</p>
<p>也就是来判断有多少个不同的<span
class="math inline">\(b_1\)</span>，有<span class="math inline">\(\left|
p-q \right| + 1\)</span>个不同的值</p>
<p>加1是因为其本身不变的话，也是一种情况。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * By Youngore</span></span><br><span class="line"><span class="comment"> * Time:22.10.17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N], c[N];</span><br><span class="line"><span class="type">int</span> num, tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">youngore</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, i; <span class="built_in">scanf</span> (<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span> (<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        c[i] = a[i] - a[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (c[i] &gt; <span class="number">0</span>) tot += c[i];</span><br><span class="line">        <span class="keyword">else</span> num -= c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(tot, num) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">abs</span>(tot-num) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> thestars = <span class="built_in">youngore</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Review</category>
      </categories>
      <tags>
        <tag>基本算法</tag>
      </tags>
  </entry>
  <entry>
    <title>How Many Answers Are Wrong</title>
    <url>/2020/12/01/How%20Many%20Answers%20Are%20Wrong/</url>
    <content><![CDATA[<p>题目大意:给定一些区间的和,如果发现与前面矛盾就认为是假话.<span id="more"></span></p>
<p>来源:<a href="http://acm.hdu.edu.cn/showproblem.php?pid=3038">How
Many Answers Are Wrong</a></p>
<p>带权并查集判错的经典例题,直到如今才学会.</p>
<p>这个算法实在是太经典了,所以我要十分详细的把自己掌握的写出来,方便自己和后人查阅,在此感谢<a
href="https://blog.csdn.net/Dextrad_ihacker/article/details/51016017">这篇题解的详细指导</a></p>
<h3 id="为什么要用并查集">为什么要用并查集?</h3>
<p>对于通常的并查集例题,都是一开始每个元素构成一个单元素集合.其后不断合并.</p>
<p>与这题联系起来便十分抽象,因为我们要判断真假,怎么判?肯定是比较.怎么比?跟谁比?比什么?</p>
<p>怎么比:假设当前输入a,b,v与之前所有输入的a,b,v相比,存在a=a,b=b,v=v,则说明没错,</p>
<p>但是一定能找到吗?如果找不到,说明一定是错吗?显然不是,因此不能这么比.</p>
<p>要想比,首先得找一个基准值,如果(a到c的距离) - (b到c的距离) ==
v,说明正确,解决了跟谁比,怎么比.</p>
<h3 id="具体思路">具体思路:</h3>
<p>给出一个闭区间<span class="math inline">\([a,b]\)</span>,转化为:<span
class="math inline">\((a-1,b]\)</span>,因为半开半闭区间有个性质:<span
class="math inline">\((a,b] + (b,c] = (a,c]\)</span></p>
<p>再来考虑如何解读一条信息:a,b,v?可以解读为:a与b有关系,关系的权值是一个v</p>
<p>但是如何求ac,bc之间的距离,首先保证a,b的基准值都是c才可以,怎么把a,c的基准值都为c?</p>
<p><strong>考虑到并查集是用来记录联通关系的.</strong></p>
<p>如果当前两个点的基准值不一样,说明本条信息一定是正确的,因为无法根据其现有数据推算正假,于是认其为真.之后合并当前信息,为下一次查询做准备.</p>
<p>如果当前两个点的基准值一样,那么说明两个点之间的距离可以通过之前的计算出来,则比较,相等没事,不相等的话计数器加1</p>
<p>更清晰的话,有如下图表示:</p>
<p><img
src="https://pic.downk.cc/item/5fc6bf316ea9a3b5483ab67a.png" /></p>
<p>用sum[k]表示k到k的基准点之间距离.</p>
<p>如果想合并a,b,最终目的是求a,b到共同基准值的距离.</p>
<p>首先求出a,b的祖先,然后比较x,y默认x认y为爹(a的祖先认b的祖先为爹)</p>
<p>所以a的祖先变成了y,x的祖先变成了y.</p>
<p>其中显然: <span class="math display">\[
sum[x] = sum[b] + v - sum[a]
\]</span></p>
<p><span
class="math inline">\(sum[b]+v\)</span>是a到y的距离,减去a到x的距离<span
class="math inline">\(sum[x]\)</span>剩下的就是x到y的距离.(<strong>这里的区间都是左闭右开</strong>)</p>
<p>至此,代码与思路就都十分清晰了.</p>
<p>代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, res;</span><br><span class="line"><span class="type">int</span> a[N], fa[N], sum[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">yhm_find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">yhm_find</span>(fa[x]);</span><br><span class="line">    sum[x] = sum[x] + sum[fa[x]];</span><br><span class="line">    <span class="keyword">return</span> fa[x] = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">yhm_clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(fa, <span class="number">0</span>, <span class="keyword">sizeof</span> fa);</span><br><span class="line">    <span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span> sum);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">yhm_func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, l, r, k, x, y;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) fa[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        l = <span class="built_in">read</span>(), r = <span class="built_in">read</span>(), k = <span class="built_in">read</span>();</span><br><span class="line">        x = <span class="built_in">yhm_find</span>(l - <span class="number">1</span>), y = <span class="built_in">yhm_find</span>(r);</span><br><span class="line">        <span class="keyword">if</span> (x != y)</span><br><span class="line">        &#123;</span><br><span class="line">            fa[x] = y;</span><br><span class="line">            sum[x] = sum[r] - sum[l - <span class="number">1</span>] + k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sum[l - <span class="number">1</span>] - sum[r] != k) ++ res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(<span class="built_in">put</span>(res));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span> (<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">yhm_clear</span>();</span><br><span class="line">        <span class="built_in">yhm_func</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后记:</p>
<p>并查集经典应用</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>DIY手工</title>
    <url>/2020/10/26/DIY%E6%89%8B%E5%B7%A5/</url>
    <content><![CDATA[<p>题目大意：H 小姐的生日很快就要到了，小 Z 还在思索应该送 H
小姐什么生日礼物才好。送化妆品太贵，送巧克力又太俗了……突然，小 Z
灵机一动，打算做一个 diy 手工以显诚意。<span id="more"></span></p>
<p>小 Z 找来了好多长度为 N
的冰棒棍，他打算把这些冰棒棍切割成若干段，然后拼接成一个个长方体，然后再用这些长方体垒成城堡。然而，小
Z 却开始为长方体长宽高的选取而烦恼：设长方体的长宽高分别为
L,W,H，为了更好地利用这些长度为 N 的冰棒棍，小 Z
希望把这些冰棒棍分为四组，其中第一组都能恰好切割成若干段长（L 整除
N），第二组切割成若干段宽（W 整除 N），第三组切割成若干段高（H 整除
N），最后一组恰好切割成长宽高各一段（N=L+W+H）。现在，小 Z
好奇，拼成的长方体，体积最大是多少？</p>
<p>H小姐。。。</p>
<p>简化题面：在n中找三个约数a,b,c，使得a+b+c=n，求max(a<em>b</em>c)=？</p>
<p>显然是个找规律的题目，考虑<span class="math inline">\(n\leq
2\)</span>肯定不合适</p>
<p>所以继续拓展，<span
class="math inline">\(n=3\)</span>（1，1，1）可以,<span
class="math inline">\(n=4\)</span>（1，1，2）可以，<span
class="math inline">\(n=5\)</span>不可以，<span
class="math inline">\(n=6\)</span>（2，2，2）3的倍数，当然可以</p>
<p>以此类推，素数显然不合适，然后就可以发现，如果一个数字不是3的倍数也不是4的倍数，那么他一定不合适，3的倍数平均分，4的倍数1，1，2</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> T, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">solve</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x % <span class="number">3</span> != <span class="number">0</span> &amp;&amp; x % <span class="number">4</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x % <span class="number">3</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1ll</span> * x / <span class="number">3</span> * x / <span class="number">3</span> * x / <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1ll</span> * x / <span class="number">2</span> * x / <span class="number">4</span> * x/ <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span> (T --)</span><br><span class="line">    &#123;</span><br><span class="line">        n = <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">put</span>(<span class="built_in">solve</span>(n));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在n中找三个约数a,b,c，使得a+b+c=n </span></span><br><span class="line"><span class="comment">求max(a*b*c)=?</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>总结：</p>
<p>这次考试期望得分：60+70+？=130pts</p>
<p>实际得分：30+100+0=130pts</p>
<p>世事难料，却又是如此巧妙</p>
<p>第一题没开ll挂了三十分，第二题写个暴力调都没调直接压正解</p>
<p>第三题？神仙？</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>Splay</title>
    <url>/2020/07/04/Splay/</url>
    <content><![CDATA[<span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Splay</span> &#123;</span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">      node *ch[<span class="number">2</span>], *fa; <span class="type">int</span> val, size;</span><br><span class="line">      <span class="built_in">node</span> (node *fa = <span class="literal">NULL</span>, <span class="type">int</span> val = <span class="number">0</span>) : <span class="built_in">fa</span>(fa), <span class="built_in">val</span>(val) &#123;ch[<span class="number">0</span>] = ch[<span class="number">1</span>] = <span class="literal">NULL</span>; size = <span class="number">1</span>;&#125;</span><br><span class="line">      <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isr</span> <span class="params">()</span> </span>&#123; <span class="keyword">return</span> fa -&gt; ch[<span class="number">1</span>] == <span class="keyword">this</span>;&#125;</span><br><span class="line">      <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">up</span> <span class="params">()</span> </span>&#123; size = (ch[<span class="number">0</span>] ? ch[<span class="number">0</span>] -&gt; size : <span class="number">0</span>) + (ch[<span class="number">1</span>] ? ch[<span class="number">1</span>] -&gt; size : <span class="number">0</span>) + <span class="number">1</span>;&#125;</span><br><span class="line">      <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">rnk</span> <span class="params">()</span> </span>&#123; <span class="keyword">return</span> (ch[<span class="number">0</span>] ? ch[<span class="number">0</span>] -&gt; size : <span class="number">0</span>) + <span class="number">1</span>;&#125;</span><br><span class="line">   &#125;*root, pool[N], *tail, *st[N];</span><br><span class="line">   <span class="type">int</span> top;</span><br><span class="line">   <span class="built_in">Splay</span> () &#123; tail = pool; root = <span class="literal">NULL</span>; top = <span class="number">0</span>;&#125;</span><br><span class="line">   <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">rot</span> <span class="params">(node *x)</span> </span>&#123;</span><br><span class="line">      <span class="type">int</span> k = x -&gt; <span class="built_in">isr</span>();</span><br><span class="line">      node *y = x -&gt; fa, *z = y -&gt; fa, *w = x -&gt; ch[!k];</span><br><span class="line">      <span class="keyword">if</span> (y == root) root = x; <span class="keyword">else</span> z -&gt; ch[y-&gt;<span class="built_in">isr</span>()] = x;</span><br><span class="line">      x -&gt; fa = z, y -&gt; fa = x;</span><br><span class="line">      x -&gt; ch[!k] = y, y -&gt; ch[k] = w;</span><br><span class="line">      <span class="keyword">if</span> (w) w -&gt; fa = y;</span><br><span class="line">      y -&gt; <span class="built_in">up</span>(); x -&gt; <span class="built_in">up</span>();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">splay</span> <span class="params">(node *x)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (x != root) &#123;</span><br><span class="line">         <span class="keyword">if</span> (x -&gt; fa != root) <span class="built_in">rot</span> (x -&gt; <span class="built_in">isr</span>() ^ x -&gt; fa -&gt; <span class="built_in">isr</span>() ? x : x -&gt; fa);</span><br><span class="line">         <span class="built_in">rot</span> (x);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Insert</span> <span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!root) <span class="keyword">return</span> (<span class="type">void</span>) (root = <span class="built_in">new</span> (tail ++) <span class="built_in">node</span> (<span class="literal">NULL</span>, val));</span><br><span class="line">      node *x = root, *fa = <span class="literal">NULL</span>;</span><br><span class="line">      <span class="keyword">while</span> (x) &#123;</span><br><span class="line">    fa = x;</span><br><span class="line">         x = x -&gt; ch[val &gt; x -&gt; val];</span><br><span class="line">      &#125;</span><br><span class="line">      x = <span class="built_in">new</span> (tail ++) <span class="built_in">node</span> (fa, val);</span><br><span class="line">      fa -&gt; ch[val &gt; fa -&gt; val] = x; <span class="built_in">splay</span> (x);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function">node *<span class="title">merge</span> <span class="params">(node *x, node *y, node *fa)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (x) x -&gt; fa = fa;</span><br><span class="line">      <span class="keyword">if</span> (y) y -&gt; fa = fa;</span><br><span class="line">      <span class="keyword">if</span> (!x || !y) <span class="keyword">return</span> x ? x : y;</span><br><span class="line">      <span class="keyword">return</span> x -&gt; ch[<span class="number">1</span>] = <span class="built_in">merge</span> (x -&gt; ch[<span class="number">1</span>], y, x), x -&gt; <span class="built_in">up</span>(), x;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">del</span> <span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">      node *x = root;</span><br><span class="line">      <span class="keyword">while</span> (x &amp;&amp; x -&gt; val != val) x = x -&gt; ch[val &gt; x -&gt; val];</span><br><span class="line">      <span class="keyword">if</span> (x == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">splay</span>(x); </span><br><span class="line">    root = <span class="built_in">merge</span> (x -&gt; ch[<span class="number">0</span>], x -&gt; ch[<span class="number">1</span>], <span class="literal">NULL</span>);</span><br><span class="line">    st[++top] = x, x = <span class="literal">NULL</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">rnk</span> <span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">      node *x = root, *last = <span class="literal">NULL</span>; <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (x) &#123;</span><br><span class="line">    last = x;</span><br><span class="line">    <span class="keyword">if</span> (val &lt;= x -&gt; val) x = x -&gt; ch[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">else</span> res += x -&gt; <span class="built_in">rnk</span>(), x = x -&gt; ch[<span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">splay</span>(last), res + <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">kth</span> <span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">      node *x = root;</span><br><span class="line">      <span class="keyword">while</span> (x &amp;&amp; x -&gt; <span class="built_in">rnk</span>() != k) &#123;</span><br><span class="line">         <span class="keyword">if</span> (x -&gt; <span class="built_in">rnk</span>() &gt; k) x = x -&gt; ch[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">else</span> k -= x -&gt; <span class="built_in">rnk</span>(), x = x -&gt; ch[<span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">splay</span> (x), x -&gt; val;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">pre</span> <span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">kth</span>(<span class="built_in">rnk</span>(x)<span class="number">-1</span>);&#125;</span><br><span class="line">   <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">nxt</span> <span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">kth</span>(<span class="built_in">rnk</span>(x+<span class="number">1</span>));&#125;</span><br><span class="line">   <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Action</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="type">int</span> t;</span><br><span class="line">      <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">      <span class="keyword">while</span> (t --&gt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="type">int</span> opt, x;</span><br><span class="line">         <span class="built_in">scanf</span> (<span class="string">&quot;%d%d&quot;</span>, &amp;opt, &amp;x);</span><br><span class="line">    <span class="keyword">if</span> (opt == <span class="number">1</span>) <span class="built_in">Insert</span> (x);</span><br><span class="line">    <span class="keyword">if</span> (opt == <span class="number">2</span>) <span class="built_in">del</span> (x);</span><br><span class="line">    <span class="keyword">if</span> (opt == <span class="number">3</span>) <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">rnk</span>(x)); </span><br><span class="line">         <span class="keyword">if</span> (opt == <span class="number">4</span>) <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">kth</span>(x));</span><br><span class="line">    <span class="keyword">if</span> (opt == <span class="number">5</span>) <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">pre</span>(x));</span><br><span class="line">    <span class="keyword">if</span> (opt == <span class="number">6</span>) <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">nxt</span>(x));</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;yhm;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123; <span class="keyword">return</span> yhm.<span class="built_in">Action</span>(), <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关于splay的一些操作">关于Splay的一些操作</h2>
<p>1.$rot $</p>
<p><span class="math inline">\(k = x -&gt; isr()\)</span></p>
<p>以及后文一些关于<span class="math inline">\(ch[k]\)</span>或者<span
class="math inline">\(ch[!k]\)</span>的操作非常巧妙</p>
<p>回复数据的时候先<span class="math inline">\(y -&gt; up()\)</span>
然后再<span class="math inline">\(x -&gt; up()\)</span></p>
<p>因为x是y的爸爸</p>
<p>2.<span class="math inline">\(splay\)</span></p>
<p>有双链和单练之分 (防止退化成链)</p>
<p>ta与ta爹如果在同一个儿子的方向 就转一下ta爹</p>
<p>如果不在一个方向就转一下ta</p>
<p>3.关于<span class="math inline">\(del\)</span> <span
class="math inline">\(rnk\)</span> <span
class="math inline">\(kth\)</span></p>
<p>这几个函数写完之后需要记得splay一下</p>
<p>4.关于<span class="math inline">\(isr\)</span> <span
class="math inline">\(rnk\)</span> <span
class="math inline">\(up\)</span>几个函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isr</span> <span class="params">()</span> </span>&#123; <span class="keyword">return</span> fa -&gt; ch[<span class="number">1</span>] == <span class="keyword">this</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">up</span> <span class="params">()</span> </span>&#123; <span class="keyword">return</span> siz = (ch[<span class="number">0</span>] ? ch[<span class="number">0</span>] -&gt; siz : <span class="number">0</span>) + (ch[<span class="number">1</span>] ? ch[<span class="number">1</span>] -&gt; siz : <span class="number">0</span>) + <span class="number">1</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">rnk</span> <span class="params">()</span> </span>&#123; <span class="keyword">return</span> (ch[<span class="number">0</span>] ? ch[<span class="number">0</span>] -&gt; siz : <span class="number">0</span>) + <span class="number">1</span>;&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学后感</category>
      </categories>
      <tags>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title>P3928 一道简单题</title>
    <url>/2020/10/18/P3928-%E4%B8%80%E9%81%93%E7%AE%80%E5%8D%95%E9%A2%98/</url>
    <content><![CDATA[<p>题目大意：yhm拿到一个 3×n
的数组，要在每一列选一个数（或者不选）。<span id="more"></span>满足以下条件：（1）如果在第一行选，那它必须大于等于上一个数（2）如果在第二行选，那么必须小于等于上一个数（3）如果在第三行选，对于连续的一段在第三行选的数，必须满足方向相同（都小于等于上一个数或者都大于等于上一个数）</p>
<p>显然可以搞出四个状态，然后n方转移</p>
<p>但是这个是最大值，所以可以用树状数组或者线段树优化成<span
class="math inline">\(n\times log n\)</span></p>
<p>但是优化我不会，留坑待填</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, res;</span><br><span class="line"><span class="type">int</span> a[<span class="number">6</span>][N], f[N][<span class="number">6</span>];</span><br><span class="line"><span class="type">int</span> b[N * <span class="number">3</span>], tree[<span class="number">6</span>][N * <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x &amp; (-x))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">chenge</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; x &lt;= m; x += <span class="built_in">lowbit</span>(x)) tree[k][x] = <span class="built_in">max</span>(tree[k][x], val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; x; x -= <span class="built_in">lowbit</span>(x)) ret = <span class="built_in">max</span>(ret, tree[k][x]);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            b[(i - <span class="number">1</span>) * n + j] = a[i][j] = <span class="built_in">read</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + n * <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    m = <span class="built_in">unique</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + n * <span class="number">3</span>) - b - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i][j] = <span class="built_in">lower_bound</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + m, a[i][j]) - b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][<span class="number">0</span>] = <span class="built_in">query</span>(<span class="number">0</span>, a[<span class="number">1</span>][i]) + <span class="number">1</span>;</span><br><span class="line">            f[i][<span class="number">1</span>] = <span class="built_in">query</span>(<span class="number">1</span>, m - a[<span class="number">2</span>][i] + <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            f[i][<span class="number">2</span>] = <span class="built_in">query</span>(<span class="number">2</span>, a[<span class="number">3</span>][i]) + <span class="number">1</span>;</span><br><span class="line">            f[i][<span class="number">3</span>] = <span class="built_in">query</span>(<span class="number">3</span>, m - a[<span class="number">3</span>][i] + <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">chenge</span>(<span class="number">0</span>, a[<span class="number">1</span>][i], f[i][<span class="number">0</span>]);</span><br><span class="line">            <span class="built_in">chenge</span>(<span class="number">0</span>, a[<span class="number">2</span>][i], f[i][<span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">chenge</span>(<span class="number">0</span>, a[<span class="number">3</span>][i], <span class="built_in">max</span>(f[i][<span class="number">2</span>], f[i][<span class="number">3</span>]));</span><br><span class="line">            <span class="built_in">chenge</span>(<span class="number">1</span>, m - a[<span class="number">1</span>][i] + <span class="number">1</span>, f[i][<span class="number">0</span>]);</span><br><span class="line">            <span class="built_in">chenge</span>(<span class="number">1</span>, m - a[<span class="number">2</span>][i] + <span class="number">1</span>, f[i][<span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">chenge</span>(<span class="number">1</span>, m - a[<span class="number">3</span>][i] + <span class="number">1</span>, <span class="built_in">max</span>(f[i][<span class="number">2</span>], f[i][<span class="number">3</span>]));</span><br><span class="line">            <span class="built_in">chenge</span>(<span class="number">2</span>, a[<span class="number">1</span>][i], f[i][<span class="number">0</span>]);</span><br><span class="line">            <span class="built_in">chenge</span>(<span class="number">2</span>, a[<span class="number">2</span>][i], f[i][<span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">chenge</span>(<span class="number">2</span>, a[<span class="number">3</span>][i], f[i][<span class="number">2</span>]);</span><br><span class="line">            <span class="built_in">chenge</span>(<span class="number">3</span>, m - a[<span class="number">1</span>][i] + <span class="number">1</span>, f[i][<span class="number">0</span>]);</span><br><span class="line">            <span class="built_in">chenge</span>(<span class="number">3</span>, m - a[<span class="number">2</span>][i] + <span class="number">1</span>, f[i][<span class="number">1</span>]);</span><br><span class="line">            <span class="built_in">chenge</span>(<span class="number">3</span>, m - a[<span class="number">3</span>][i] + <span class="number">1</span>, f[i][<span class="number">3</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">max</span>(res, <span class="built_in">max</span>(<span class="built_in">max</span>(f[i][<span class="number">0</span>], f[i][<span class="number">1</span>]), <span class="built_in">max</span>(f[i][<span class="number">2</span>], f[i][<span class="number">3</span>])));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">put</span>(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动规</tag>
      </tags>
  </entry>
  <entry>
    <title>P7043「MCOI-03」村国</title>
    <url>/2020/10/31/P7043%E3%80%8CMCOI-03%E3%80%8D%E6%9D%91%E5%9B%BD/</url>
    <content><![CDATA[<p>题面大意：一棵树，每次选择一个权值最大的点（特别的，若有多个权值相同的点，则选择编号最小的），并令周围的一圈点权值都加一，操作m次，最终权值最大的那个节点是哪个？其中m属于1e18<span id="more"></span></p>
<p>如此之大的数据量启示我们找规律或者矩阵乘法，显然此题没办法矩乘，所以只能找规律</p>
<p>考虑我们第一次找出来的最合适的点<span
class="math inline">\(fa\)</span>，考虑每次操作与<span
class="math inline">\(fa\)</span>最合适的儿子<span
class="math inline">\(son\)</span>权值的关系</p>
<p>1）当我即使用尽所有的次数，未能使得son与fa的权值相等，显然fa是最合适的</p>
<p>2）当son权值跟自己一样，但是操作次数已经用完了，显然这时候最优的点一定是自己与儿子之间编号最小的那个节点</p>
<p>3）当son权值跟自己一样，但是依然还有剩余的一些次数，显然，我的答案只可能在<span
class="math inline">\(fa\)</span>与<span
class="math inline">\(son\)</span>之间反复横跳，顾分奇偶来讨论。</p>
<p>（为了方便后续的讲解，此时我们比较fa与son编号的大小，如果发现fa编号大于son则交换fa与son，想一想，为什么？）</p>
<p>我们保证fa一定是<strong>当前</strong>合适的点。</p>
<ul>
<li>若剩下奇数次，答案是son</li>
<li>若剩下偶数次，答案是fa</li>
</ul>
<p>其实如果用文字来表示，恕我傻逼，难以表示清楚，但是我们可以举个特殊的例子来方便理解</p>
<p>奇数？1是奇数吧？我接下来再<strong>操作一次</strong>，一定是操作在fa上，结果就是使得son的权值比fa大一，所以答案是son；</p>
<p>偶数？0是偶数吧？我接下来<strong>不操作</strong>，我原先最合适的点不是fa吗，所以现在还是fa</p>
<p>证毕.</p>
<p>还有一个小细节，一个可以影响你九十分的小细节，<strong>请特判1</strong></p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">s</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">w</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) w = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) s = s * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s * w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (! x) <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">num</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="type">char</span> c[<span class="number">66</span>];</span><br><span class="line">    <span class="keyword">while</span> (x) c[++ num] = x % <span class="number">10</span> + <span class="number">48</span>, x /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (num) <span class="built_in">putchar</span>(c[num --]);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e6</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ver[N &lt;&lt; <span class="number">1</span>], nex[N &lt;&lt; <span class="number">1</span>], head[N], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++ cnt] = y;</span><br><span class="line">    nex[cnt] = head[x];</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(head[x] = cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> T, n, m, son, fa;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">yhm_clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt = fa = son = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span> a);</span><br><span class="line">    <span class="built_in">memset</span>(nex, <span class="number">0</span>, <span class="keyword">sizeof</span> nex);</span><br><span class="line">    <span class="built_in">memset</span>(ver, <span class="number">0</span>, <span class="keyword">sizeof</span> ver);</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">yhm_func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, x, y;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i] = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; a[fa]) fa = i;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[i] == a[fa] &amp;&amp; i &lt; fa) fa = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">add_edge</span>(x, y), <span class="built_in">add_edge</span>(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> (<span class="type">void</span>)(<span class="built_in">put</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (i = head[fa]; i; i = nex[i])</span><br><span class="line">    &#123;</span><br><span class="line">        y = ver[i];</span><br><span class="line">        <span class="keyword">if</span> (a[y] &gt; a[son]) son = y;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[y] == a[son] &amp;&amp; y &lt; son) son = y;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;fa--&gt;&quot; &lt;&lt; fa &lt;&lt; &quot; son--&gt;&quot; &lt;&lt; son &lt;&lt; &#x27;\n&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> (a[fa] - a[son] &gt; m) <span class="keyword">return</span> (<span class="type">void</span>)(<span class="built_in">put</span>(fa));</span><br><span class="line">    <span class="keyword">if</span> (a[fa] - a[son] == m) <span class="keyword">return</span> (<span class="type">void</span>)(<span class="built_in">put</span>(<span class="built_in">min</span>(fa, son)));</span><br><span class="line">    <span class="type">int</span> rest = m - (a[fa] - a[son]);</span><br><span class="line">    <span class="keyword">if</span> (fa &gt; son) <span class="built_in">swap</span>(fa, son);</span><br><span class="line">    <span class="keyword">if</span> (rest &amp; <span class="number">1</span>) <span class="keyword">return</span> (<span class="type">void</span>)(<span class="built_in">put</span>(son));</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(<span class="built_in">put</span>(fa));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span> (T --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">yhm_clear</span>();</span><br><span class="line">        <span class="built_in">yhm_func</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>找规律</tag>
      </tags>
  </entry>
  <entry>
    <title>Moo</title>
    <url>/2020/09/18/Moo/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1885">click</a></p>
<p>一道与<a
href="https://www.luogu.com.cn/problem/P5657">格雷码</a>类似的题目
<span id="more"></span> 先把前几个串的长度求出来，二分查找出属于哪一个串</p>
<p>然后递归求解就可以</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//东方之珠 整夜未眠！</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> x == <span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span>;<span class="comment">//递归边界</span></span><br><span class="line">   <span class="keyword">if</span> (x &lt;= s[k - <span class="number">1</span>]) <span class="keyword">return</span> <span class="built_in">dfs</span>(x, k - <span class="number">1</span>);<span class="comment">//属于左边的上一个串</span></span><br><span class="line">   <span class="keyword">if</span> (x &gt; s[k] - s[k - <span class="number">1</span>]) <span class="keyword">return</span> <span class="built_in">dfs</span>(x + s[k - <span class="number">1</span>] - s[k], k - <span class="number">1</span>);<span class="comment">//属于右边的上一个串</span></span><br><span class="line">   <span class="comment">// if (x &lt; s[k - 1] || x &gt; s[k - 1] + 3 + k) dfs(x, k - 1);</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (x == s[k - <span class="number">1</span>] + <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//中间的...特判就好</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">thestars</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> i, j, n;</span><br><span class="line">   s[<span class="number">0</span>] = j = <span class="number">3</span>;</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">30</span>; ++ i) s[i] = (s[i - <span class="number">1</span>] &lt;&lt; <span class="number">1</span>) + (++ j);</span><br><span class="line">   cin &gt;&gt; n;</span><br><span class="line">   j = <span class="built_in">lower_bound</span>(s + <span class="number">1</span>, s + <span class="number">28</span>, n) - s;</span><br><span class="line">   <span class="built_in">dfs</span>(n, j) == <span class="number">1</span> ? <span class="built_in">puts</span>(<span class="string">&quot;m&quot;</span>) : <span class="built_in">puts</span>(<span class="string">&quot;o&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> youngore = <span class="built_in">thestars</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br></pre></td></tr></table></figure>
<hr />
<p>后记</p>
<p>一年前坐在秦皇岛的考场上做格雷码，连打暴力加想正解，加各种调试，花了三个小时</p>
<p>如今正解+调试花了不到半个小时</p>
<p>一路走过来</p>
<p>才发现，我真的提高了</p>
<p>祝NOIP-2020全省Rank前3</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>TallestCows</title>
    <url>/2022/10/17/TallestCows/</url>
    <content><![CDATA[<p>题目大意：给定n个数字，其中已知某一个最大，并告知一些关系“哪些数字是小于某些区间端点的”，求合法序列下，数字的最大值。</p>
<span id="more"></span>
<p>对于区间处理问题，考虑差分，在需要操作的区间首端点处以及尾端点+1或者-1处进行标记处理一下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * By Youngore</span></span><br><span class="line"><span class="comment"> * Time:22.10.17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, p, h, m;</span><br><span class="line"><span class="type">int</span> d[N], c[N];</span><br><span class="line">map&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;, <span class="type">bool</span>&gt;existed;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">youngore</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i; <span class="built_in">scanf</span> (<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;p, &amp;h, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y; <span class="built_in">scanf</span> (<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span> (x &gt; y) <span class="built_in">swap</span>(x, y);</span><br><span class="line">        <span class="keyword">if</span> (existed[<span class="built_in">make_pair</span>(x, y)]) <span class="keyword">continue</span>;</span><br><span class="line">        existed[<span class="built_in">make_pair</span>(x, y)] = <span class="literal">true</span>;</span><br><span class="line">        d[x + <span class="number">1</span>] -= <span class="number">1</span>, d[y] += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        c[i] = c[i - <span class="number">1</span>] + d[i];</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;%d\n&quot;</span>, h + c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> thestars = <span class="built_in">youngore</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Review</category>
      </categories>
      <tags>
        <tag>基本算法</tag>
      </tags>
  </entry>
  <entry>
    <title>SublimeText3的相关操作</title>
    <url>/2020/08/28/SublimeText3%E7%9A%84%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<span id="more"></span>
<p>Crtl +</p>
<ul>
<li>Z 后退</li>
<li>X 剪切</li>
<li>C 复制</li>
<li>V 粘贴（shift + Insert也是粘贴）</li>
<li>B 编译运行</li>
<li>N 新建文档</li>
<li>M 在两个括号之间反复横踢</li>
<li>A 全选</li>
<li>S 保存</li>
<li>D
在Dev里面是删除一行，在sublime里是一个极其智能的快捷键，对着一个代码按一次Ctrl
+
D，会选中当前单词，再按几次，会显示出这个单词在文档里面出现在了那里</li>
<li>F 查找</li>
<li>G
你打上"#"或者"@"就会显示出所有函数与关键字如果什么不打，可以快速预览每个cpp的内容</li>
<li>H 也是查找</li>
<li>J 代码压行</li>
<li>K 打开/隐藏侧边栏</li>
<li>L 选中当前这一行</li>
<li>Q 录制宏，再按一次就是关闭（你用不到</li>
<li>W 关闭当前文档</li>
<li>E 不知道</li>
<li>R 见Ctrl+G</li>
<li>T 交换当前两个字符</li>
<li>Y 与Ctrl+Z相反</li>
<li>U 与Ctrl+U相同，用得少，因为莪不方便</li>
<li>I 查找</li>
<li>O 打开新文件</li>
<li>&lt;-或者-&gt; 智能跳跃相关内容</li>
</ul>
]]></content>
      <categories>
        <category>mess</category>
      </categories>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title>当一个人的痛苦大于ta能力的时候</title>
    <url>/2023/09/07/npy%E8%A1%A5%E8%80%83%E5%89%8D%E6%9F%90%E6%99%9A/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="39e191d1d6d45ca97797ebf6ffa2a9de16e348e96b3b463d01c8ebd7059d745f">6731bfde467a3339878a7bb5be9b716dc3994510d4fb0d3942966fc26cf31a21b5dbd849b756194d9771c3360f60a9b00da5ce10c15020c3cbbfb888ad342392d68b8e41097c1307bc78dbbb89ceb2246c476338b51b2ca5403a2e327008f7eb20f87e4793be21ddcdf4cc537b854d90b61445f248d6c50de6bf9fd1d39a249439fd11371a35ef90b1e9c0670af7800fca5d1bcd86dc37750da1c218e353c99a3fcaf7db2111688eb8c291f7b8c3f4555731c8a2056e39038bdc283299af80fad035f147aeaf8b4fa6ec851a22057beeb8d27dc83ba75553b2947b2f7e777614a42e759debeb89f0ceed065d912cc01726b5bcf14f7effe90728d3cb83c1c4b20e0b810fdbcdd7e9e72e7bad242b26ca4012137b4a7d6e697866dfa775f58b7d7d7d9e40c1b843d31b942d92adf5402b80b8669cb754ae30586e069185f77df435e54ab70263622bba6c4a9de3600ca82d614f9c86d05331699bdc12f3dd59c6188325a71616a2ed218de162f7549ff90ede9fd8566a4f7e1d0a52da4fbc2d88ca871955f18a7f39f77123826ff8c436adda8cf0a170f91b7bee4087c491a0b2e899c92f32683feec817405606979ffde0639bc6507ea4debd6e9c858389f071a618f99aa672882d895cb1a7acecf609fdc20cdefdf5b2d7033602cd5970b448a36fb4233217b2f3b0a35b3e956f3d7d98c587d0ec7fd70d115a3bcdcf11bf5f4a7130395e2e29346cceca74242f7a84ed5ced906473e2a7aaea3da501cca32de57ed212637ae99aae660beed9d6cf19f51811b9e0e3c2811a6023203129d0c49481ca26816261d6d9a2daaf999ed86c7d3eab80ba23c0b631808da447d3a05f1b3fd8788d4ca2ff1c69ed4ecba11ef2b06a440e0641fbfe82f4df2ce31deb784ff534f02958fa1c33a3e39730809b741f658e5b5fd1bcf2b34cd64e5d354e94bbf1345d8e29c294a6b3332615f284b414cf3a6664af9697e4858d46f050dec4b1ee70041c5efa6395d6ca7c722eb677a82d407f8a0133b387dbae1cf98cb3011278c6ee21674719b19243530d419fc6465003ae88de7316b7452d47b1438f60c661ec5a33a1a23de7e129d8143888e8040df4afff3b4ad8ccdd4d91b5815bdabc299ebfd86822f4de501f61ec048aa22ca1cb5752bb75be8a8e8931ea1b1e62d7995e88bb00cc605ef8a2ac8121c56f075960259ef751dc9849ac0302669475643a46f98175af25dd4224e8df4cbf4677b50a992c651b000b3b61cf21ea097c9ae51368f65dc28a90f5042b572a6fd7d35a29d4344784e1fad77af69cc695cbed0ed98b983f9f0d69cc25350cb6df32fd33cc156cee166067e19853475ff6aea38c7b31e4b711979d353621b0249222f529e9a159065ab27668f239ab2399e083d6267f2ebba2aa293a4fad577dd01bddae5fecb2e6457bb9ff928373622ef3a029edd2ffb8aea9da2dc695a3b999fd31711e9071943fefeb75875af484598ae645bd4e1cc2ff634b8c2e4655fee2dfbf19f41d52be00b43afa505e886b2209a120f5611e1e958a6958fe9372db0a05efe237e0af9d648c04f139f793802551cf54bb2614e511815f3e02481849fe0d5516d6c70655773f7715e0ef74bdf25efe3d3978d67e917013271f59e76d28299b32efffff55fad51316c8eb6a6279b2f5d11da86846b71eaec199ca18e557e7071721dbadac406ef97716ade6bd14baa3342d933bdddebc96d87e490174969054569051cace29bd5515b08404711a25d38c601c98eafdb1e61a0fce2263895e60bdc5a501ce60694f668cb615b2ab69c9eea3d6acf4eef7438a5c5f18c5204baf89e97df7a59b409ac55dbcbf57980b41851f25264c2748122f073de1f7776a2107d2850c2d2f75e55ff4ab46b15b16c4cfcfb9db888667bcaef896cfa3866709de5d526fc402a598d0549a6b9693987b2337e2a4a4055dc83a66404e85078ba9365a7eed576098cf30c2a025fd7a69d6540ff76e3eb52fea951c6e36b270eef344c247faf76c3ab5965502e215a41e3e0ea59444055f9ea62dc91ebb97a937f1f509ff107bbee9063ce098667c8b1fae10274afd544ba562544eb1b117db6fbf5309cd7cb90421c7c77e71bf47a898774b4a0835563d7163cc7d88c6794d05391e777c3352316f73b23eecdce539251eda224ac46d8d26207d01c98512137ff529e4976e2fad6d9edc773b8f1d7e3c31a36cb95d20c0668730a27964a450ea11db841d04a0aebdd127ca46c21ab78162a0f67f249abe107e8f0783f145ec597aff990e592eaa74f036c4e1f8348ecba821937b06215cc332b147c28b6d4886de3b91e9bbd0ac29611a29acb0785260efda8ea0fcfa08022d43fc37bf778eb01e0b1bfc0dd898eba343b9143fe839481141f355c717da815cddccf7347a5a2a22e3bc58dd42e1f80d1e13fe2675aae35f2331baf592781a0c4f038125d8e0ff980a8410d919389c7fba7a7e1542454ac6c0d12070fc83e86b5195642c4d0f0016b1ecb6510da859285c11e725d6c6a46dec673f7fa2871ebb16054207475fe351723a627c0a1147b32275b817e7f8d854f6b9547055231286fd92a001a9bcbd2489557c1612412d4dbcdbd5af3bf03f9589dd93bf8449e3cceef1e5dc783bca09b5cc90c0447d6c1764c176092275ee46461796ad87b4332260744f2bea9209</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>pywebsql的debug</title>
    <url>/2023/09/28/pywebsql%E7%9A%84debug/</url>
    <content><![CDATA[<p>debug <span id="more"></span></p>
<ul>
<li>index类中无POST</li>
</ul>
<p>从网页敲网址回车刷新后属于GET</p>
<p>重新刷新会重新提交表单属于POST</p>
<ul>
<li>翻译查English查不到</li>
</ul>
<p>样本过于少</p>
<ul>
<li><code>notice = "Not Found"</code> 没有正常显示</li>
</ul>
<p>空格&amp;tab</p>
<p>py中if的缩进 不出现空行</p>
<ul>
<li>前端网页空出一行</li>
</ul>
<p>从ppt往vscode中复制时候，有非法字符，无法识别 在句末没看到。。。</p>
<ul>
<li>vscode中运行py，不能正常显示图片问题</li>
</ul>
<p>敲命令行可以解决</p>
<ul>
<li>各种奇怪错误</li>
</ul>
<p><code>=</code> &amp; <code>==</code></p>
<p><code>,</code>存在与否</p>
<p><code>mysql</code>语句是否正确</p>
]]></content>
      <categories>
        <category>学后感</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>pyy整队</title>
    <url>/2020/10/13/pyy%E6%95%B4%E9%98%9F/</url>
    <content><![CDATA[<p>题目大意：pyy让班里n个同学先排好队。<span id="more"></span>站在队伍前端玩手机，前面的人少了，谁都顶不住。于是陆陆续续有人往队伍最后躲去，但大家都忘记了老师说前面位置有空缺要补齐的要求。一些同学还时不时地低头问向指挥队伍的班长pyy，排在自己前面成绩最好的同学是谁。这时老师来了，看着到处充满空缺的队伍，老师限pyy以最快的时间整顿队伍。体育老师看不出来队伍的位置后移了，老师只关心队伍是否整齐没有空缺。老师给了pyy一次移动一名同学的权力，因此pyy无法使用技能“向前看齐”。问你至少移动多少个同学可以使队伍整齐。</p>
<p>首先看见这个排名这么大，肯定要离散化一下，然后要求查询最小值，构造一个权值线段树就可以了，对于最后的移动同学，我们尝试维护一个长度为n
的滑动窗口，维护零的个数，然后就没了</p>
<p>对于往后挪动的同学，我们令他们的排名为++n就好了</p>
<p>注意：开ll！且在opt之后的那个数字也要开ll</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">666</span>, inf = <span class="number">214748360000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, num, res = inf;</span><br><span class="line"><span class="type">int</span> a[N], b[N], pos[N], vis[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SEGMENTTREE</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> minv;</span><br><span class="line">&#125;tree[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = p &lt;&lt; <span class="number">1</span>, r = (p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(tree[p].minv = <span class="built_in">min</span>(tree[l].minv, tree[r].minv));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> (<span class="type">void</span>)(tree[p].minv = pos[l]);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>((p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(<span class="built_in">up</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">updata</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> (<span class="type">void</span>)(tree[p].minv = val);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= mid) <span class="built_in">updata</span>(p &lt;&lt; <span class="number">1</span>, l, mid, k, val);</span><br><span class="line">    <span class="keyword">if</span> (k &gt; mid) <span class="built_in">updata</span>((p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>, mid + <span class="number">1</span>, r, k, val);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(<span class="built_in">up</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (tree[p &lt;&lt; <span class="number">1</span>].minv &lt; k) <span class="keyword">return</span> <span class="built_in">query</span>(p &lt;&lt; <span class="number">1</span>, l, mid, k);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>((p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>, mid + <span class="number">1</span>, r, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>(), num = n;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i] = <span class="built_in">read</span>();</span><br><span class="line">        b[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(b + <span class="number">1</span>, b + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i] = <span class="built_in">lower_bound</span>(b + <span class="number">1</span>, b + n + <span class="number">1</span>, a[i]) - b;</span><br><span class="line">        pos[a[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1e5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> opt[<span class="number">66</span>]; <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%s%lld&quot;</span>, opt, &amp;x);</span><br><span class="line">        x = <span class="built_in">lower_bound</span>(b + <span class="number">1</span>, b + n + <span class="number">1</span>, x) - b;</span><br><span class="line">        <span class="keyword">if</span> (opt[<span class="number">0</span>] == <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> y = <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1e5</span>, pos[x]);</span><br><span class="line">            <span class="keyword">if</span> (b[y] == <span class="number">0</span>) <span class="built_in">put</span>(<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">put</span>(b[y]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pos[x] = num + <span class="number">1</span>;</span><br><span class="line">            ++ num;</span><br><span class="line">            <span class="built_in">updata</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1e5</span>, x, pos[x]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) vis[pos[a[i]]] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">2e5</span>; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (! vis[i]) ++ ret;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; n) </span><br><span class="line">            <span class="keyword">if</span> (! vis[i - n])</span><br><span class="line">                -- ret;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= n) res = <span class="built_in">min</span>(res, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">put</span>(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：配上放爆竹那个题目，我期望得分是100+30pts，实际上是20+0pts，我第三题的思路其实是没有问题的，没时间来写了。</p>
<p>我发誓不做平庸的人！</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>V 神玩游戏</title>
    <url>/2020/11/03/V-%E7%A5%9E%E7%8E%A9%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<p>题目大意：把一个数字拆成多个互质数的和，每次拆分之后将质数相乘起来得到一个数字，如果以前未曾出现过，则这次计数器增加</p>
<p>问计数器最终为多少<span id="more"></span></p>
<p>来自Ame__大佬的讲解：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">解题思路:由唯一分解定理，任何一个数我们都可以拆成若干个质数相乘，题目要求的是将n分解成若干互质的数之和然后乘起来看有多少种不同的乘积，既然两两互质我们可以从互质出发，用质数来乘积最后。</span><br><span class="line"></span><br><span class="line">那么我们将问题转化成了将n分解成多少不同质数的组合，注意这里的组合不仅含质数还有1，因为1与其他的数gcd$均为1，即互质。</span><br><span class="line"></span><br><span class="line">那么我们设dp[i][j]表示从前i个质数里面组成和为j的组合的乘积数，考虑转移的话因为要求乘积不同的方案数，即求不同质数集合的方案数可知ans最多为不同的质数组合方案数个所以我们枚举的是质数的组合方案，这样保证了不同的乘积全都枚举到了，且只枚举了一次这样不会少枚举情况，因为枚举了所有的质数组合方案，所有的乘积都枚举到了。$dp[i][j]=\sum dp[i-1][j-k^p](p=0,1,2...)$</span><br><span class="line"></span><br><span class="line">最后$ans=\sum_&#123;i=0&#125;^n dp[cnt][i]$，cnt为n以内质数的个数</span><br></pre></td></tr></table></figure>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">6</span>, G = <span class="number">1e5</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, cnt, res;</span><br><span class="line"><span class="type">int</span> f[N][N], vis[N], pri[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pres_dou</span><span class="params">(<span class="type">int</span> lim)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= lim; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (! vis[i]) pri[++ cnt] = i;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * pri[j] &lt;= lim; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[i * pri[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (! (i % pri[j])) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    n = <span class="built_in">read</span>(), <span class="built_in">pres_dou</span>(n);</span><br><span class="line"></span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= cnt; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= n; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="type">int</span> now = pri[i];</span><br><span class="line">            <span class="keyword">for</span> (; now &lt;= j; now *= pri[i]) f[i][j] += f[i - <span class="number">1</span>][j - now];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= n; ++ i) res += f[cnt][i];</span><br><span class="line">    <span class="built_in">put</span>(res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动规</tag>
      </tags>
  </entry>
  <entry>
    <title>message</title>
    <url>/2020/09/28/message/</url>
    <content><![CDATA[<p>题目大意：一个数字由两个字符串 a 和 b 表达，这个数字就是 b 在 a
中匹配的位置。 <span id="more"></span> 比如，a=”abcd”，b=”c”，那么这个数字就是
3。</p>
<p>但是这样会出现一个问题，a 和 b
能够表达两个不同的数字：比如，a=“ababa”，b=”aba”时，那个数字可以是 1
也可以是 3。他们对这</p>
<p>种现象很好奇现在给定一个字符串 a，求一个整数 x
使得对于任意一个长度大于 x 的串 b，这一问题都不会出现。</p>
<p><strong>Input:</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">ababa</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<p>题目分析:</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">题目要求出一个长度，使得大于这个长度的串只会出现一次，</span><br><span class="line">考虑什么时候一个串会出现两次乃至多次，一定是他会被某一个串的next计算到，</span><br><span class="line">所以我们对字符串的每一个字符作为起点，对‘当前串’求一遍next，</span><br><span class="line">考虑在某一个串里面，所有长度大于‘当前串’的next的最大值的‘子串’，那么他一定只会在当前串里面出现一次，</span><br><span class="line">答案就是所有串的next的最大值</span><br></pre></td></tr></table></figure>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">666</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">s</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">w</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) w = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) s = s * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s * w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (! x) <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">num</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="type">char</span> c[<span class="number">66</span>];</span><br><span class="line">    <span class="keyword">while</span> (x) c[++ num] = x % <span class="number">10</span> + <span class="number">48</span>, x /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (num) <span class="built_in">putchar</span>(c[num --]);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> nex[N];</span><br><span class="line"><span class="type">char</span> ch[N], s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, l, n, len, <span class="built_in">res</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%s&quot;</span>, ch + <span class="number">1</span>), n = <span class="built_in">strlen</span>(ch + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (l = <span class="number">1</span>; l &lt;= n; ++ l)</span><br><span class="line">    &#123;</span><br><span class="line">        j = len = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(nex, <span class="number">0</span>, <span class="keyword">sizeof</span> nex), <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span> s);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (i = l; i &lt;= n; ++ i) s[++ len] = ch[i];</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= len; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &amp;&amp; s[j + <span class="number">1</span>] != s[i]) j = nex[j];</span><br><span class="line">            <span class="keyword">if</span> (s[j + <span class="number">1</span>] == s[i]) ++ j;</span><br><span class="line">            nex[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= len; ++ i) res = <span class="built_in">max</span>(res, nex[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">put</span>(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>water</title>
    <url>/2020/10/31/water/</url>
    <content><![CDATA[<p>题目大意：给定数字n，求<span class="math inline">\(n\bmod
i\)</span>和，其中i属于n，多组数据T1e6,n1e7！<span id="more"></span></p>
<p>显然可以数论分块，对于每个块，如果发现跨度大于1，那么这个序列贡献出来的答案就是一个等差数列，然后算就完事了</p>
<p>时间复杂度：<span class="math inline">\(O(T\times \sqrt
n)\)</span></p>
<p>还可以推数学式子，但是我不会</p>
<p>于是我们再次打表找规律，就看每个数字对于后面数的贡献是啥，栗子：</p>
<p>1对谁也没有贡献，2对2贡献为0，对3贡献为1,3对3贡献为0，对4贡献为1，对5贡献为2，对6贡献为零…</p>
<p>打个表就会发现，我们设<span
class="math inline">\(f_i\)</span>表示答案</p>
<p>显然可以发现<span
class="math inline">\(f_i=f_{i-1}+(i-2)-(d_i-1-i)\)</span>（d表示i的约数和）</p>
<p>显然从上一个数字当当前，是每一位的贡献都会多（除了i和本身）所以加上i-2</p>
<p>但是我们又可以打表发现这个数字的下面的约数位都是0，也就是我们一定多加了某些数字，所以要减去约数和，但是约数和包含了1和i</p>
<p>所以还要加回来</p>
<p>但是我不会线性筛约数和，回头补坑</p>
<p>代码如下：（注释部分即为整除分块）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e7</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> T, n;</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> f[N], prime[N], cnt;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> sum[N], tot[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pres_dou</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    sum[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i= <span class="number">2</span>; i &lt; <span class="number">1e7</span>; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (! vis[i]) prime[++ cnt] = i, sum[i] = i + <span class="number">1</span>, tot[i] = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * prime[j] &lt; N; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[i * prime[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (!(i % prime[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                tot[i * prime[j]] = tot[i] * prime[j] + <span class="number">1</span>;</span><br><span class="line">                sum[i * prime[j]] = sum[i] / tot[i] * tot[i * prime[j]];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sum[i * prime[j]] = sum[i] * sum[prime[j]];</span><br><span class="line">            tot[i * prime[j]] = <span class="number">1</span> + prime[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    T = read();</span></span><br><span class="line"><span class="comment">    while (T --)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        int i, l, r; n = read(), res = 0;</span></span><br><span class="line"><span class="comment">        for (l = 1; l &lt;= n; l = r + 1)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            r = n / (n / l);</span></span><br><span class="line"><span class="comment">            if (r == l) res += n % l;</span></span><br><span class="line"><span class="comment">            else</span></span><br><span class="line"><span class="comment">            &#123;</span></span><br><span class="line"><span class="comment">                int t = n / l, len = r - l + 1, a1 = n % r;</span></span><br><span class="line"><span class="comment">                res += 1ll * len * a1 + 1ll * len * (len - 1) / 2 * t;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        put(res);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="built_in">pres_dou</span>();</span><br><span class="line">    T = <span class="built_in">read</span>();</span><br><span class="line">    f[<span class="number">3</span>] = f[<span class="number">4</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">5</span>; i &lt;= <span class="number">1e7</span>; ++ i) f[i] = f[i - <span class="number">1</span>] + i - <span class="number">2</span> - (sum[i] - <span class="number">1</span> - i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (T --)</span><br><span class="line">    &#123;</span><br><span class="line">        n = <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">put</span>(f[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fclose</span>(stdin), <span class="built_in">fclose</span>(stdout);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">给定数字n</span></span><br><span class="line"><span class="comment">求n/i的余数的和，其中i属于n</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>总结：</p>
<p>今天上午期望得分：60+10+0+50=120pts</p>
<p>实际得分：20+40+0+50=110pts</p>
<p>第一题挂掉令人惊讶，第二题输出1得了四十分更令人惊讶</p>
<p>最令人惊讶的是第四题竟然是个直接暴力的水题</p>
<p>今天下午期望得分：10+40+20+30=100pts</p>
<p>实际得分：20+40+20+30=110pts</p>
<p>出题人良心，不然不可能过百</p>
<p>其实考了这么多这么多回，知识的提高并不是显著的，显著的是我明显感觉到我的做题策略终于改变了</p>
<p>部分分和暴力分数几乎做到颗粒归仓</p>
<p>人都是顽固不化的，考了三个月我才领悟到考试的精髓，考了三个月才从那种上来就干正解的傻逼策略中扭转过来</p>
<p>看起来很可笑</p>
<p>但是当人真正处于围城的时候，无法自拔，深陷其中，无数次怀疑自己的能力而不是自己的方法</p>
<p>更没有怀疑过自己的做题策略这种<strong>小小小的细节</strong></p>
<p>但是就是这种小小小的细节决定了我的成败</p>
<p>我可以不如别人厉害，但是我不一定考的分数比别人低</p>
<p>推荐名额定了，不出所料，但又略有失望</p>
<p>假如我可以早一个月扭转做题策略，我未尝不可被推荐，拿到一种毫无压力的通往NOIp的门票</p>
<p>但是那是假如</p>
<p>悟已往之不谏 知来者之可追</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>V 神跑步</title>
    <url>/2020/11/03/V-%E7%A5%9E%E8%B7%91%E6%AD%A5/</url>
    <content><![CDATA[<p>题目大意：给定一张M条边的无向连通图，求从S到T经过N条边的最短路长度。<span id="more"></span></p>
<p>说白了就是通过矩阵来模拟走多少步</p>
<p>矩阵转一次走一步，山不转水转，终究会走那么多步的</p>
<p>我不会重载运算符，留坑</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">s</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">w</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) w = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) s = s * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s * w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">put</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (! x) <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">num</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="type">char</span> c[<span class="number">66</span>];</span><br><span class="line">    <span class="keyword">while</span> (x) c[++ num] = x % <span class="number">10</span> + <span class="number">48</span>, x /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (num) <span class="built_in">putchar</span>(c[num --]);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ver[N &lt;&lt; <span class="number">1</span>], nex[N &lt;&lt; <span class="number">1</span>], len[N &lt;&lt; <span class="number">1</span>], head[N], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++ cnt] = y;</span><br><span class="line">    nex[cnt] = head[x];</span><br><span class="line">    len[cnt] = z;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(head[x] = cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, tot;</span><br><span class="line"><span class="type">int</span> num[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yhzhyhm</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">360</span>][<span class="number">360</span>];</span><br><span class="line">    yhzhyhm <span class="keyword">operator</span> * (<span class="type">const</span> yhzhyhm &amp;x) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        yhzhyhm c; <span class="type">int</span> i, j, k;</span><br><span class="line">        <span class="built_in">memset</span>(c.a, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> c.a);</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= tot; ++ k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= tot; ++ i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= tot; ++ j)</span><br><span class="line">                &#123;</span><br><span class="line">                    c.a[i][j] = <span class="built_in">min</span>(c.a[i][j], a[i][k] + x.a[k][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;dis, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;run.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin), <span class="built_in">freopen</span>(<span class="string">&quot;run.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    <span class="type">int</span> i, x, y, z, s, t;</span><br><span class="line">    <span class="built_in">memset</span>(dis.a, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis.a);</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>(), s = <span class="built_in">read</span>(), t = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        z = <span class="built_in">read</span>(), x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span> (! num[x]) num[x] = ++ tot;</span><br><span class="line">        <span class="keyword">if</span> (! num[y]) num[y] = ++ tot;</span><br><span class="line">        dis.a[num[x]][num[y]] = dis.a[num[y]][num[x]] = z;</span><br><span class="line">    &#125;</span><br><span class="line">    -- n, ans = dis;</span><br><span class="line">    <span class="keyword">for</span> (; n; n &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) ans = ans * dis;</span><br><span class="line">        dis = dis * dis;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">put</span>(ans.a[num[s]][num[t]]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>矩阵乘法</tag>
      </tags>
  </entry>
  <entry>
    <title>windy数</title>
    <url>/2020/10/10/windy%E6%95%B0/</url>
    <content><![CDATA[<p>题目大意：求一段区间内不含前导零且相邻两个数字之差至少为2的正整数的个数</p>
<span id="more"></span>
<p>PS：很久以前写了一篇题解，现在无论是从码风还是代码实现上来看，都感觉那时候是个傻逼</p>
<p>时隔很久，终于有时间来重新整理一下思路，修改一下码风。</p>
<p>对于这道题目，我们直接在一段前后没有区间里搞的话，貌似不好求，于是运用一下在区间问题里面经典的前缀和思想——</p>
<p>对于<span class="math inline">\([1,r]\)</span>求得一个<span
class="math inline">\(res_1\)</span>，在<span
class="math inline">\([1,l-1]\)</span>求得一个<span
class="math inline">\(res_2\)</span>，两者做差即是<span
class="math inline">\([l,r]\)</span>内的<span
class="math inline">\(res\)</span></p>
<p>接下来讨论如何求出<span
class="math inline">\([1,一个端点]\)</span>的答案，</p>
<p>我们设<span
class="math inline">\(f[i][j]\)</span>表示当前这一位是<span
class="math inline">\(i\)</span>，上一位是<span
class="math inline">\(j\)</span>的方案数目</p>
<p>然后考虑转移：我们枚举每一位的<span
class="math inline">\(0\)</span>~<span
class="math inline">\(9\)</span>，特别的，如果发现上一位是有限制的，那么这一位的上限便不再是9，只能是原数中的那个数字</p>
<p>举个例子：</p>
<p>假如原数为<span class="math inline">\(123456\)</span></p>
<p>我们可以从<span class="math inline">\(122...\)</span>转移到<span
class="math inline">\(1229..\)</span>，但是我们显然不能从<span
class="math inline">\(123...\)</span>转移到<span
class="math inline">\(1239..\)</span>，只能转移到<span
class="math inline">\(1234..\)</span>这一位上限<strong>显然</strong>只能是4</p>
<p>然后就可以大力讨论转移了。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">666</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">s</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">w</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) w = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) s = s * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s * w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (! x) <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">num</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="type">char</span> c[<span class="number">66</span>];</span><br><span class="line">    <span class="keyword">while</span> (x) c[++ num] = x % <span class="number">10</span> + <span class="number">48</span>, x /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (num) <span class="built_in">putchar</span>(c[num --]);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, cnt;</span><br><span class="line"><span class="type">int</span> num[N], f[N][N];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">pos 当前枚举的哪一位</span></span><br><span class="line"><span class="comment">pre 上一位是谁</span></span><br><span class="line"><span class="comment">flag 上一位是否达到了限制，换言之，前边搜到的数字，是否和原数字匹配了</span></span><br><span class="line"><span class="comment">lim 是否有前导零</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> pre, <span class="type">int</span> flag, <span class="type">int</span> lim)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (! pos) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (! flag &amp;&amp; f[pos][pre] != <span class="number">-1</span> &amp;&amp; !lim) <span class="keyword">return</span> f[pos][pre];</span><br><span class="line">    <span class="type">int</span> i, nex, <span class="built_in">res</span>(<span class="number">0</span>);</span><br><span class="line">    nex = flag ? num[pos] : <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= nex; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> delta = <span class="built_in">abs</span>(pre - i);</span><br><span class="line">        <span class="keyword">if</span> (delta &lt; <span class="number">2</span> &amp;&amp; ! lim) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (i == nex &amp;&amp; flag) res += <span class="built_in">dfs</span>(pos - <span class="number">1</span>, i, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> res += (i || ! lim) ? <span class="built_in">dfs</span>(pos - <span class="number">1</span>, i, <span class="number">0</span>, <span class="number">0</span>) : <span class="built_in">dfs</span>(pos - <span class="number">1</span>, i, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (! flag &amp;&amp; ! lim) f[pos][pre] = res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span> (f, <span class="number">-1</span>, <span class="keyword">sizeof</span> f), cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x) num[++ cnt] = x % <span class="number">10</span>, x /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(cnt, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">put</span>(<span class="built_in">calc</span>(m) - <span class="built_in">calc</span>(n - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数位dp</tag>
      </tags>
  </entry>
  <entry>
    <title>x</title>
    <url>/2020/11/30/x/</url>
    <content><![CDATA[<p>题目大意:给定一个长度为n的正整数序列.将 {1,2,...,n}
划分成两个非空集合S,T.使得 <span
class="math inline">\(gcd(∏_{i∈S}a_i,∏_{i∈T}a_i)\)</span> =
1.求划分方案数，对 <span
class="math inline">\(10^9+7\)</span>取模.<span id="more"></span></p>
<p>显然的性质是:有相同因数的数字们必须在一个集合里面.</p>
<p>所以我们用并查集来维护.最后统计分成了几个集合.答案就是<span
class="math inline">\(2^{cnt} - 2\)</span></p>
<p>线性筛+并查集即可.</p>
<p>代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">66</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, cnt;</span><br><span class="line"><span class="type">int</span> v[N], mp[N], pri[N], vis[N], las[N];</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pres_dou</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; <span class="number">1e6</span>; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (! v[i]) pri[++ cnt] = i, mp[i] = i;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; pri[j] * i &lt; <span class="number">1e6</span>; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            v[i * pri[j]] = <span class="number">1</span>;</span><br><span class="line">            mp[i * pri[j]] = pri[j];</span><br><span class="line">            <span class="keyword">if</span> (i % pri[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)p[x].<span class="built_in">size</span>(); ++ i) <span class="keyword">if</span> (! vis[p[x][i]]) <span class="built_in">dfs</span>(p[x][i]);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">yhm_func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, x; n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= cnt; ++ i) las[pri[i]] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        vis[i] = <span class="number">0</span>, p[i].<span class="built_in">clear</span>();</span><br><span class="line">        x = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">while</span> (x &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> tmp = mp[x];</span><br><span class="line">            <span class="keyword">while</span> (x % tmp == <span class="number">0</span>) x /= tmp;</span><br><span class="line">            <span class="keyword">if</span> (las[tmp]) p[i].<span class="built_in">push_back</span>(las[tmp]), p[las[tmp]].<span class="built_in">push_back</span>(i);</span><br><span class="line">            las[tmp] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="keyword">if</span> (! vis[i]) <span class="built_in">dfs</span>(i), res = res * <span class="number">2</span> % mod;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(<span class="built_in">put</span>((res - <span class="number">2</span> + mod) % mod));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">    <span class="built_in">pres_dou</span>();</span><br><span class="line">    <span class="type">int</span> T = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span> (T --) <span class="built_in">yhm_func</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后记:</p>
<p>巧妙的思维题</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>数学</tag>
        <tag>思维题</tag>
        <tag>线性筛</tag>
      </tags>
  </entry>
  <entry>
    <title>web与py和sql</title>
    <url>/2023/09/26/web%E4%B8%8Epy%E5%92%8Csql/</url>
    <content><![CDATA[<p>web,py,sql相关操作 <span id="more"></span></p>
<h1 id="web-相关操作">web 相关操作</h1>
<p><code>pip list</code>展示当前已安装的模块以及版本号</p>
<p><code>pip install web.py</code> 安装模块</p>
<p>要从管理员cmd打开</p>
<h1 id="web.py的模板">web.py的模板</h1>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> web</span><br><span class="line">urls = (</span><br><span class="line">    <span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;index&#x27;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">index</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">GET</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, world!&quot;</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app = web.application(urls, <span class="built_in">globals</span>())</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>
<p>提交表单是POST，调用是GET</p>
<h1 id="sql">sql</h1>
<p>navicat中</p>
<p>sql语句插入</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">insert into 表名(字段1, 字段2...) values(&#x27;值1&#x27;, &#x27;值2&#x27;);</span><br></pre></td></tr></table></figure>
<p>sql修改与删除 <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">update 表名 set 字段1 = &#x27;值1&#x27; 字段2 = &#x27;值2&#x27; where 条件;</span><br><span class="line">delete from 表名 where 条件</span><br></pre></td></tr></table></figure></p>
<p>sql当前数据 <figure class="highlight text"><table><tr><td class="code"><pre><span class="line">select * from 表名</span><br><span class="line"></span><br><span class="line">select x from y where z</span><br><span class="line">当z成立时，将x从y中挑选出来</span><br></pre></td></tr></table></figure></p>
<p>与py结合 <figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sqlSelect</span>(<span class="params">sql</span>):</span><br><span class="line">   conn=pymysql.connect(host=<span class="string">&#x27;localhost&#x27;</span>,port=<span class="number">3306</span>,user=<span class="string">&#x27;root&#x27;</span>,passwd=<span class="string">&#x27;123456&#x27;</span>,db=<span class="string">&#x27;web&#x27;</span>)</span><br><span class="line">   cur = conn.cursor()</span><br><span class="line">   cur.execute(sql)</span><br><span class="line">   sqlData=cur.fetchall()</span><br><span class="line">   cur.close()</span><br><span class="line">   conn.close()</span><br><span class="line">   <span class="keyword">return</span> sqlData</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sqlWrite</span>(<span class="params">sql</span>):</span><br><span class="line">   conn=pymysql.connect(host=<span class="string">&#x27;localhost&#x27;</span>,port=<span class="number">3306</span>,user=<span class="string">&#x27;root&#x27;</span>,passwd=<span class="string">&#x27;123456&#x27;</span>,db=<span class="string">&#x27;web&#x27;</span>)</span><br><span class="line">   cur = conn.cursor()</span><br><span class="line">   cur.execute(sql)</span><br><span class="line">   cur.close()</span><br><span class="line">   conn.commit()</span><br><span class="line">   conn.close()</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">sql = <span class="string">&quot;select displayname, jobs, lifedata from lol where races = &#x27;%s&#x27;&quot;</span> %name</span><br><span class="line">sqlData = sqlSelect(sql)</span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> sqlData:</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;名称：%s，职业：%s，生命：%s&quot;</span> %(t[<span class="number">0</span>], t[<span class="number">1</span>], t[<span class="number">2</span>]))</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>学后感</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>tree(换根dp)</title>
    <url>/2020/10/08/tree/</url>
    <content><![CDATA[<p>题目大意： 一棵树，任意选择一个点为根，根的深度<span
class="math inline">\(dep_{root}\)</span>为0，整棵树的价值W=所有点的深度和，问你选择哪一个点作为根？</p>
<span id="more"></span>
<p>换根dp模板题</p>
<p>一般都是跑两边大法师，第一遍大法师是从根出发，处理出到达别的点的一些信息</p>
<p>然后第二遍大法师也是从根出发，但是每访问到一个节点都会转移一些信息</p>
<p><span class="math display">\[ f[y] = f[x]-siz[y]+n-siz[y](y= son[x])
\]</span></p>
<p>表示从x这个根转移到y这个根的话，首先要把从y引申出来的siz[y]条路径的长度全部减一</p>
<p>其次要把从x引申出来的所有不包含y的所有路径长度全部加一</p>
<p><strong>PS：我们的f数组定义为：这个点到别的所有点的路径的和，并不是针对单个点，理解了这一点，转移也就很好理解了</strong></p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">666</span>, inf = <span class="number">214748364</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> f[N], dis[N], siz[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> yhm_fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, y;</span><br><span class="line">    siz[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = head[x]; i; i = nex[i])</span><br><span class="line">    &#123;</span><br><span class="line">        y = ver[i];</span><br><span class="line">        <span class="keyword">if</span> (y == yhm_fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y, x);</span><br><span class="line">        siz[x] += siz[y];</span><br><span class="line">        dis[x] += dis[y] + siz[y];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fuck</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> yhm_fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, y;</span><br><span class="line">    <span class="keyword">for</span> (i = head[x]; i; i = nex[i])</span><br><span class="line">    &#123;</span><br><span class="line">        y = ver[i];</span><br><span class="line">        <span class="keyword">if</span> (y == yhm_fa) <span class="keyword">continue</span>;</span><br><span class="line">        f[y] = f[x] - siz[y] + n - siz[y];</span><br><span class="line">        <span class="built_in">fuck</span>(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, x, y, <span class="built_in">res</span>(inf);</span><br><span class="line">    </span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">add_edge</span>(x, y), <span class="built_in">add_edge</span>(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    f[<span class="number">1</span>] = dis[<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">fuck</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) res = <span class="built_in">min</span>(res, f[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">put</span>(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title>queue2</title>
    <url>/2020/11/26/queue2/</url>
    <content><![CDATA[<p>题目大意:<span
class="math inline">\(n\)</span>个沙茶,被编号1至n排完队之后.每个沙茶希望自己的相邻的两人只要无一个人的编号和自己的编号相差为<span
class="math inline">\(1\)</span>(+1或-1就行).现在想知道,存在多少方案满足沙茶们如此不苛刻的条件.<span id="more"></span></p>
<p>计数dp</p>
<p>状态:<span
class="math inline">\(f_{i,j,0/1}\)</span>表示推到第i个数字,有j对数字是相差1的且i与i-1相邻/不相邻</p>
<h3 id="分析f_ij1">分析<span
class="math inline">\(f_{i,j,1}\)</span></h3>
<p>考虑<span class="math inline">\(i-1\)</span>与<span
class="math inline">\(i-2\)</span>的关系</p>
<ul>
<li>若<span class="math inline">\(i-1\)</span>与<span
class="math inline">\(i-2\)</span>相邻</li>
</ul>
<blockquote>
<p>将<span
class="math inline">\(i\)</span>插入到两者中间,拆散了一对<span
class="math inline">\((i-1,i-2)\)</span>但是多了一对<span
class="math inline">\((i-1,i)\)</span>,依然还是<span
class="math inline">\(j\)</span>对,故方案来自于<span
class="math inline">\(f_{i-1,j,1}\)</span></p>
</blockquote>
<blockquote>
<p>将<span class="math inline">\(i\)</span>插入到<span
class="math inline">\(i-1\)</span>的另一侧,多了一对<span
class="math inline">\((i-1,i)\)</span>.现在有<span
class="math inline">\(j\)</span>对,故当时状态只有<span
class="math inline">\(j-1\)</span>对,因此方案来自于<span
class="math inline">\(f_{i-1,j-1,1}\)</span></p>
</blockquote>
<ul>
<li>若<span class="math inline">\(i-1\)</span>与<span
class="math inline">\(i-2\)</span>不相邻</li>
</ul>
<blockquote>
<p>为了满足<span
class="math inline">\((i-1,i)\)</span>相邻的条件,我们可以必须在<span
class="math inline">\(i-1\)</span>的旁边插入,又因为两边都可以满足要求,所以方案数目要加倍.故方案为<span
class="math inline">\(f_{i-1,j-1,0} \times2\)</span></p>
</blockquote>
<h3 id="分析f_ij0">分析<span
class="math inline">\(f_{i,j,0}\)</span></h3>
<p>依旧是考虑<span class="math inline">\(i-1\)</span>与<span
class="math inline">\(i-2\)</span>的关系</p>
<ul>
<li>若<span class="math inline">\(i-1\)</span>与<span
class="math inline">\(i-2\)</span>相邻</li>
</ul>
<blockquote>
<p>我们将<span
class="math inline">\(i\)</span>插入到任何一对里面都会破坏一对,因为当前是<span
class="math inline">\(j\)</span>对,所以当时的状态就必须是<span
class="math inline">\(j+1\)</span>对,因此方案来自于<span
class="math inline">\(f_{i-1,j+1,1}\)</span>,又因为有<span
class="math inline">\(j+1-1\)</span>个位置可以选(别忘记我们不能拆开<span
class="math inline">\((i-1,i-2)\)</span>那对,)因此方案总数为<span
class="math inline">\(f_{i-1,j+1,1} \times j\)</span></p>
</blockquote>
<ul>
<li>若<span class="math inline">\(i-1\)</span>与<span
class="math inline">\(i-2\)</span>不相邻</li>
</ul>
<blockquote>
<p>类比上一个情况,我们可以初步得到方程<span
class="math inline">\(f_{i-1,j+1,0}\)</span>,又因为有<span
class="math inline">\(j+1\)</span>个位置可以选,所以总方案数为<span
class="math inline">\(f_{i-1,j,0} \times (j+1)\)</span></p>
</blockquote>
<p>也有可能是<span
class="math inline">\(i\)</span>不去拆开那些相邻的关系</p>
<p>可以插入到平凡的世界:</p>
<ul>
<li><span class="math inline">\(f_{i-1,j,1}\)</span>:这种情况会出现<span
class="math inline">\((i-j-2+1)\)</span>个,因为当前共有<span
class="math inline">\((i-j-2)\)</span>个位置可以插入,但是考虑到插入于<span
class="math inline">\((i-1,i-2)\)</span>中间后,不会产生新的贡献,故<span
class="math inline">\(+1\)</span>,因此总方案数:<span
class="math inline">\(f_{i-1,j,1} \times(i-j-1)\)</span></li>
<li><span
class="math inline">\(f_{i-1,j,0}\)</span>:类比上一个,只不过稍微简单一些:故总方案数:<span
class="math inline">\(f_{i-1,j,0} \times (i-j-2)\)</span></li>
</ul>
<hr />
<p>综上所述</p>
<p><span
class="math display">\[f_{i,j,1}=f_{i-1,j,1}+f_{i-1,j-1,1}+f_{i-1,j-1,0}\times
2\]</span></p>
<p><span class="math display">\[f_{i,j,0}=f_{i-1,j+1,1} \times
j+f_{i-1,j+1,0} \times (j+1)\]</span></p>
<p><span class="math display">\[f_{i,j,0}=f_{i-1,j,1} \times
(i-j-1)+f_{i-1,j,0} \times (i-j-2)\]</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">66</span>, mod = <span class="number">7777777</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N][N][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, i, j;</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; i; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j][<span class="number">1</span>] = (f[i - <span class="number">1</span>][j][<span class="number">1</span>] + f[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">1</span>] + f[i - <span class="number">1</span>][j - <span class="number">1</span>][<span class="number">0</span>] * <span class="number">2</span>) % mod;</span><br><span class="line">            f[i][j][<span class="number">0</span>] = (f[i - <span class="number">1</span>][j + <span class="number">1</span>][<span class="number">1</span>] * j + f[i - <span class="number">1</span>][j + <span class="number">1</span>][<span class="number">0</span>] * (j + <span class="number">1</span>)) % mod;</span><br><span class="line">            f[i][j][<span class="number">0</span>] = (f[i][j][<span class="number">0</span>] + f[i - <span class="number">1</span>][j][<span class="number">1</span>] * (i - <span class="number">1</span> - j) + (f[i - <span class="number">1</span>][j][<span class="number">0</span>] * (i - <span class="number">2</span> - j))) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">put</span>(f[n][<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后记:</p>
<p>第一道学会学透学懂的计数dp,难了我整整两天</p>
<p>神仙状态.</p>
<p>感觉这一道题就加深了我对dp的理解</p>
<p>我们由谁推过来,一定是由推过来那个状态所演变的,假如我现在只有<span
class="math inline">\(j\)</span>个,但是推过来那个有<span
class="math inline">\((j+1)\)</span>个,意味着我这次的转移的意义是少一个<span
class="math inline">\(j\)</span></p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动规</tag>
        <tag>计数类dp</tag>
      </tags>
  </entry>
  <entry>
    <title>上升序列</title>
    <url>/2020/12/02/%E4%B8%8A%E5%8D%87%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p>题目大意:在一个序列里面找一个字典序最小的指定长度的上升序列<span id="more"></span></p>
<p>题目来源:<a
href="https://www.luogu.com.cn/problem/P2215">P2215</a></p>
<p>一反常态,这次需要从后往前找.</p>
<p>我们定义<span
class="math inline">\(f_i\)</span>为从第i个元素后最长上升的序列长度</p>
<p>然后遇到制定可以满足答案的就跳</p>
<p>因为是顺序查找,所以我们一旦遇到答案就去跳,一定是有解且最优的!</p>
<p>代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span> + <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, maxv;</span><br><span class="line"><span class="type">int</span> a[N], f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j; n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) a[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = n; i &gt;= <span class="number">1</span>; -- i)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= n; ++ j) <span class="keyword">if</span> (a[j] &gt; a[i])</span><br><span class="line">            f[i] = <span class="built_in">max</span>(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">        maxv = <span class="built_in">max</span>(maxv, f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span> (m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span> (l &gt; maxv) &#123;<span class="built_in">puts</span>(<span class="string">&quot;Impossible&quot;</span>); <span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="type">int</span> las = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (f[i] &gt;= l &amp;&amp; a[i] &gt; las)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">put</span>(a[i]), las = a[i];</span><br><span class="line">                <span class="keyword">if</span> (! -- l) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后记:</p>
<p>考场上几乎想到了,但是差一点.</p>
<p>我是倒着搞的,贪心的正确性没办法保证.</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动规</tag>
        <tag>思维题</tag>
        <tag>一般dp</tag>
      </tags>
  </entry>
  <entry>
    <title>买咖啡</title>
    <url>/2020/10/25/%E4%B9%B0%E5%92%96%E5%95%A1/</url>
    <content><![CDATA[<p>题目大意：咖啡它的价格每小时都会发生变化。现在，考虑长为
n时的一段时间，在第i时中，咖啡的价格为<span
class="math inline">\(c_i\)</span>，由于秋冬季容易感冒， KSkun
不会喝冷了的咖啡，1杯咖啡在经过 h时后会冷，这之后 KSkun
不会再喝它了。<span id="more"></span>1杯咖啡可以让 KSkun 保持清醒
1时，他想知道在每个小时中分别买几杯咖啡，才能在花费最少的情况下在每个小时中都能够通过喝
杯热的咖啡保持清醒。 在本题中，你只需要输出第
这些小时中的答案即可。在花费最少的情况下喝到最新鲜的咖啡（即如果有相同价格的咖啡能选择，选择时间最后的）。</p>
<p>转化题意，也就是说，从当前这个物品的前h个里面选一个最小的买了，用单调队列来转移</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, h, b, e;</span><br><span class="line"><span class="type">int</span> c[N], q[N], res[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span> (<span class="string">&quot;%lld%lld%lld%lld&quot;</span>, &amp;n, &amp;h, &amp;b, &amp;e) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) c[i] = <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">memset</span>(q, <span class="number">0</span>, <span class="keyword">sizeof</span> q), <span class="built_in">memset</span>(res, <span class="number">0</span>, <span class="keyword">sizeof</span> res);</span><br><span class="line">        <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r &amp;&amp; q[l] + h &lt;= i) ++ l;</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r &amp;&amp; c[q[r]] &gt;= c[i]) -- r;</span><br><span class="line">            q[++ r] = i;</span><br><span class="line">            ++ res[q[l]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = b; i &lt;= e; ++ i) <span class="built_in">put</span>(res[i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<p>期望得分：100+？+50pts</p>
<p>实际得分：100+0+50pts</p>
<p>第二题自己在一个错误的方向上走了很远，应该多换方向考虑，自己的做题思路太容易僵化</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>二分图</title>
    <url>/2020/07/05/%E4%BA%8C%E5%88%86%E5%9B%BE/</url>
    <content><![CDATA[<span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// eft</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span>+<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, t, res;</span><br><span class="line"><span class="type">int</span> vis[N], mch[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;<span class="type">int</span> frm, to, nxt;&#125;e[N&lt;&lt;<span class="number">3</span>]; <span class="type">int</span> cnt, h[N&lt;&lt;<span class="number">3</span>]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add_edge</span> <span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">   e[++cnt].nxt = h[u], h[u] = cnt;</span><br><span class="line">   e[cnt].frm = u, e[cnt].to = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">dfs</span> <span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = h[x]; i; i = e[i].nxt) &#123;</span><br><span class="line">      <span class="type">int</span> y = e[i].to;</span><br><span class="line">      <span class="keyword">if</span> (vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">      vis[y] = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (!mch[y] || <span class="built_in">dfs</span> (mch[y])) &#123;</span><br><span class="line">         mch[y] = x;</span><br><span class="line">	 <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">main</span> () &#123;</span><br><span class="line">   cin &gt;&gt; n &gt;&gt; m &gt;&gt; t;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, u, v; i &lt;= t; ++ i) &#123;</span><br><span class="line">      <span class="built_in">scanf</span> (<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">      <span class="keyword">if</span> (u &gt; n || v &gt; m) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="built_in">add_edge</span> (u, v);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">      <span class="built_in">memset</span> (vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">dfs</span> (i)) ++ res;</span><br><span class="line">   &#125;</span><br><span class="line">   cout &lt;&lt; res;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS:</p>
<p>1."if" must special judgement</p>
<p>2.the important thought is:</p>
<p>first.use the U to match V</p>
<p>second. if the V has matched w</p>
<p>third. dfs(w) if we get true,thus the U --&gt; V; else we need to
find the other edge of the U</p>
]]></content>
      <categories>
        <category>学后感</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>书信</title>
    <url>/2020/11/11/%E4%B9%A6%E4%BF%A1/</url>
    <content><![CDATA[<p>题目大意：有 n 个小朋友，编号为 1 到
n，他们每人写了一封信，放到了一个信箱里，
接下来每个人从中抽取一封书信。显然，这样一共有 <span
class="math inline">\(n!\)</span>种拿到书信的情况。
<span id="more"></span>现在亮亮规定，对任意的 1&lt;=x,y&lt;=n，如果 x 号小朋友拿到 u
号小朋友写的 书信，y 号小朋友拿到 v
号小朋友写的书信，那么（x+y）号小朋友必须拿到（u+v）
号小朋友写的书信（这里的加法若和超过了 n，那么就减去 n）。
小林想知道，总共有多少种拿到书信的情况呢？</p>
<p>我打表的时候发现了，如果这个数字是一个素数，那么ans就为素数减一，没有联想到欧拉函数，这是我的过</p>
<p>其实我距离正解只差那么一点点</p>
<p>证明不会</p>
<p>打表会</p>
<p>欧拉函数公式：<span class="math inline">\(\phi(x) = x\times
\prod_{i=1}^{m}(1-\dfrac 1 {p_i})\)</span>，其中m为素因子个数</p>
<p>在分解质因数的时候顺便求一下就好了</p>
<p>代码如下：（求一个裸的欧拉函数）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">s</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">w</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) w = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) s = s * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s * w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">put</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (! x) <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">num</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="type">char</span> c[<span class="number">66</span>];</span><br><span class="line">    <span class="keyword">while</span> (x) c[++ num] = x % <span class="number">10</span> + <span class="number">48</span>, x /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (num) <span class="built_in">putchar</span>(c[num --]);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = n, i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i * i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (n % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (n % i == <span class="number">0</span>) n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) res = res / n * (n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">put</span>(<span class="built_in">solve</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fclose</span>(stdin), <span class="built_in">fclose</span>(stdout);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>交叉乘</title>
    <url>/2020/11/28/%E4%BA%A4%E5%8F%89%E4%B9%98/</url>
    <content><![CDATA[<p>题目大意:求 <span class="math display">\[
\sum_{i=l}^r \times \sum_{j=i+1}^ra[i] \times a[j]
\]</span></p>
<span id="more"></span>
<p>化简式子:</p>
<p><span class="math display">\[
\begin{aligned}
&amp;\sum_{i=l}^r \times \sum_{j=i+1}^ra[i] \times a[j]\\
&amp;=\sum_{i=l}^r a[i] \times (\sum_{j=i+1}^r a[j])\\
&amp;=\sum_{i=l}^r a[i] \times (sum[r] - sum[i])\\
&amp;=sum[r] \times (sum[r] - sum[l - 1]) - \sum_{i=l}^r a[i] \times
sum[i]\\
\end{aligned}
\]</span></p>
<p>观察到发现后面那一堆没有同类项了,因此设</p>
<p><span class="math display">\[p[k] = \sum_{i=1}^k a[i] \times
sum[i]\]</span></p>
<p>因此式子化简为:</p>
<p><span class="math display">\[sum[r] \times (sum[r] - sum[l - 1]) -
(p[r] - p[l - 1])\]</span></p>
<p>代码自己可写.</p>
<p>后记:</p>
<p>加深sigema与前缀和应用.</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>思维题</tag>
        <tag>推式子</tag>
      </tags>
  </entry>
  <entry>
    <title>关于指针</title>
    <url>/2022/12/27/%E5%85%B3%E4%BA%8E%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<p>关于指针</p>
<span id="more"></span>
<h1 id="关于指针">关于指针：</h1>
<h2 id="定义">1.定义：</h2>
<p>two ways. <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>, *p = &amp;a;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>, *p;</span><br><span class="line">p = &amp;a;</span><br></pre></td></tr></table></figure>
<p>如果这么写是不合法的： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>, *p;</span><br><span class="line">*p = &amp;a;</span><br></pre></td></tr></table></figure>
可以理解为该变量存储的内容是地址</p>
<h2 id="自增自减">2.自增自减</h2>
<p><span class="math inline">\(*p++\)</span> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">针对p指针加一，然后间接访问</span><br><span class="line"><span class="type">int</span> a[<span class="number">6</span>] = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>&#125;, *p = a;<span class="comment">//a本身就是地址，不需要再&amp;</span></span><br><span class="line">cout &lt;&lt; *p; <span class="comment">// 1</span></span><br><span class="line">*p++;</span><br><span class="line">cout &lt;&lt;*p; <span class="comment">// 4</span></span><br></pre></td></tr></table></figure> <span
class="math inline">\((*p)++\)</span> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> p指针间接访问的内容加一</span><br><span class="line"><span class="type">int</span> a[<span class="number">6</span>] = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>&#125;, *p = a;</span><br><span class="line">cout &lt;&lt; *p; <span class="comment">// 1</span></span><br><span class="line">(*p)++;</span><br><span class="line">cout &lt;&lt; *p; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p>
<h2 id="指针与其他结合">3.指针与其他结合</h2>
<h2 id="宏定义">宏定义</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> type1 char *</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *type2;</span><br><span class="line">type1 s1, s2;</span><br><span class="line">type2 s3, s4;</span><br></pre></td></tr></table></figure>
<p>define仅仅是替换，typedf是定义了一个新的数据类型
上面的代码块也可以写成如下： <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> type1 char *</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *type2;</span><br><span class="line"><span class="type">char</span> *s1, s2;</span><br><span class="line">type2 s3, s4;</span><br></pre></td></tr></table></figure>
显然，s1,s3,s4是指针类型变量</p>
<h2 id="结构体">结构体</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">  <span class="type">char</span> gender;</span><br><span class="line">&#125;std[<span class="number">3</span>], *p = std;</span><br></pre></td></tr></table></figure>
<p>当需要用指针来访问结构体里面内容，两种办法。 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(*p).age = p-&gt;age</span><br></pre></td></tr></table></figure></p>
<p>不允许写 (*p)-&gt;age</p>
<p>*p仍旧是一个值，可以这么考虑，你见过有人写std[0]-&gt;age的吗？</p>
<p>还要注意，p-&gt;age只是一个值，在scanf中仍旧需要取地址&amp;</p>
<p>遇到字符是%c，需要&amp;</p>
<p>遇到字符串是%s，不需要&amp;</p>
]]></content>
  </entry>
  <entry>
    <title>代码素养与规范</title>
    <url>/2020/08/21/%E4%BB%A3%E7%A0%81%E7%B4%A0%E5%85%BB%E4%B8%8E%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<p>在学习之余，我想总结一下关于代码基本素养与规范的问题 <span id="more"></span></p>
<ul>
<li>全局变量与局部变量</li>
</ul>
<p>全局变量默认初始化为0，局部变量务必进行初始化</p>
<p>且开数组的时候，尽量开为全局变量，开为局部变量空间容易出问题</p>
<ul>
<li>代码注释与风格</li>
</ul>
<p>代码注释可以写简单的几句或者不写，切忌长篇大论，很影响代码美观程度</p>
<p>代码风格，在某些合适的地方尽量打一些空格与回车，看着舒服，并且debug的时候好d</p>
<ul>
<li>main函数的传参为空</li>
<li>变量名字重复</li>
</ul>
<p>全局变量与局部变量尽量不要重复，有时候会出现一些奇奇怪怪的错误</p>
<ul>
<li>使用系统自带的关键字</li>
</ul>
<p>比如find，next，time，容易出锅，如果你不知道这个单词是不是关键字，试试首字母大写？或者加一个下划线？</p>
<p>就像这样：Find,Next,Time,find_yhm,next_yhm</p>
<ul>
<li>AC，WA，RE，UKE，MLE，TLE等相关状态的解读</li>
</ul>
<p>ac是你通过了</p>
<p>wa是你答案错误，通常是由于你算法错误，或者细节出锅导致，少数情况下是数组开小了</p>
<p>re是运行时错误，大多数是由数组开小了</p>
<p>uke是输出超过限制，你算法绝逼有问题。。。。</p>
<p>mle是你的空间超过内存限制，通常需要一些优化空间的技巧，比如滚动数组等等</p>
<p>tle是你超时了，就是你程序跑得太慢了，这时候一般会选择开启<span
class="math inline">\(O_2\)</span>或者加上卡常火车头，或者选择改进算法</p>
<ul>
<li>少用cin，输入多用scanf和快读</li>
</ul>
<p>cin，众所周知得慢</p>
<hr />
<p>关于我的码风，给出详细解释</p>
<ul>
<li><p>在字母后边必定跟着逗号，或者分号，然后才是空格</p></li>
<li><p>花括号不换行，换行之后会显得十分凌乱，不换行，整齐</p></li>
<li><p>三缩进，四缩进在for 内，距离太大，显得十分苍白无力</p></li>
<li><p>for循环内无新定义变量</p></li>
<li><p>数组必须开为全局变量</p></li>
<li><p>初始变量时，int不与double同行，在int内，一维数组不与二维数组同行，变量不与数组同行，在同一行内，按照字典序依次排开</p></li>
<li><p>函数与后面的括号之间无空格</p></li>
<li><p>自加/减运算的时候，从来都是++ x/ -- x</p></li>
<li><p>除了主函数外，别的函数都有inline</p></li>
<li><p>变量赋<strong>初值</strong>一定是在后面使用括号</p></li>
<li><p>无论是int还是void，函数结束之后都必须有return</p></li>
<li><p>if 与后面的表达式之间必须有个空格</p></li>
<li><p>如果只有一行变量，不用花括号</p></li>
<li><p>在适当的地方，一定会有回车换行，来区分代码块</p></li>
<li><p>在max与min里，如果表达式过于长，会选择在加号处换行</p></li>
<li><p>字母与数字混合时，字母与表达式与数字之间必须有空格隔开</p></li>
</ul>
<p>详见下面截图</p>
<p><img
src="https://pic.imgdb.cn/item/6327cd9516f2c2beb12460f5.png" /></p>
<p><img
src="https://pic1.imgdb.cn/item/6327cd9516f2c2beb12460fa.png" /></p>
<p><img
src="https://pic.imgdb.cn/item/6327cd9516f2c2beb12460ff.png" /></p>
]]></content>
      <categories>
        <category>mess</category>
      </categories>
      <tags>
        <tag>代码素养</tag>
      </tags>
  </entry>
  <entry>
    <title>代领快递</title>
    <url>/2020/11/23/%E4%BB%A3%E9%A2%86%E5%BF%AB%E9%80%92/</url>
    <content><![CDATA[<p>题目大意:有一些物品,每个物品会有两个属性(x,y),有两种箱子,每种箱子分别有若干个.<span id="more"></span>先规定把箱子分为两个种类,种类1的箱子只能装下属性x严格比他小的物品,对y不做考虑,种类2的箱子只能装下属性y严格比他小的物品,对x不做考虑.每个箱子可以装无限个,但是没装入一个会花掉一分钟,问装完所有箱子最少花费多长时间.</p>
<p>简直是二分答案的神题,我们考虑二分这个时间t,也就是每个箱子最多装的物品,然后问题就转化成了,在时间t的范围内,是否可以装完全部物品的判定性问题.</p>
<p>考虑对种类1的箱子升序排序,对种类2的箱子降序排序,对物品按照w第一s第二关键字升序排序</p>
<p>然后考虑对当前的t我们如何验证.</p>
<p>贪心做的话,是把w小的放进种类1里面限制小的.建立一个以s为关键字的大根堆,每当不能放的时候,就从大根堆里弹出t个来(弹出来的就意味着往这个箱子里面放置的是哪些).这t个一定是s最大的,也就保证了往s里面放的都是尽量小的,贪心显然正确.</p>
<p>然后把没放完的物品放到种类2里面,因为我当前的的箱子是降序排序,所以每当不能放的时候,意味着,如果这个箱子放不了,后面的箱子也肯定都放不了,所以返回即可</p>
<p>最后判断是否还有没放完的,如果有东西没放完代表这次的t是失败的,反之同理.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">66</span>, G = <span class="number">5e4</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A, B, T;</span><br><span class="line"><span class="type">int</span> x[G], y[G];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yhzhyhm</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> w, s;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> yhzhyhm &amp;yhm) <span class="type">const</span> &#123;<span class="keyword">return</span> s &lt; yhm.s;&#125;</span><br><span class="line">&#125;yh[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pi</span><span class="params">(<span class="number">1</span>)</span>, i, j</span>; priority_queue &lt;yhzhyhm&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= A; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (pi &lt;= T &amp;&amp; yh[pi].w &lt; x[i]) q.<span class="built_in">push</span>(yh[pi]), ++ pi;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= t &amp;&amp; ! q.<span class="built_in">empty</span>(); ++ j) q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (pi &lt;= T) q.<span class="built_in">push</span>(yh[pi]), ++ pi;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= B; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (! q.<span class="built_in">empty</span>() &amp;&amp; q.<span class="built_in">top</span>().s &gt;= y[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= t &amp;&amp; ! q.<span class="built_in">empty</span>() &amp;&amp; q.<span class="built_in">top</span>().s &lt; y[i]; ++ j) q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> yhm1, <span class="type">int</span> yhm2)</span> </span>&#123;<span class="keyword">return</span> yhm1 &gt; yhm2;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">CMP</span><span class="params">(yhzhyhm yhm1, yhzhyhm yhm2)</span> </span>&#123;<span class="keyword">return</span> (yhm1.w &lt; yhm2.w) || ((yhm1.w == yhm2.w) &amp;&amp; (yhm1.s &lt; yhm2.s));&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">    <span class="type">int</span> i; A = <span class="built_in">read</span>(), B = <span class="built_in">read</span>(), T = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= A; ++ i) x[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= B; ++ i) y[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= T; ++ i) yh[i].w = <span class="built_in">read</span>(), yh[i].s = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(x + <span class="number">1</span>, x + <span class="number">1</span> + A), <span class="built_in">sort</span>(y + <span class="number">1</span>, y + <span class="number">1</span> + B, cmp);</span><br><span class="line">    <span class="built_in">sort</span>(yh + <span class="number">1</span>, yh + <span class="number">1</span> + T, CMP);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = T, mid;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">put</span>(! <span class="built_in">check</span>(r) ? <span class="number">-1</span> : r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后记:</p>
<p>对此题的解法佩服到了极点,贪心,二分两者结合起来,在这个题里天衣无缝,水乳交融</p>
<p>对出题人的奇思妙想佩服到了极点</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>保卫王国</title>
    <url>/2020/10/09/%E4%BF%9D%E5%8D%AB%E7%8E%8B%E5%9B%BD/</url>
    <content><![CDATA[<p>题目大意：小 Y 正在 A 国游玩。该国共有 𝑛
个城市，地图可以抽象为一张有向无环图。小 Y 的旅行共有 𝑞
天，每天他都会选取一个新的起点和终点，同时每天都会有一些城市无法通行。现在小
Y 想要知道每一天他可能的旅行路线数量。</p>
<span id="more"></span>
<p>时隔很久，这个坑终于tmd补上了</p>
<p>和上学路线那个题目很相似，s到达t的方案数就等于从s到达t不算坏点的方案数，减去路径中经过换点的数目的<strong>dp值</strong>乘以这个坏点到达t的方案数</p>
<p>注意要提前预处理</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">66</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">s</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">w</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) w = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) s = s * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s * w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (! x) <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">num</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="type">char</span> c[<span class="number">66</span>];</span><br><span class="line">    <span class="keyword">while</span> (x) c[++ num] = x % <span class="number">10</span> + <span class="number">48</span>, x /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (num) <span class="built_in">putchar</span>(c[num --]);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ver[N], nex[N], head[N], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++ cnt] = y;</span><br><span class="line">    nex[cnt] = head[x];</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(head[x] = cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, T;</span><br><span class="line"><span class="type">int</span> g[N], c[N], deg[N], vis[N];</span><br><span class="line"><span class="type">int</span> f[<span class="number">1010</span>][<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, y;</span><br><span class="line">    vis[x] = <span class="number">1</span>, f[x][x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = head[x]; i; i = nex[i])</span><br><span class="line">    &#123;</span><br><span class="line">        y = ver[i];</span><br><span class="line">        <span class="keyword">if</span> (! vis[y]) <span class="built_in">dfs</span>(y);</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">            (f[x][j] += f[y][j]) %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> i, x, y;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>(), T = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">add_edge</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="keyword">if</span> (! vis[i]) <span class="built_in">dfs</span>(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (T --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> s = <span class="built_in">read</span>(), t = <span class="built_in">read</span>(), k = <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">memset</span>(deg, <span class="number">0</span>, <span class="keyword">sizeof</span> deg);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= k; ++ i) c[i] = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        <span class="keyword">for</span> (l = <span class="number">1</span>; l &lt;= k; ++ l)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (r = <span class="number">1</span>; r &lt;= k; ++ r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (l == r || ! f[c[l]][c[r]]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span> ++ deg[r];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= k; ++ i) <span class="keyword">if</span> (! deg[i]) q.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= k; ++ i) g[i] = f[s][c[i]];</span><br><span class="line">        <span class="keyword">while</span> (! q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            x = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= k; ++ i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != x &amp;&amp; f[c[x]][c[i]])</span><br><span class="line">                &#123;</span><br><span class="line">                    g[i] = (g[i] - <span class="number">1ll</span> * g[x] * f[c[x]][c[i]] % mod) % mod;</span><br><span class="line">                    <span class="keyword">if</span> (! -- deg[i]) q.<span class="built_in">push</span>(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res = f[s][t];</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= k; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            res = (res - <span class="number">1ll</span> * g[i] * f[c[i]][t] % mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        res = (res % mod + mod) % mod;</span><br><span class="line">        <span class="built_in">put</span>(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：其实很多时候，只是自己骗自己：这题很难，细细拨开来看，一点都不难</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>养花</title>
    <url>/2020/10/27/%E5%85%BB%E8%8A%B1/</url>
    <content><![CDATA[<p>题目大意：小 C 在家种了 n 盆花, 每盆花有一个艳丽度 ai.在接下来的 m
天中, 每天早晨他会从一段编号连续的花中选择一盆摆放在客厅, 并在晚上放回.
<span id="more"></span>同时每天有特定的光照强度 ki,
如果这一天里摆放在客厅的花艳丽度为 x, 则他能获得的喜悦度为 x mod
ki.他希望知道, 每一天他能获得的最大喜悦度是多少.(1e5的数据两)</p>
<p>我的思路接近接近正解：对于每一个位置，提前预处理好，膜1~1e5得出来的每一个结果</p>
<p>然后去随便弄个数据结构去max</p>
<p>正解：分块，考虑把艳丽值桶排，用<span
class="math inline">\(f_i\)</span>表示艳丽值小于等于i的最大值是多少，用<span
class="math inline">\(g_i\)</span>表示这段区间被i模的最大值是多少</p>
<p>显然可以得到：<span class="math inline">\(g_i=max(f_{i\times
j-1}\bmod i)(1\leq j\;and\;i\times j\leq 1e5)\)</span></p>
<p>代码如下：（来自_plxer大佬)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> S = <span class="number">1e3</span>;</span><br><span class="line"><span class="type">int</span> mx[<span class="number">103</span>][N + <span class="number">5</span>], f[N + <span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> n, m, a[N + <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) a[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="type">int</span> num = (n - <span class="number">1</span>) / S;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= num; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">        <span class="type">int</span> l = i * S + <span class="number">1</span>, r = <span class="built_in">min</span>(n, (i + <span class="number">1</span>) * S);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = l; j &lt;= r; j ++) f[a[j]] = a[j];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= N; j ++) f[j] = <span class="built_in">max</span>(f[j - <span class="number">1</span>], f[j]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= N; j ++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= N; k += j)</span><br><span class="line">                mx[i][j] = <span class="built_in">max</span>(mx[i][j], f[<span class="built_in">min</span>(k + j - <span class="number">1</span>, N)] - k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, l, r, k; i &lt;= m; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        l = <span class="built_in">read</span>(); r = <span class="built_in">read</span>(); k = <span class="built_in">read</span>();</span><br><span class="line">        <span class="type">int</span> lx = (l - <span class="number">1</span>) / S, rx = (r - <span class="number">1</span>) / S;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = lx + <span class="number">1</span>; j &lt; rx; j ++) ans = <span class="built_in">max</span>(ans, mx[j][k]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = l; j &lt;= <span class="built_in">min</span>(r, (lx + <span class="number">1</span>) * S); j ++) ans = <span class="built_in">max</span>(ans, a[j] % k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="built_in">max</span>(l, rx * S + <span class="number">1</span>); j &lt;= r; j ++) ans = <span class="built_in">max</span>(ans, a[j] % k);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>关于数学</title>
    <url>/2020/07/03/%E5%85%B3%E4%BA%8E%E6%95%B0%E5%AD%A6/</url>
    <content><![CDATA[<p>对于“同余方程”“扩展欧几里得”“贝祖定理”“乘法逆元”以及“费马小定理”
<span id="more"></span> ### 同余方程</p>
<p>只是一个方程，形如<span class="math inline">\(a\times x\equiv c \pmod
b\)</span></p>
<h3 id="扩展欧几里得">扩展欧几里得</h3>
<p>是求解形如 <span class="math inline">\(a\times x+b\times y=
\gcd(a,b)\)</span>的<span class="math inline">\(x,y\)</span>的解</p>
<h3 id="贝祖定理">贝祖定理</h3>
<p>对于数<span class="math inline">\(a,b\)</span> 一定存在一对<span
class="math inline">\(x,y\)</span> 使得 <span
class="math inline">\(a\times x+b \times y=\gcd(a,b)\)</span></p>
<h3 id="乘法逆元">乘法逆元</h3>
<p>若<span class="math inline">\(a\times x \equiv 1 \pmod b\)</span>
并且<span class="math inline">\(a,b\)</span> 互质.我们就称<span
class="math inline">\(x\)</span> 为 <span
class="math inline">\(a\)</span> 在<span class="math inline">\(\pmod
b\)</span>意义下的乘法逆元,记为<span
class="math inline">\(a^{-1}\)</span></p>
<h3 id="费马小定理">费马小定理</h3>
<p>若 <span class="math inline">\(p\)</span> 是素数, <span
class="math inline">\(a\)</span> 是正整数,且<span
class="math inline">\(a,p\)</span> 互质</p>
<p>则<span class="math inline">\(a^{p-1}\equiv 1\pmod p\)</span></p>
<p>通俗的讲，扩展欧几里得是为了求解同余方程这种类型的题目而产生的，而贝祖定理（也叫裴蜀定理）证明了扩展欧几里得算法的正确性（证明其一定有解）</p>
<p>而乘法逆元是为了处理计算机不能很好的对除法进行运算，没法取倒数，而产生的一个新定义，在数学里面看起来就像是一个数的倒数，但是在计算机里面，这就是一个新定义，乘法逆元的符号就是<span
class="math inline">\(a^{-1}\)</span></p>
<p>并且求解乘法逆元用扩展欧几里得就好</p>
<p>即同余方程中 <span class="math inline">\(c\)</span> 等于 <span
class="math inline">\(1\)</span> 的情况</p>
<hr />
<p>8.31 update:</p>
<p>求解乘法逆元较多的是快速幂与乘法逆元，其中快速幂必须保证a，p互质</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线性：</span></span><br><span class="line">inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; p; ++ i)</span><br><span class="line">   inv[i] = (p - p / i) * inv[p % i] % p;</span><br><span class="line"><span class="comment">//快速幂</span></span><br><span class="line"><span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res = res * a % mod;</span><br><span class="line">   a = a * a % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">ksm</span>(a, p<span class="number">-2</span>, p);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学后感</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>冒泡排序</title>
    <url>/2020/10/22/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>题目大意：给定一个序列，问需要几轮冒泡排序之后才会得到一个合法序列（每一轮是指在一层for里面）<span id="more"></span></p>
<p>看到冒泡排序啥的就想逆序对</p>
<p>考虑冒泡排序的本质，每次都会把当前最大的挤到后边，然后把小的推到前边来，回想逆序对的定义，<strong>这个数字前面比它大的数字的个数</strong>，而比我大的数字，不都一定会到我后边吗？一次只会有一个到我后边，所以一定会<strong>至少</strong>有这么多<span
class="math inline">\(次数_{比我大的数字}​\)</span>轮数，然后取max即可</p>
<p>然后求逆序对的时候，本来是<span class="math inline">\(O(n\times
logn)​\)</span></p>
<p>但是鉴于这是个<strong>排列</strong>，且最后的数字一定是有序的</p>
<p>所以对于<span
class="math inline">\(i​\)</span>来说，逆序对个数就是这里本应该是的数字与这里实际是的数字的差（想一想，为什么）</p>
<p><span class="math inline">\(O(n)\)</span>求，实属niub</p>
<p>本应该是这里的数字意味着我前边应该有<span
class="math inline">\(i-1\)</span>个数字，但是我这里仅仅是<span
class="math inline">\(a[i]\)</span>，然后讨论一下<span
class="math inline">\(a[i]\)</span>的大小</p>
<ul>
<li><span class="math inline">\(a[i] &gt; i​\)</span>，说明有某一个<span
class="math inline">\(i&#39;​\)</span>在<span
class="math inline">\(i​\)</span>的后边，我们枚举到<span
class="math inline">\(i&#39;​\)</span>的时候会更新答案的，对我们的答案一定不会有影响</li>
<li><span
class="math inline">\(a[i]&lt;i​\)</span>，说明我前边一定有比我大的数字</li>
</ul>
<p>这个其实是一个很巧妙的思想，需要好好缓和两天</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e7</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, res;</span><br><span class="line">ll S, B, C, D;</span><br><span class="line"><span class="type">int</span> a[N], b[N], tree[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">chenge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; x &lt;= n; x += <span class="built_in">lowbit</span>(x)) tree[x] += c;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x)</span><br><span class="line">    &#123;</span><br><span class="line">        ret += tree[x];</span><br><span class="line">        x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"> </span><br><span class="line">    n = <span class="built_in">read</span>(), S = <span class="built_in">read</span>(), B = <span class="built_in">read</span>(), C = <span class="built_in">read</span>(), D = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i] = i;</span><br><span class="line">        S = (S * B + C) % D;</span><br><span class="line">        <span class="built_in">swap</span>(a[i], a[(S % i) + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//	cin &gt;&gt; n;</span></span><br><span class="line"><span class="comment">//	for (i = 1; i &lt;= n; ++ i) a[i] = read(); </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//		chenge(a[i], 1);</span></span><br><span class="line"><span class="comment">//		res = max(res, i - query(a[i]));</span></span><br><span class="line">        res = <span class="built_in">max</span>(res, i - a[i]); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">put</span>(res); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维题</tag>
      </tags>
  </entry>
  <entry>
    <title>军训站队</title>
    <url>/2020/10/01/%E5%86%9B%E8%AE%AD%E7%AB%99%E9%98%9F/</url>
    <content><![CDATA[<p>题目大意：小林和亮亮刚入高中，首先就迎来了军训。</p>
<span id="more"></span>
<p>用数学的语言来描述，如果把训练场看成一个平面直角坐标系，第 i
名同学所在位置的横坐标是 i，而所有同学的纵坐标本该是
0（或者任意一个相等的常量），这样就排成了一条直线。当然，由于同学们排的歪歪扭扭，所以第
i 位同学的横坐标依然是 i，而纵坐标却成了Yi
（为了简化问题，我们假设所有的坐标都是整数）。对此，教官当然十分生气，因此他决定下命令调整队伍，使得所有人能够站成一条直线（<strong>也即让所有的Yi
相同</strong>）。教官的命令总共有三种：</p>
<ul>
<li>除了某一个同学外，其余所有同学向前走一步（向前走一步可理解为Yi 的
值加 1，下同）</li>
<li>除了某一个同学外，其余所有同学向前走两步</li>
<li>除了某一个同学外，其余所有同学向前走五步。</li>
</ul>
<p>教官希望他能以最少的命令次数使得所有同学站成一条直线，但是他不会算，于是就让亮亮帮他来计算。亮亮虽然聪明，可是由于班上同学人数众多，他一下子也解决不了这个问题，只能来寻求会编程的你的帮助，你能告诉亮亮答案吗？</p>
<hr />
<p>很好的一道思维题，<strong>排成一条线是一个相对的概念，因此如果一个人不动，别的同学向前走q步的话，相当于这个人向后走q步</strong></p>
<p>所以对于三个指令，分别可以转化为：令Yi减1，减2，减5，所以当我们按升序给他们排序完毕之后，所有的Yi都应该减少至Y1，</p>
<p>Y1-1，Y1-2，Y1-3，Y1-4，这五个数之一（想一想，为什么）我们枚举所有的Yi应该减少到哪一个值，并计算出到达这一步的指令数目</p>
<p>求和，取min，即为答案，时间复杂度<span
class="math inline">\(O(n\times logn)\)</span>或者<span
class="math inline">\(O(n)​\)</span>（为啥？</p>
<p>至此问题大致已经解决，但是有个细节需要注意，为了防止减成负数，先给他加上那个贡献（见代码</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, <span class="built_in">res</span>(<span class="number">0</span>), ans;</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) a[i] = <span class="built_in">read</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = n; i &gt;= <span class="number">1</span>; -- i) a[i] -= a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) b[i] = a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">5</span>; ++ j)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) a[i] = b[i];</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) a[i] += j;<span class="comment">//here</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt;= <span class="number">5</span>) ans += a[i]/<span class="number">5</span>, a[i] %= <span class="number">5</span>;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt;= <span class="number">2</span>) ans += a[i]/<span class="number">2</span>, a[i] %= <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; <span class="number">0</span>) ans += a[i]/<span class="number">1</span>, a[i] %= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        res = ! j ? ans : <span class="built_in">min</span>(res, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">put</span>(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维题</tag>
      </tags>
  </entry>
  <entry>
    <title>初等函数</title>
    <url>/2022/09/21/%E5%88%9D%E7%AD%89%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>关于初等函数的相关知识</p>
<span id="more"></span>
<h1 id="基本初等函数">基本初等函数</h1>
<h2 id="常函数">常函数</h2>
<p>y = k</p>
<h2 id="幂函数">幂函数</h2>
<p><span class="math inline">\(y = x^u\)</span></p>
<p>共性：都经过(1,1),在$(0, inf) $上有意义</p>
<h2 id="指数函数">指数函数</h2>
<p><span class="math inline">\(y = a^x(a &gt;0, a \ne 1)\)</span></p>
<p><span class="math inline">\(x \in R\)</span></p>
<p><span class="math inline">\(y \in (0,inf)\)</span></p>
<p>过(1,0)</p>
<h2 id="对数函数">对数函数</h2>
<p><span class="math inline">\(y = log_ax\)</span></p>
<p><span class="math inline">\(x \in (0,inf)\)</span></p>
<p><span class="math inline">\(y \in R\)</span></p>
<p>过(0,1)</p>
<p>与指数函数互为反函数</p>
<h2 id="三角函数">三角函数</h2>
<h3 id="正余弦函数">正余弦函数</h3>
<p><span class="math inline">\(x \in R\)</span></p>
<p>周期都为<span class="math inline">\(2\pi\)</span></p>
<h3 id="正余切函数">正余切函数</h3>
<p>正切：<span class="math inline">\({x | x \ne k \pi + \dfrac{\pi}{2},
k \in Z }\)</span></p>
<p>余切</p>
<p><span class="math inline">\(y = cotx=\dfrac {cosx}{sinx}\)</span></p>
<p><span class="math inline">\(x | x \ne k\pi, k \in Z\)</span></p>
<p>周期都为<span class="math inline">\(\pi\)</span></p>
<h2 id="反三角函数">反三角函数</h2>
<p>根据反函数的定义要求</p>
<p>“单射”</p>
<p>所以一般来讲，三角函数并不满足此条件</p>
<p>但是我们可以考虑在某一段区间内，进行反函数的操作</p>
<h3 id="arcsin">arcsin</h3>
<p><span class="math inline">\(x \in [-1,1] ,y \in [-\dfrac{\pi}{2},
\dfrac{\pi}{2}]\)</span></p>
<h3 id="arccos">arccos</h3>
<p><span class="math inline">\(x \in [-1,1], y \in [0, \pi]\)</span></p>
<h3 id="arctan">arctan</h3>
<p><span class="math inline">\(x \in R, y \in (-\dfrac{\pi}{2},
\dfrac{\pi}{2})\)</span></p>
<h3 id="arccos-1">arccos</h3>
<p><span class="math inline">\(x \in R, y \in (0, \pi)\)</span></p>
<h1 id="函数的四则运算">函数的四则运算</h1>
<h2 id="和差积商">和差积商</h2>
<p><span class="math inline">\(f(x),x \in D_1,g(x), x \in D_2, \exists D
= D_1 \cap D_2 \ne NULL\)</span></p>
<p>则可以定义下面四个<span class="math inline">\(x \in
D\)</span>运算</p>
<p><span class="math inline">\(f + g : (f+ g)(x) = f(x) + g(x),x \in
D\)</span></p>
<p>但是在对商时</p>
<p>分母不可为零</p>
<h2 id="复合函数">复合函数</h2>
<p><span class="math inline">\(y = f(u), u \in D_1, u =
g(x)在D上有定义\)</span>，且<span class="math inline">\(g(D) \subset
D_1\)</span></p>
<p>则，由下式确定的函数 <span class="math display">\[
y = f[g(x)], x \in D
\]</span> 叫做由<span class="math inline">\(y = f(u), u =
g(x)\)</span>构成的复合函数，其中定义域为D，<strong><span
class="math inline">\(u\)</span></strong>叫做中间变量</p>
<p>记作<span class="math inline">\(f \circ g\)</span></p>
<p>前提条件：内层函数值域包含在外层函数定义域内</p>
<p>example <span class="math display">\[
\begin{aligned}
y = arcsin u\\
u = 2 + x^2\\
\end{aligned}
\]</span> 所以复合无意义</p>
<p>分解复合函数<span class="math inline">\(y = \sqrt {cot
\dfrac{x}{2}}\)</span> <span class="math display">\[
\begin{aligned}
y = \sqrt u \\
u = cot v \\
v = x^2\\
\end{aligned}
\]</span> 另一个案例<span class="math inline">\(y =
sin(e^{x^2})\)</span> <span class="math display">\[
\begin{aligned}
y = sin u \\
u = e^v \\
v = x^2\\
\end {aligned}
\]</span> 分解到最后，必须</p>
<ul>
<li>基本初等函数</li>
<li>基本初等函数经过四则运算得到的形式</li>
</ul>
<p>关于幂函数与指数函数，关键在于看自变量x的位置 <span
class="math display">\[
\begin{aligned}
y = x^u \rightarrow y = [g(x)] ^u\\
y = u^x \rightarrow y = u^{g(x)}\\
\end{aligned}
\]</span></p>
<h1 id="初等函数">初等函数</h1>
<p>定义：基本初等函数经过有限次的四则运算和有限次的复合运算得到的<strong>且有统一的解析表达式</strong>的函数叫做
<strong>初等函数</strong></p>
<p>根据定义我们可以知道分段函数不属于初等函数</p>
<h2 id="幂指函数">幂指函数</h2>
<p>形如<span class="math inline">\([f(x)]^{g(x)}\)</span>，其中<span
class="math inline">\(f(x)&gt;0\)</span>，称之为 幂指函数</p>
<p>幂指函数是初等函数</p>
<p>证明：</p>
<p>恒等式<span class="math inline">\(h(x) &gt; 0, h(x) = e^{ln
{h(x)}}\)</span></p>
<p>所以 <span class="math display">\[
\begin{aligned}
f(x)^{g(x)} \\
=e^{lnf(x)^{g(x)}} \\
=e^{g(x)lnf(x)}\\
\end{aligned}
\]</span></p>
<h1 id="隐函数">隐函数</h1>
<p>可以看得到表达式的函数叫做显函数</p>
<p>由二元方程<span
class="math inline">\(F(x,y)\)</span>所确定了一个定义在D上的函数，叫做
隐函数</p>
<p>如<span class="math inline">\(e^{xy} + x + y =
0\)</span>确定了一个隐函数<span class="math inline">\(y = f(x),x \in
D\)</span></p>
<p>隐函数的解析式一般写不出来</p>
<p>有时候也可以 <span class="math display">\[
x^2 + 2xy - 1 = 0
\]</span> 解方程 <span class="math display">\[
y = f(x) = \dfrac{1-x^2}{2x} , x\ne 0
\]</span></p>
]]></content>
      <categories>
        <category>Univ秋1</category>
      </categories>
      <tags>
        <tag>高数</tag>
      </tags>
  </entry>
  <entry>
    <title>区间第k大</title>
    <url>/2020/10/01/%E5%8C%BA%E9%97%B4%E7%AC%ACk%E5%A4%A7/</url>
    <content><![CDATA[<p>题目大意： 一个区间的价值定义为该区间中的最大值减最小值 给定 n
个数，求所有区间价值中，第 k 大值为多少。n是40万 <span id="more"></span>
显然对于一个右端点，左端点越靠左挪动，得到的价值，只能是递减或者是不降的</p>
<p>并且一定存在一个确切的位置，满足在这个位置左边（作为左端点）所得到的价值大于等于二分出来的mid，在这个位置右边一定小于</p>
<p>其中最大最小值用单调队列来维护</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">judge</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l1 = l2 = <span class="number">1</span>;</span><br><span class="line">    r1 = r2 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, l = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(l1 &lt;= r1 &amp;&amp; a[q1[r1]] &lt;= a[i]) r1 --;</span><br><span class="line">        <span class="keyword">while</span>(l2 &lt;= r2 &amp;&amp; a[q2[r2]] &gt;= a[i]) r2 --;</span><br><span class="line">        q1[++ r1] = i， q2[++ r2] = i;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; r1 &lt;&lt; &quot; &quot; &lt;&lt; r2 &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">while</span>(l1 &lt;= r1 &amp;&amp; l2 &lt;= r2 &amp;&amp; a[q1[l1]] - a[q2[l2]] &gt;= x)</span><br><span class="line">        &#123;</span><br><span class="line">            l ++;</span><br><span class="line">            <span class="keyword">if</span>(q1[l1] &lt; l) l1 ++;</span><br><span class="line">            <span class="keyword">if</span>(q2[l2] &lt; l) l2 ++;</span><br><span class="line">        &#125;</span><br><span class="line">        res += l - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res &gt;= k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (l &lt; r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> mid = (l + r + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">judge</span>(mid) &gt;= k)<span class="comment">//表示&gt;=x的数是否&gt;=k</span></span><br><span class="line">        l = mid;</span><br><span class="line">    <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意是mid=(l+r+1)/2</p>
<p>因为我们想得到的在小于等于某个范围内的最大值</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>博弈论</title>
    <url>/2020/07/02/%E5%8D%9A%E5%BC%88%E8%AE%BA/</url>
    <content><![CDATA[<p>今天学了博弈论 <span id="more"></span></p>
<h3 id="必胜态与必败态">必胜态与必败态</h3>
<p>必败态：</p>
<ul>
<li>我的后继状态全是必胜态</li>
</ul>
<p>无论我如何选择我的对手都将会面临必胜态，我显然必输</p>
<ul>
<li>我没有后继状态</li>
</ul>
<p>默认谁不能拿谁输，我已经不能拿了，我显然输了</p>
<p>必胜态：</p>
<ul>
<li>我的后继状态有一个是必败态，我就为必胜态</li>
</ul>
<p>因为大家都是绝顶聪明的，我肯定会选择使我的后继状态变为必败态（我的对手将要面临的状态）</p>
<p>通过必胜态与必败态，我们可以画出：</p>
<h3 id="博弈树">博弈树</h3>
<p>博弈树——和dfs树的一样数据量大</p>
<p>以巴什博弈为例子，</p>
<p><img
src="https://pic.imgdb.cn/item/6327d0ff16f2c2beb12772c4.png" /></p>
<h3 id="四大博弈">四大博弈</h3>
<ul>
<li>巴什博弈</li>
</ul>
<p>每一次只可以取一个或者两个，规定取走最后一个的人是胜者</p>
<p>变种：每一次最少取1个 最多取m个，两个人轮流取
规定谁取走最后一个就是人生赢家</p>
<p><span class="math inline">\(n\%(m+1) \neq
0\;?\;先手胜:后手胜\)</span></p>
<p>再变种，谁取到最后一个谁输</p>
<p><span class="math inline">\((n-1)\%(m+1) ==
0\;?\;后手胜\;：\;先手胜\)</span></p>
<ul>
<li><p>Nim游戏</p>
<p>n堆石子，每次可以在一堆里面取出一个或至多<span
class="math inline">\(a[i]\)</span>个</p></li>
</ul>
<p>结论：<span
class="math inline">\(a_1\;xor\;a_2\;xor\;a_3......xor\;a_n\;==\;0?后手胜：先手胜\)</span></p>
<ul>
<li>威佐夫博弈</li>
</ul>
<p>每次每个人可以从任意一堆石子中取任意多的石子，或者从两堆石子中取同样多的石子，不能取得人输</p>
<p>结论：当且仅当<span
class="math inline">\((x,y)(x&lt;y),(y-x)\times\dfrac {\sqrt 5 +1} {2} =
x\)</span>，先手必败</p>
<ul>
<li>斐波那契博弈</li>
</ul>
<p>有一堆个数为n的石子，A，B轮流取石子，满足：</p>
<p>(1)先手不能在<strong>第一次把所有的石子取完</strong>；</p>
<p>(2)之后每次可以取的石子数介于<strong>1到对手刚取的石子数的2倍</strong>之间
(包含1和对手刚取的石子数的2倍)</p>
<p>同之前的不同点就是:取的规则<strong>动态化</strong>，约定取走最后一个石子的就是赢家</p>
<p>结论：当且仅当n是斐波那契数字先手必败</p>
<hr />
<p>威佐夫博弈与斐波那契博弈没有变种，要么都是裸的</p>
<h3 id="sg函数">SG函数</h3>
<p>定义一个DAG，一个入度为零的点为起点，起点上有一个棋子，先/后手沿有向边，轮流移动，无法移动的人死</p>
<p>显然把博弈论弄到图论上了</p>
<ul>
<li>mex运算</li>
</ul>
<p>最小的，不属于 集合内的元素</p>
<ul>
<li>sg函数</li>
</ul>
<p>我们考虑对于当前的节点x，其有k条出边，每天出边的重点为<span
class="math inline">\(y_i\)</span></p>
<p>对于<span class="math inline">\(sg[x]\)</span>，其值为<span
class="math inline">\(y_{1...k}\)</span>所有取值的mex</p>
<p>若对于x这个状态，<span
class="math inline">\(sg[x]\)</span>为零，意味着x状态是必败的，否则就是必胜的</p>
<p>可以这么理解：</p>
<p><span class="math inline">\(sg[x]\)</span>为零，意味着</p>
<ul>
<li>要么自己没有初边，自己没有后继状态，显然必败</li>
<li>要么自己的初边<span
class="math inline">\(sg[y_i]\)</span>全部非零，自己的后继状态全部都是必胜，自己显然就是必败</li>
</ul>
<p><span class="math inline">\(sg[x]\)</span>非零，意味着</p>
<ul>
<li>自己的初边<span
class="math inline">\(sg[y_i]\)</span>一定有零，就是自己的后继状态一定有一个是必败，自己显然是必胜</li>
</ul>
<p>显然，<span
class="math inline">\(sg[x]\)</span>是必胜的，只要其有值即可，为什么不直接变成1，反而要找mex呢？</p>
<p>因为有sg定理：</p>
<ul>
<li><span class="math inline">\(SG_{tot}=SG(1)\ \ xor \ \ SG(2)\ \ xor \
\ SG(3)\ \ xor \ \ SG(4)\ \ xor \ \ ......\ \ xor \ \
SG(n)\)</span></li>
</ul>
<p>也就是游戏的sg值，为子游戏的sg值的异或和</p>
<p><strong>考虑时间戳优化</strong></p>
<p>hdu1848：</p>
<details>
<summary>
Code
</summary>
<pre><code>SG[0] = 0;
f[0] = 1,f[1] = 1 ;
for(i = 2; i <= 20; ++ i) f[i] = f[i - 1] + f[i - 2];
for(i = 1; i <= 1000; ++ i) &#123;
   ++ tot;
   for(j = 1; j <= 20; ++ j) if(i >= f[j]) vis[SG[i - f[j]]] = tot; 
   for(j = 0; ;++j) if(vis[j] != tot) &#123;SG[i] = j; break;&#125;
&#125;
while(1) &#123;
   cin >> x >> y >> z;
   if(!x && !y && !z) break; 
   res = SG[x] ^ SG[y] ^ SG[z];
   res ? puts("Fibo") : puts("Nacci");
&#125;
</code></pre>
</details>
<p>关于Anti-Nim，有结论：</p>
<ul>
<li><p>每一堆石子只有一个时 且异或和为0</p></li>
<li><p>存在至少一堆石子多于一个时 且异或和不为0</p></li>
</ul>
<p>给出<a
href="https://www.luogu.com.cn/problem/P4279">click</a>一个板子题目的代码</p>
<details>
<summary>
Code
</summary>
<pre><code>cin >> k;
while (k --> 0)
&#123;
   res = 0, ans = 0, pd = 0;
   cin >> n;
   for (i = 1; i <= n; ++ i)
   &#123;
      cin >> a[i];
      if (a[i] == 1) ++ res;
      ans ^= a[i];
   &#125;
   if ((res == n && ! ans) || (res != n && ans)) pd = 1;
   pd ? puts("John") : puts("Brother");
&#125;
</code></pre>
</details>
<p>关于Multi-Nim</p>
<ul>
<li><p>Multi-SG游戏规定
在符合拓扑原则的前提下一个单一游戏的后继可以是多个单一游戏</p></li>
<li><p>Multi-SG游戏其他规则同一般SG</p></li>
</ul>
<p>对于一个状态来讲</p>
<p>不同的划分方法会有多个不同的后继，而在一个后继当中会有多个独立的游戏</p>
<p>该后继状态SG值即为后继状态中独立游戏的异或和，该状态的SG值即为后继状态的mex</p>
<p>这里有个<a
href="https://www.luogu.com.cn/problem/P3185">click</a>一个板子题目</p>
<details>
<summary>
Code
</summary>
<pre><code>while (T --)
&#123;
   cin >> n;
   for (i = 1; i <= n; ++ i) cin >> a[i], sg[i] = 0;
   for (i = n - 1; i; -- i)
   &#123;
      memset(vis, 0, sizeof vis);
      for (j = i + 1; j <= n; ++ j) for (k = j; k <= n; ++ k) vis[sg[j] ^ sg[k]] = 1;
      for (j = 0; ; ++ j) if (! vis[j]) &#123;sg[i] = j; break;&#125;
   &#125;
   res = 0;
   for (i = 1; i <= n; ++ i) if (a[i] & 1) res ^= sg[i];
   if (! res) puts("-1 -1 -1\n0");
   else
   &#123;
      nx = 0, ny = 0, nz = 0, ans = 0;
      for (i = 1; i <= n; ++ i)
      for (j = i+1; j <= n; ++ j)
      for (k = j; k <= n; ++ k)
      if ((res ^ sg[i] ^ sg[j] ^ sg[k]) == 0)
      &#123;
         ++ ans;
         if (nx && ny && nz) continue;
         nx = i, ny = j, nz = k;
      &#125;
      printf ("%d %d %d\n%d\n", nx-1, ny-1, nz-1, ans);
   &#125;
&#125;
</code></pre>
</details>
<hr />
<p>至此，博弈论的相关知识叙述完毕，代码不难，难在思想的转换</p>
<p><span class="math inline">\(End...\)</span></p>
]]></content>
      <categories>
        <category>学后感</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>合并序列</title>
    <url>/2020/09/28/%E5%90%88%E5%B9%B6%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p>题目大意：合并k个序列为一个，满足本来在同一序列中的两个数的相对位置不变。
<span id="more"></span> 定义一个序列 A 的不和谐度为序列中使得A[i] &gt; A[i +
1]成立的 i
的总数，请输出一种，合并方案，使得合并后的序列不和谐度最小。</p>
<p><strong>Input:</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入的第一行包括一个整数 K。</span><br><span class="line">接下来 K 行，每数 5 个整数 Ni, Ai[1], xi, yi, pi描述一个序列。</span><br><span class="line">其中 Ni为序列长度，Ai[1]</span><br><span class="line">为序列第一个数字。序列中剩余元素的生成规则如下：对于j ≥ 2, A𝑖[j] = (A𝑖[j − 1] × x𝑖 +y𝑖)𝑚𝑜𝑑 p𝑖</span><br></pre></td></tr></table></figure>
<p><strong>Output:</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure>
<p><strong>题目分析：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">首先我们考虑把每个序列单拎出来看</span><br><span class="line">对于每一个序列，人为规定分成几块：保证每一个块里都是单调递增的</span><br><span class="line">纵观全局，每一个序列都被分成了几块，每一块都是单调递增的</span><br><span class="line">所以不同序列的对应的块在合并的时，也将会是单调递增的</span><br><span class="line">所以答案就是每一个序列的块的个数的最大值再减一</span><br></pre></td></tr></table></figure>
<p><strong>代码如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">s</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">w</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) w = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) s = s * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s * w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (! x) <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">num</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="type">char</span> c[<span class="number">66</span>];</span><br><span class="line">    <span class="keyword">while</span> (x) c[++ num] = x % <span class="number">10</span> + <span class="number">48</span>, x /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (num) <span class="built_in">putchar</span>(c[num --]);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> k, n;</span><br><span class="line"><span class="type">int</span> a[N], res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">calc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, <span class="built_in">ans</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i = j + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        j = i;</span><br><span class="line">        ++ ans;</span><br><span class="line">        <span class="keyword">while</span> (a[j] &lt; a[j + <span class="number">1</span>]) ++ j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, t; k = <span class="built_in">read</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (t = <span class="number">1</span>; t &lt;= k; ++ t)</span><br><span class="line">    &#123;</span><br><span class="line">        n = <span class="built_in">read</span>(), a[<span class="number">1</span>] = <span class="built_in">read</span>();</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>(), p = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; ++ i) a[i] = (a[i - <span class="number">1</span>] * x + y) % p;</span><br><span class="line">        res = <span class="built_in">max</span>(res, <span class="built_in">calc</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">put</span>(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维题</tag>
      </tags>
  </entry>
  <entry>
    <title>加减法</title>
    <url>/2020/09/28/%E5%8A%A0%E5%87%8F%E6%B3%95/</url>
    <content><![CDATA[<p>题目大意：在一个无向图里面每次可以选择一条边，使得这条边的一个端点加1，另一个端点减1</p>
<span id="more"></span>
<p>求<span class="math inline">\(\sum i\times val[i]\)</span></p>
<p><strong>题目分析：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">考虑在同一个联通块里面，可以随意分配名额，所以我们尽量使得编号大的权值最大就好</span><br></pre></td></tr></table></figure>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> to[N &lt;&lt; <span class="number">1</span>], nex[N &lt;&lt; <span class="number">1</span>], head[N], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    to[++ cnt] = y;</span><br><span class="line">    nex[cnt] = head[x];</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(head[x] = cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector &lt;<span class="type">int</span>&gt; v[N];</span><br><span class="line"><span class="type">int</span> n, m, L, tot;</span><br><span class="line"><span class="type">int</span> vis[N], val[N], w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, y;</span><br><span class="line">    w[num] += val[x], v[num].<span class="built_in">push_back</span>(x);</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = head[x]; i; i = nex[i])</span><br><span class="line">    &#123;</span><br><span class="line">        y = to[i];</span><br><span class="line">        <span class="keyword">if</span> (vis[y]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y, num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">fuck</span><span class="params">(<span class="type">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(v[x].<span class="built_in">begin</span>(), v[x].<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> s = v[x].<span class="built_in">size</span>(), <span class="built_in">ret</span>(<span class="number">0</span>), i, y;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; s; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        y = v[x][i];</span><br><span class="line">        val[y] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    w[x] -= s;</span><br><span class="line">    <span class="keyword">for</span> (i = s - <span class="number">1</span>; i &gt;= <span class="number">0</span>; -- i)</span><br><span class="line">    &#123;</span><br><span class="line">        y = v[x][i];</span><br><span class="line">        val[y] += <span class="built_in">min</span>(L - <span class="number">1</span>, w[x]);</span><br><span class="line">        <span class="keyword">if</span> (val[y] != L) w[x] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> w[x] -= (L - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (w[x] &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; s; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        y = v[x][i];</span><br><span class="line">        ret = ret + y * val[y];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, x, y, <span class="built_in">res</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>(), L = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) val[i] = <span class="built_in">read</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++ i) </span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">add_edge</span>(x, y), <span class="built_in">add_edge</span>(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="keyword">if</span> (! vis[i]) ++ tot, <span class="built_in">dfs</span>(i, tot);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= tot; ++ i) res += <span class="built_in">fuck</span>(i);</span><br><span class="line">    <span class="built_in">put</span>(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维题</tag>
      </tags>
  </entry>
  <entry>
    <title>回家打游戏</title>
    <url>/2020/11/14/%E5%9B%9E%E5%AE%B6%E6%89%93%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<p>题目大意：n个数字，上限为maxv，下限0，期间可以加减，问最后最大是多少<span id="more"></span></p>
<p>一眼看出来是dp，但是考场上tm推错式子了</p>
<p>我的错误式子：</p>
<p>状态：<span
class="math inline">\(f_{i,j}\)</span>表示前i个数字里面进行加操作j次所得到的最大值</p>
<p>转移：<span
class="math inline">\(f_{i,j}=max(f_{i-1,j}-a_i,f_{i-1,j-1}+a_i)\)</span></p>
<p>显然这是错的，因为有上限，并不满足无后效性。</p>
<p>关于无后效性的解释：</p>
<p>我当前所作出的选择与之后无关，及时我取最大值，但是之后的话可能取最小值会更优</p>
<p>正确的解法：</p>
<p>可达性背包（我自己起的）</p>
<p>状态：<span
class="math inline">\(f_{i,j}\)</span>表示前i个数字<strong>是否</strong>可以达到j这个大小</p>
<p>转移：<span class="math inline">\(f_{i,j} =
(f_{i-1,j+a_i},f_{i-1,j-a_i})\)</span></p>
<p>用第二位维度来表示权值</p>
<p>其实题面已经给了我们提示了：<strong>最大上线很小只有<span
class="math inline">\(3e4\)</span></strong></p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e4</span> + <span class="number">6</span>, G = <span class="number">2e3</span> + <span class="number">555</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, st, maxv;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">bool</span> f[G][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    n = <span class="built_in">read</span>(), st = <span class="built_in">read</span>(), maxv = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) a[i] = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    f[<span class="number">0</span>][st] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= maxv; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (j + a[i] &lt;= maxv) f[i][j] |= f[i - <span class="number">1</span>][j + a[i]];</span><br><span class="line">            <span class="keyword">if</span> (j - a[i] &gt;= <span class="number">0</span>) f[i][j] |= f[i - <span class="number">1</span>][j - a[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = maxv; i &gt;= <span class="number">0</span>; -- i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (f[n][i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">put</span>(i);</span><br><span class="line">            <span class="built_in">fclose</span>(stdin), <span class="built_in">fclose</span>(stdout);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">put</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动规</tag>
      </tags>
  </entry>
  <entry>
    <title>升降梯</title>
    <url>/2020/10/01/%E5%8D%87%E9%99%8D%E6%A2%AF/</url>
    <content><![CDATA[<p>题目大意：不要问我这个名字为什么这么奇怪。 <span id="more"></span> Nescafe
之塔一共有 N 层，升降梯在每层都有一个停靠点。手柄有 M 个控制 槽，第 i
个控制槽旁边标着一个数 Ci，满足 C1&lt;C2&lt;C3&lt;……&lt;CM。如果
Ci&gt;0， 表示手柄扳动到该槽时，电梯将上升 Ci 层；如果
Ci&lt;0，表示手柄扳动到该槽 时，电梯将下降-Ci 层；并且一定存在一个
Ci=0，手柄最初就位于此槽中。注 意升降梯只能在 1~N
层间移动，因此扳动到使升降梯移动到 1 层以下、 N 层以
上的控制槽是不允许的。 电梯每移动一层，需要花费 2
秒钟时间，而手柄从一个控制槽扳到相邻的槽， 需要花费 1
秒钟时间。探险队员现在在 1 层，并且想尽快到达 N 层，他们想知 道从 1 层到
N 层至少需要多长时间？</p>
<p>输入第一行两个正整数 N、 M。 第二行 M 个整数 C1、 C2……CM。
输出一个整数表示答案，即至少需要多长时间。若不可能到达输出-1。</p>
<p>对于 30% 的数据，满足 1≤N≤10， 2&lt;=M&lt;=5。 对于 100% 的数据，满足
1≤N≤1000， 2&lt;=M&lt;=20， -N&lt;C1&lt;C2&lt;……&lt;CM&lt;N</p>
<p>最短路，以楼层为点，转移为边，每个点有三种转移，向上向下和继续走，直接dij就可以</p>
<p>新技能：constructor（构造函数）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">yhm</span>(<span class="type">int</span> D = <span class="number">0</span>, <span class="type">int</span> X = <span class="number">0</span>, <span class="type">int</span> Y = <span class="number">0</span>) : <span class="built_in">d</span>(D), <span class="built_in">x</span>(X), <span class="built_in">y</span>(Y) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span> + <span class="number">66</span>, inf = <span class="number">214748364</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">s</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">w</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) w = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) s = s * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s * w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (! x) <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">num</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="type">char</span> c[<span class="number">66</span>];</span><br><span class="line">    <span class="keyword">while</span> (x) c[++ num] = x % <span class="number">10</span> + <span class="number">48</span>, x /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (num) <span class="built_in">putchar</span>(c[num --]);</span><br><span class="line">    <span class="comment">// return (void)(putchar(&#x27;\n&#x27;));</span></span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">res</span><span class="params">(inf)</span>, c[66]</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yhm</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> d, x, y;</span><br><span class="line">    <span class="comment">//constructor</span></span><br><span class="line">    <span class="built_in">yhm</span>(<span class="type">int</span> D = <span class="number">0</span>, <span class="type">int</span> X = <span class="number">0</span>, <span class="type">int</span> Y = <span class="number">0</span>) : <span class="built_in">d</span>(D), <span class="built_in">x</span>(X), <span class="built_in">y</span>(Y) &#123;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &gt; (<span class="type">const</span> yhm &amp;a) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> d &gt; a.d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> vis[N][<span class="number">66</span>], dis[N][<span class="number">66</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fuck</span><span class="params">(<span class="type">int</span> src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    priority_queue&lt;yhm, vector&lt;yhm&gt;, greater&lt;yhm&gt; &gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">yhm</span>(<span class="number">0</span>, <span class="number">1</span>, src));</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">    dis[<span class="number">1</span>][src] = <span class="number">0</span>;</span><br><span class="line">    vis[<span class="number">1</span>][src] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (! q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        x = q.<span class="built_in">top</span>().x, y = q.<span class="built_in">top</span>().y; q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// if (vis[x][y] == 1) continue;</span></span><br><span class="line">        vis[x][y] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (y != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> ny = y - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (dis[x][ny] &gt; dis[x][y] + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[x][ny] = dis[x][y] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (! vis[x][ny])</span><br><span class="line">                &#123;</span><br><span class="line">                    vis[x][ny] = <span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(<span class="built_in">yhm</span>(dis[x][ny], x, ny));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (y != m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> ny = y + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (dis[x][ny] &gt; dis[x][y] + <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[x][ny] = dis[x][y] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (! vis[x][ny])</span><br><span class="line">                &#123;</span><br><span class="line">                    vis[x][ny] = <span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(<span class="built_in">yhm</span>(dis[x][ny], x, ny));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> nx = x + c[y];</span><br><span class="line">        <span class="keyword">if</span> (nx &lt; <span class="number">1</span> || nx &gt; n) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (dis[nx][y] &gt; dis[x][y] + <span class="built_in">abs</span>(c[y]) * <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dis[nx][y] = dis[x][y] + <span class="built_in">abs</span>(c[y] * <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (! vis[nx][y])</span><br><span class="line">            &#123;</span><br><span class="line">                vis[nx][y] = <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(<span class="built_in">yhm</span>(dis[nx][y], nx, y));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, src;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        c[i] = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span> (c[i] == <span class="number">0</span>) src = i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">fuck</span>(src);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++ i) res = res &gt; dis[n][i] ? dis[n][i] : res;</span><br><span class="line">    </span><br><span class="line">    res == inf ? <span class="built_in">put</span>(<span class="number">-1</span>) : <span class="built_in">put</span>(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>图</title>
    <url>/2020/10/22/%E5%9B%BE/</url>
    <content><![CDATA[<p>题面大意：有一个无向图：共 n 个节点，编号分别为 1~n，同时有 m
条无向边。不同于他研究的树，图中边和点都有各自的权值，第 i 条边的边权为
wi，第 i 个点的点权为 ci。<span id="more"></span>从点 s 经过若干条边到点 t
的花费定义为：两点之间经过边的边权之和，加上经过的所有点（包括 s 和
t）的点权的最大值。现在 Makik 将给出 k 次询问，每次给出两个整数
s,t，询问从 s 到 t 的最小花费。（n属于250）</p>
<p>埋坑</p>
<p>大致意思就是看到数据范围很小，就联想Floyd</p>
<p>按权值从小到大转移，枚举转移点k（这种排序之后，把当前点作为最大权值的思想要学会借鉴）</p>
<p><span
class="math inline">\(dist(i,j)\)</span>表示i与j之间的距离，<span
class="math inline">\(ans(i,j)\)</span>表示i与j之间的答案</p>
<p>因为暴力转移需要枚举一个最大值，所以我们考虑用排序来优化</p>
<p>我们美剧k,i,j实际上就是在枚举编号这么做的好处就是最大点权一定在i,j,k三点之间（想一想为什么）</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> G = <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, K;</span><br><span class="line"><span class="type">int</span> dist[G][G], ans[G][G], c[G];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yhzhyhm</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val, id;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> yhzhyhm &amp;x) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> val &lt; x.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;yh[G];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FLOYD</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//	sort(yh + 1, yh + 1 + n, cmp);</span></span><br><span class="line">    <span class="built_in">sort</span>(yh + <span class="number">1</span>, yh + <span class="number">1</span> + n);</span><br><span class="line">    <span class="type">int</span> k, i, j;</span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= n; ++ k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[i][j] = <span class="built_in">min</span>(dist[i][j], dist[i][yh[k].id] + dist[yh[k].id][j]);</span><br><span class="line">                ans[i][j] = <span class="built_in">min</span>(ans[i][j], dist[i][j] + <span class="built_in">max</span>(yh[k].val, <span class="built_in">max</span>(c[i], c[j])));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, x, y, z;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>(), K = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">memset</span>(ans, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> ans), <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        yh[i].val = <span class="built_in">read</span>();</span><br><span class="line">        c[i] = yh[i].val, yh[i].id = i;</span><br><span class="line">        ans[i][i] = yh[i].val, dist[i][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>(), z = <span class="built_in">read</span>();</span><br><span class="line">        dist[x][y] = dist[y][x] = <span class="built_in">min</span>(dist[x][y], z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">FLOYD</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= K; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> s = <span class="built_in">read</span>(), t = <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">put</span>(ans[s][t]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>区间第k大模版题目</title>
    <url>/2020/11/18/%E5%8C%BA%E9%97%B4%E7%AC%ACk%E5%A4%A7%E6%A8%A1%E6%9D%BF%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<p>题目大意:给定一个序列求这个序列的第k大数字<span id="more"></span>,其中n属于1e7</p>
<p>我们显然可以直接sort一下,然后求解的话时间复杂度属于<span
class="math inline">\(O(nlogn)\)</span>,貌似不太优秀</p>
<p>所以STL有个函数就叫:nth_element()</p>
<p>用法:nth_element(a + 1, a + k, a + 1 + n, cmp)</p>
<p>并且是<span
class="math inline">\(O(n)\)</span>的,也就不必快速排序来求了</p>
<p>考虑快排的思想,每次分治的时候,都选择一个基准值,然后看有多少个数字大于这个基准值即为cnt,然后根据k与cnt的关系把区间一分为2递归到自己需要的区间</p>
<p>期望分log次,<span class="math inline">\(n +
n/2＋n/4...+1=O(n)\)</span></p>
<p>代码如下: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">nth_element</span>(a + <span class="number">1</span>, a + k, a + <span class="number">1</span> + n); </span><br><span class="line">    <span class="built_in">put</span>(a[k]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>后记:</p>
<p>在这里,我谨代表所有被快速排序坑过的人们,向快排发明者致以最崇高的问候和衷心的祝愿</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>地图</title>
    <url>/2020/10/22/%E5%9C%B0%E5%9B%BE/</url>
    <content><![CDATA[<p>题面大意：Makik 有一张详细的城市地图，地图标注了 L 个景区，编号为
1~L。而景区与景区之间建有单向高速通道。<span id="more"></span>这天，Makik
要去逛景区，他可以任选一个景区开始一天行程，且只能通过单向高速通道进入其他景区。至少要参观两个景区，游玩最后要回到起始景区。
如果 Makik 参观了第 i 个景区，会获得一个乐趣值
F_i。且参观过得景区不会再获得乐趣值。对于第 i 条单向高速通道，需要消耗
T_i 的时间，能够从 L1_i 到达
L2_i。为了简化问题，参观景区不需要花费时间，Makik
想要最终单位时间内获得的乐趣值最大。 请你写个程序，帮 Makik
计算一下他能得到的最大平均乐趣值。</p>
<p>显然我们最终的答案是一个简单环</p>
<p>然后推一下式子：</p>
<p>我们要最大化<span class="math display">\[ \dfrac {\sum v_i} {\sum
e_i}​\]</span></p>
<p>不妨让ans就是最大值，所以对于每一个环还可以转化为：</p>
<p><span class="math display">\[\dfrac {\sum v_i} {\sum e_i} \leq
ans\]</span></p>
<p><span class="math display">\[\sum v_i \leq ans \times \sum e_i = \sum
(ans \times e_i)\]</span></p>
<p><span class="math display">\[\sum( v_i  - ans \times e_i) \leq
0\]</span></p>
<p>然后考虑二分，如果图中没有一个正环，说明我们二分出来的足够大了，经过往小里面考虑</p>
<p>用spfa跑正权路，找正环就好</p>
<p>2020.10.23updata补：</p>
<p>其实关于正环负环的我也很蒙逼，感觉我写的也不太对劲</p>
<p>网上找了一篇码风码量都很棒的<a
href="https://www.cnblogs.com/19992147orz/p/7295652.html">博客</a></p>
<p>(我的)代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, f[N];</span><br><span class="line"><span class="type">int</span> mark, tag[N];</span><br><span class="line"><span class="type">double</span> dis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">double</span> ans)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, x, y;</span><br><span class="line">    <span class="keyword">for</span> (x = <span class="number">1</span>; x &lt;= n; ++ x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = head[x]; i; i = nex[i])</span><br><span class="line">        &#123;</span><br><span class="line">            y = ver[i];</span><br><span class="line">            val[i] = len[i] * ans - f[y];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">spfa</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tag[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> i, y;</span><br><span class="line">    <span class="keyword">for</span> (i = head[x]; i; i = nex[i])</span><br><span class="line">    &#123;</span><br><span class="line">        y = ver[i];</span><br><span class="line">        <span class="keyword">if</span> (dis[y] &gt; dis[x] + val[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (tag[y]) <span class="keyword">return</span> (<span class="type">void</span>)(mark = <span class="number">1</span>);</span><br><span class="line">            dis[y] = dis[x] + val[i];</span><br><span class="line">            <span class="built_in">spfa</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(tag[x] = <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">pd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) dis[i] = <span class="number">0</span>, tag[i] = <span class="number">0</span>;</span><br><span class="line">    mark = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">spfa</span>(i);</span><br><span class="line">        <span class="keyword">if</span> (mark) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, x, y, z;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) f[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>(), z = <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">add_edge</span>(x, y, z);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> l = <span class="number">0</span>, r = <span class="number">10000</span>, mid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; <span class="number">0.001</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">build</span>(mid);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">pd</span>()) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%.2lf&quot;</span>, l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>地雷</title>
    <url>/2020/10/09/%E5%9C%B0%E9%9B%B7/</url>
    <content><![CDATA[<p>记录自己的地雷</p>
<span id="more"></span>
<p>： （持续更新）</p>
<p>考试大方向：</p>
<ul>
<li>如果感觉暴力的性价比不高，或者感觉这题在自己的能力范围之内，不要想先写暴力，因为写完之后还要花时间调，就不如先想正解</li>
<li>务必对拍，无论这题难易如何，人脑难免会忽略很多细节问题</li>
<li>考试前两个题切掉，切不掉就一定是自己哪里出了问题，需要反思</li>
<li>暴力可千万别tm写挂</li>
<li>少听别人xbb啥，别人即使键盘敲得再响，也不能改变他这题究竟是爆零还是AC</li>
</ul>
<p>做题大方向：</p>
<ul>
<li>数据结构无用论</li>
<li>贪心和dp永远都是正道</li>
<li>多做思维题少做毒瘤题</li>
<li>可以不做新题，但是不可以不复习，孔子老人家说过：温故而知新，可以为师矣</li>
</ul>
<p>具体细节：</p>
<ul>
<li>即使#define int long
long遇到一些神奇的东西也要1ll（一些数学题）</li>
<li>遇事不决开ll（一些数据结构体）</li>
<li>求最大最小值，初始化一定要为极大/小值（树剖）</li>
<li>预处理数组，不要吝啬多处理一些（数学题）</li>
<li>在取mod的时候，不要写‘+=’,‘-=’可能会出问题（各种涉及到取模的题）</li>
<li>多组数据清空，还有少用memset，用多少，清空多少（各种多组数据题）</li>
<li>如果碰到精度问题，那就加一减一和原数字取最优值（贪心）</li>
<li>搜索题先写出来大致模型再去剪枝（搜索题）</li>
<li>模拟题至少花十分钟来审题，审题一定要仔细！（模拟题）</li>
<li>结论题大胆猜结论，对拍求证（结论题）</li>
<li>树上问题就要给自己一个知识体系，挨个筛选用哪一个算法（树上问题）</li>
</ul>
<p>最近更新时间：20.10.24</p>
]]></content>
      <categories>
        <category>地雷</category>
      </categories>
      <tags>
        <tag>地雷</tag>
      </tags>
  </entry>
  <entry>
    <title>填数游戏</title>
    <url>/2020/10/02/%E5%A1%AB%E6%95%B0%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<p>题目大意：小 Y 得到了一个长度为 𝑛 的画板和 𝑚
支画笔。经过尝试，他发现编号为 𝑖的画笔能够对画板的第 𝑙𝑖 格到第 𝑟𝑖
格染色。现在小 Y 有 𝑞 次询问，每次他想知道编号在 [𝑥, 𝑦]
内的画笔能否将画板上的区间 [𝑠,𝑡] 中的每一格都染色。</p>
<span id="more"></span>
<p>其实拿暴力分的话，做法很多，UFS，莫队套分块，莫队套线段树</p>
<p>正解的思想很巧妙，利用时间戳，可以很巧妙的计算完成这个区间最早需要的时间戳与他规定的开始时间</p>
<p>为什么只比较开始时间？想一想，为什么</p>
<p>因为他插进去vector的时候，就是在右端点插进去的，这样就保证了，他比较的时候，右端点一定相同</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yhm</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, l, r, id;</span><br><span class="line"><span class="comment">//constructor</span></span><br><span class="line">    <span class="built_in">yhm</span>(<span class="type">int</span> X = <span class="number">0</span>, <span class="type">int</span> L = <span class="number">0</span>, <span class="type">int</span> R = <span class="number">0</span>, <span class="type">int</span> ID = <span class="number">0</span>):<span class="built_in">x</span>(X), <span class="built_in">l</span>(L), <span class="built_in">r</span>(R), <span class="built_in">id</span>(ID)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SEGMENTTREE</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> tag, minv;</span><br><span class="line">&#125;tree[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">vector&lt;yhm&gt;vec[N];</span><br><span class="line"><span class="type">int</span> n, m, q;</span><br><span class="line"><span class="type">int</span> l[N], r[N], ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = p &lt;&lt; <span class="number">1</span>, r = (p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(tree[p].minv = <span class="built_in">min</span>(tree[l].minv, tree[r].minv));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = p &lt;&lt; <span class="number">1</span>, r = (p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>, c = tree[p].tag;</span><br><span class="line">    <span class="keyword">if</span> (! c) <span class="keyword">return</span>;</span><br><span class="line">    tree[l].tag = tree[l].minv = c;</span><br><span class="line">    tree[r].tag = tree[r].minv = c;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(tree[p].tag = <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">updata</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> nl, <span class="type">int</span> nr, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nl &lt;= l &amp;&amp; nr &gt;= r) <span class="keyword">return</span> (<span class="type">void</span>)(tree[p].minv = tree[p].tag = c);</span><br><span class="line">    <span class="built_in">down</span>(p);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (nl &lt;= mid) <span class="built_in">updata</span>(p &lt;&lt; <span class="number">1</span>, l, mid, nl, nr, c);</span><br><span class="line">    <span class="keyword">if</span> (nr &gt; mid) <span class="built_in">updata</span>((p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>, mid + <span class="number">1</span>, r, nl, nr, c);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(<span class="built_in">up</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> nl, <span class="type">int</span> nr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nl &lt;= l &amp;&amp; nr &gt;= r) <span class="keyword">return</span> tree[p].minv;</span><br><span class="line">    <span class="built_in">down</span>(p);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, res = <span class="number">0x7fffffff</span>;</span><br><span class="line">    <span class="keyword">if</span> (nl &lt;= mid) res = <span class="built_in">min</span>(res, <span class="built_in">query</span>(p &lt;&lt; <span class="number">1</span>, l, mid, nl, nr));</span><br><span class="line">    <span class="keyword">if</span> (nr &gt; mid) res = <span class="built_in">min</span>(res, <span class="built_in">query</span>((p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>, mid + <span class="number">1</span>, r, nl, nr));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>(), q = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++ i) l[i] = <span class="built_in">read</span>(), r[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= q; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, y, s, t;</span><br><span class="line">        x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>(), s = <span class="built_in">read</span>(), t = <span class="built_in">read</span>();</span><br><span class="line">        vec[y].<span class="built_in">push_back</span>(<span class="built_in">yhm</span>(x, s, t, i));</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">updata</span>(<span class="number">1</span>, <span class="number">1</span>, n, l[i], r[i], i);</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; (<span class="type">int</span>)vec[i].<span class="built_in">size</span>(); ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            ans[vec[i][j].id] = <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, vec[i][j].l, vec[i][j].r) &gt;= vec[i][j].x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= q; ++ i) <span class="built_in">put</span>(ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>坐车</title>
    <url>/2020/10/03/%E5%9D%90%E8%BD%A6/</url>
    <content><![CDATA[<p>题目大意：有 𝑛 个人想要坐车，线路可以抽象成一条数轴。 <span id="more"></span> 第
𝑖 个人想要从坐标 𝑠𝑖 坐到坐标 𝑡𝑖 。你的车从原点 0 出发，最终行驶到坐标 𝑚
。车上最多只能同时坐一个乘客，但你可以让乘客中途下车，只需保证最终将其送达他的目的地即可。在满足所有人的需求下，你行驶的最小总路程是多少呢？</p>
<p>考虑这个路程可以分为车上有人和车上没人，显然车上有人的话，其路程是一定的，无法更改</p>
<p>我们只好希望车上没人的路程尽量的小</p>
<p>所以我们对于每一个t，都希望找到一个全局最小的s，作为他的后继</p>
<p>并且需要把0与m放进去，其中0需要作为一个t，m需要作为一个s（可以这么想，我们到达第一个点，就是相当于从上一个终点过来的，而上一个终点就是0，m同理）</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">s</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">w</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) w = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) s = s * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s * w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (! x) <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">num</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="type">char</span> c[<span class="number">66</span>];</span><br><span class="line">    <span class="keyword">while</span> (x) c[++ num] = x % <span class="number">10</span> + <span class="number">48</span>, x /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (num) <span class="built_in">putchar</span>(c[num --]);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, res;</span><br><span class="line"><span class="type">int</span> s[N], t[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        s[i] = <span class="built_in">read</span>(), t[i] = <span class="built_in">read</span>();</span><br><span class="line">        res += <span class="built_in">abs</span>(s[i] - t[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s[<span class="number">0</span>] = m, t[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sort</span>(s, s + n + <span class="number">1</span>), <span class="built_in">sort</span>(t, t + n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= n; ++ i) res += <span class="built_in">abs</span>(s[i] - t[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">put</span>(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维题</tag>
      </tags>
  </entry>
  <entry>
    <title>嫌疑人</title>
    <url>/2020/11/25/%E5%AB%8C%E7%96%91%E4%BA%BA/</url>
    <content><![CDATA[<p>题目大意:每人可以投两个,boss说A和B是嫌疑人,但是会参考在场人们的建议.要至少p个人通过才能实施.(同意的条件:A或者B是这个人投的其中一个),问有多少种合法的无序方案<span id="more"></span></p>
<p>我们枚举其中一个,然后对另一个删边,减贡献,然后加上预处理好的后缀和</p>
<p>deg[i]表示i这个人被指定了多少次.</p>
<p>f[i]的含义只可意会,我第一次意识到我词穷了...</p>
<p>就是我们考虑选的这个点之后,我们把所有与这个点连边的点暂时全删了</p>
<p>把所有当前度数为delta(也就意味着当这个点与x不连之后,将没有贡献)的点统计答案</p>
<p>实在是一个思维好题</p>
<p>代码如下: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ver[N &lt;&lt; <span class="number">1</span>], nex[N &lt;&lt; <span class="number">1</span>], head[N], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++ cnt] = y;</span><br><span class="line">    nex[cnt] = head[x];</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(head[x] = cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, p, res;</span><br><span class="line"><span class="type">int</span> deg[N], f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, x, y;</span><br><span class="line">    n = <span class="built_in">read</span>(), p = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">add_edge</span>(x, y), <span class="built_in">add_edge</span>(y, x);</span><br><span class="line">        ++ deg[x], ++ deg[y];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) ++ f[deg[i]];</span><br><span class="line">    <span class="keyword">for</span> (i = n; i &gt;= <span class="number">1</span>; -- i) f[i] += f[i + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (x = <span class="number">1</span>; x &lt;= n; ++ x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> delta = p - deg[x];</span><br><span class="line">        <span class="keyword">if</span> (delta &lt;= <span class="number">0</span>) res += n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="built_in">k</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (deg[x] &gt;= delta) ++ k;</span><br><span class="line">            <span class="keyword">for</span> (i = head[x]; i; i = nex[i])</span><br><span class="line">            &#123;</span><br><span class="line">                y = ver[i];</span><br><span class="line">                <span class="keyword">if</span> (deg[y] == delta) ++ k;</span><br><span class="line">                -- deg[y];</span><br><span class="line">            &#125;</span><br><span class="line">            res += f[delta] - k;</span><br><span class="line">            <span class="keyword">for</span> (i = head[x]; i; i = nex[i])</span><br><span class="line">            &#123;</span><br><span class="line">                y = ver[i];</span><br><span class="line">                ++ deg[y];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">put</span>(res / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>后记:</p>
<p>傻逼std还用树状数组来维护...可恶!当时搞得我那么懵逼</p>
<p>细细想来一点也不难.</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维题</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>子集</title>
    <url>/2020/11/17/%E5%AD%90%E9%9B%86/</url>
    <content><![CDATA[<p>题目大意: 给定 L, R，令 <span
class="math inline">\(S[L,R]_{x}\)</span> 表示区间 <span
class="math inline">\([L,R]\)</span>内 x
的倍数组成的集合，形式化的，我们有<span class="math inline">\(S[L,R]_{x}
= {d|L ≤ d ≤ R,
x|d}\)</span><span id="more"></span>。定义一个集合的权值为这个集合中所有元素之和。那么，能否求出最小的
x，使得 <span class="math inline">\(S
[L,R]_x\)</span>有非空子集的权值和为 K 呢？虽然小 P
喜欢数学，但数学似乎并不喜欢他，所以他并不会这个问题。请你帮助小 P
解决他的问题。若无解，请输出 No Solution</p>
<p>10pts:直接暴力枚举</p>
<p>30pts:考虑当前x一定会求出对应的一个S,然后发现S中每一个元素都只会出现<span
class="math inline">\(2^{|S|-1}\)</span>个子集里面(我选了当前这个元素之后,在剩下的子集里面都可以选或者不选)因此S的价值=每一个元素*$2^{|S|
- 1}<span class="math inline">\(2,也就是\)</span>sum_S ^{|S| - 1}$</p>
<p>50pts:考虑当前x对应找到的S,其中一定每一个数字都是x的倍数,<strong>且一定是连续的x的倍数</strong>,再稍加分析就会得到每一个元素都是<span
class="math inline">\(k \times x\)</span>的形式其中<span
class="math inline">\((\lfloor\dfrac{l-1} { x }\rfloor \leq k \leq
\lfloor \dfrac {R} {x} \rfloor)\)</span>,所以<span
class="math inline">\(sum_S\)</span>就可以<span
class="math inline">\(O(1)\)</span>用等差数列求</p>
<p>100pts:数论分块</p>
<p>大致思想,对L内的分一下,对L至R内的分一下,总复杂度:<span
class="math inline">\(O(\sqrt L + \sqrt {(R - L)})\)</span></p>
<p>我们枚举(l-1)/x,r/x,也就是k的范围,然后可以求出这一段的和,然后通过判断这一段的长度以及反推出x总之就是各种判断以及计算来验证合法性,然后如果发现x合理就可以取min</p>
<p>实在是一道数论分块不可多得的好题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ll <span class="title">s</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">w</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) w = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) s = s * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s * w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">put</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (! x) <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">num</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="type">char</span> c[<span class="number">66</span>];</span><br><span class="line">    <span class="keyword">while</span> (x) c[++ num] = x % <span class="number">10</span> + <span class="number">48</span>, x /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (num) <span class="built_in">putchar</span>(c[num --]);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">yhm_func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> L, R, K, <span class="built_in">cnt</span>(<span class="number">0</span>), ans = (<span class="number">1ll</span> &lt;&lt; <span class="number">60</span>), x, i, j, sum;</span><br><span class="line">    L = <span class="built_in">read</span>(), R = <span class="built_in">read</span>(), K = <span class="built_in">read</span>();</span><br><span class="line">    x = K, -- L;</span><br><span class="line">    <span class="keyword">while</span> (x % <span class="number">2</span> == <span class="number">0</span>) x /= <span class="number">2</span>, ++ cnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= L; i = j + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l = L / i, r = R / i;</span><br><span class="line">        j = <span class="built_in">min</span>(L / l, R / r);</span><br><span class="line">        <span class="keyword">if</span> (r - l - <span class="number">1</span> &gt; cnt || r - l &lt;= <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        sum = K / (<span class="number">1ll</span> &lt;&lt; (r - l - <span class="number">1</span>)) * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (sum % (r - l)) <span class="keyword">continue</span>;</span><br><span class="line">        x = sum / (r - l);</span><br><span class="line">        <span class="keyword">if</span> (x % (l + r + <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">        x /= (l + r + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (l == L / x &amp;&amp; r == R / x) ans = <span class="built_in">min</span>(ans, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = L + <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= R; i = j + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = R / i;</span><br><span class="line">        j = R / r;</span><br><span class="line">        <span class="keyword">if</span> (r - l - <span class="number">1</span> &gt; cnt || r - l &lt;= <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        sum = K / (<span class="number">1ll</span> &lt;&lt; (r - l - <span class="number">1</span>)) * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (sum % (r - l)) <span class="keyword">continue</span>;</span><br><span class="line">        x = sum / (r - l);</span><br><span class="line">        <span class="keyword">if</span> (x % (l + r + <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">        x /= (l + r + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (l == L / x &amp;&amp; r == R / x) ans = <span class="built_in">min</span>(ans, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ans == (<span class="number">1ll</span> &lt;&lt; <span class="number">60</span>)) <span class="built_in">puts</span>(<span class="string">&quot;No Solution&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">put</span>(ans);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">    <span class="type">int</span> T = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span> (T --) <span class="built_in">yhm_func</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>处理细节</title>
    <url>/2020/12/02/%E5%A4%84%E7%90%86%E7%BB%86%E8%8A%82/</url>
    <content><![CDATA[<p>历来不确定的东西<span id="more"></span></p>
<ul>
<li>ST表</li>
</ul>
<p>注意细节:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> t = <span class="built_in">log</span>(n) / <span class="built_in">log</span>(<span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= t; ++ j) <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n - (<span class="number">1</span> &lt;&lt; j) + <span class="number">1</span>; ++ i)</span><br><span class="line">    f[i][j] = <span class="built_in">max</span>(f[i][j - <span class="number">1</span>], f[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">max</span>(f[l][k], f[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br></pre></td></tr></table></figure>
<ul>
<li>unsigned long long 与 long long</li>
</ul>
<p>unsigned long long</p>
<p>min: 0</p>
<p>max: <span class="math inline">\(2^{64} - 1\)</span></p>
<p>long long</p>
<p>min: <span class="math inline">\(-2^{63}\)</span></p>
<p>max: <span class="math inline">\(2^{63} - 1\)</span></p>
<ul>
<li>逆元</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ifac[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; p; ++ i)</span><br><span class="line">    ifac[i] = (p - p / i) * inv[p % i] % p;</span><br><span class="line">四字口诀:减除乘膜</span><br><span class="line"></span><br><span class="line">对于阶乘的最常用的:</span><br><span class="line">fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) fac[i] = fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">ifac[n] = <span class="built_in">ksm</span>(fac[i], mod - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; -- i) ifac[i] = ifac[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br></pre></td></tr></table></figure>
<ul>
<li>直径</li>
</ul>
<p>树上最长的一段距离.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">-1</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q; <span class="type">int</span> i, x, y;</span><br><span class="line">    dis[s] = <span class="number">0</span>, q.<span class="built_in">push</span>(s);</span><br><span class="line">    <span class="keyword">while</span> (! q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        x = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (i = head[x]; i; i = nex[i])</span><br><span class="line">        &#123;</span><br><span class="line">            y = ver[i];</span><br><span class="line">            <span class="keyword">if</span> (dis[y] == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            dis[y] = dis[x] + len[i];</span><br><span class="line">            <span class="comment">//树上路径唯一确定</span></span><br><span class="line">            q.<span class="built_in">push</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">bfs</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="keyword">if</span> (dis[i] &gt; dis[From]) From = i;</span><br><span class="line"><span class="built_in">bfs</span>(From);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="keyword">if</span> (dis[i] &gt; dis[To]) To = i;</span><br><span class="line">此时直径的端点就为:From与To</span><br></pre></td></tr></table></figure>
<ul>
<li>重心</li>
</ul>
<p>定义:对于树上的每一个点,计算其所有子树中最大的子树节点数,这个值最小的点就是这棵树的重心</p>
<p>性质:以树的重心为根时，所有子树的大小都不超过整棵树大小的一半</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">getroot</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, y;</span><br><span class="line">    f[x] = <span class="number">0</span>, siz[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = head[x]; i; i = nex[i])</span><br><span class="line">    &#123;</span><br><span class="line">        y = ver[i];</span><br><span class="line">        <span class="keyword">if</span> (v[y] || y == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">getroot</span>(y, x);</span><br><span class="line">        f[x] = <span class="built_in">max</span>(f[x], siz[y]);</span><br><span class="line">        siz[x] += siz[y];        </span><br><span class="line">    &#125;</span><br><span class="line">    f[x] = <span class="built_in">max</span>(f[x], yhm_size - f[x]); <span class="comment">//yhm_size为指定大小.</span></span><br><span class="line">    <span class="keyword">if</span> (f[x] &lt; f[rt]) rt = x;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">getroot</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>树剖求lca</li>
</ul>
<p>主要就是少处理dfn.别的和树剖一模一样</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, y; siz[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = head[x]; i; i = nex[i])</span><br><span class="line">    &#123;</span><br><span class="line">        y = ver[i];</span><br><span class="line">        <span class="keyword">if</span> (y == fa[x]) <span class="keyword">continue</span>;</span><br><span class="line">        fa[y] = x;</span><br><span class="line">        dep[y] = dep[x] + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(y);</span><br><span class="line">        siz[x] += siz[y];</span><br><span class="line">        <span class="keyword">if</span> (siz[y] &gt; siz[son[x]]) son[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> yhm_top)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, y; top[x] = yhm_top;</span><br><span class="line">    <span class="keyword">if</span> (! son[x]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(son[x], yhm_top);</span><br><span class="line">    <span class="keyword">for</span> (i = head[x]; i; i = nex[i])</span><br><span class="line">    &#123;</span><br><span class="line">        y = ver[i];</span><br><span class="line">        <span class="keyword">if</span> (y == fa[x] || y == son[x]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(y, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (top[x] != top[y])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[top[x]] &lt; dep[top[y]]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[x] &lt; dep[y] ? x : y;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>exgcd</li>
</ul>
<p>式子自己推推就好,主要是这里值的一步步代入.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (! b) <span class="keyword">return</span> (<span class="type">void</span>)(x = <span class="number">1</span>, y = <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">calc</span>(b, a % b);</span><br><span class="line">    <span class="type">int</span> tx = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = tx - a / b * x;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>差分约束与负环</li>
</ul>
<p>好像有两种建边方式都可以.</p>
<p>我只写一种:</p>
<p>如果<span class="math inline">\(a - b &gt;= c\)</span>,意味着<span
class="math inline">\(a &gt;= b + c\)</span></p>
<p>所以由b出发连一条向a边,边权为c</p>
<p>然后跑最长路就可以了</p>
<p>判断负环两个细节:</p>
<blockquote>
<p>必须在判断vis里面判断</p>
</blockquote>
<blockquote>
<p>必须判断次数是否<strong>大于n</strong></p>
</blockquote>
<p>以<a
href="https://www.luogu.com.cn/problem/P1993">小k的农场</a>一题为例,代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, x, y; <span class="built_in">memset</span>(dis, <span class="number">0xcf</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">    dis[<span class="number">0</span>] = <span class="number">0</span>, vis[<span class="number">0</span>] = cishu[<span class="number">0</span>] = <span class="number">1</span>, q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (! q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        x = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[x] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = head[x]; i; i = nex[i])</span><br><span class="line">        &#123;</span><br><span class="line">            y = ver[i];</span><br><span class="line">            <span class="keyword">if</span> (dis[y] &lt; dis[x] + len[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[y] = dis[x] + len[i];</span><br><span class="line">                <span class="keyword">if</span> (! vis[y])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (++ cishu[y] &gt; n) <span class="keyword">return</span> (<span class="type">void</span>)(pd = <span class="number">1</span>);</span><br><span class="line">                    vis[y] = <span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, a, b, c, opt;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m --)</span><br><span class="line">    &#123;</span><br><span class="line">        opt = <span class="built_in">read</span>(), a = <span class="built_in">read</span>(), b = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>) c = <span class="built_in">read</span>(), <span class="built_in">add_edge</span>(b, a, c);</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">2</span>) c = <span class="built_in">read</span>(), <span class="built_in">add_edge</span>(a, b, -c);</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">3</span>) <span class="built_in">add_edge</span>(a, b, <span class="number">0</span>), <span class="built_in">add_edge</span>(b, a, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">add_edge</span>(<span class="number">0</span>, i, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">spfa</span>();</span><br><span class="line"></span><br><span class="line">    pd == <span class="number">1</span> ? <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>) : <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>筛各种东西</li>
</ul>
<blockquote>
<p>首先是筛<span class="math inline">\(\phi\)</span></p>
</blockquote>
<p>定义:</p>
<p><span class="math display">\[
\phi(i) = \sum_{i=1}^n\gcd(i,n)==1
\]</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pres_dou</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    </span><br><span class="line">    v[<span class="number">1</span>] = <span class="number">1</span>, phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; N; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (! v[i]) pri[++ cnt] = i, phi[i] = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * pri[j] &lt; N; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            v[i * pri[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (! (i % pri[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                phi[i * pri[j]] = phi[i] * pri[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> phi[i * pri[j]] = phi[i] * (pri[j] - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其次是筛<span class="math inline">\(\mu\)</span></p>
</blockquote>
<p>定义:</p>
<p><span class="math display">\[
\mu(n)=
\begin{cases}
1&amp;n=1\\
0&amp;n\text{ 含有平方因子}\\
(-1)^k&amp;k\text{ 为 }n\text{ 的本质不同质因子个数}\\
\end{cases}
\]</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pres_dou</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j; v[<span class="number">1</span>] = <span class="number">1</span>, mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; N; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (! v[i]) pri[++ cnt] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * pri[j] &lt; N; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            v[i * pri[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (! (i % pri[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                mu[i * pri[j]] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> mu[i * pri[j]] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>mess</category>
      </categories>
      <tags>
        <tag>坑点</tag>
      </tags>
  </entry>
  <entry>
    <title>奇偶路径(换根dp)</title>
    <url>/2020/10/09/%E5%A5%87%E5%81%B6%E8%B7%AF%E5%BE%84(%E6%8D%A2%E6%A0%B9dp)/</url>
    <content><![CDATA[<p>题目大意：对于正整数 𝑎, 𝑏 定义函数 𝑓(𝑎, 𝑏) 表示将 𝑎 和 𝑏
用二进制表示后二者不同位的个数。现给出一棵 𝑛 个点的树，点有点权 𝑎𝑖 ，点
𝑖 与点 𝑗 的距离 𝑑𝑖𝑠(𝑖,𝑗)
定义为两点间最短路经过的边数。询问共有多少点对满足 𝑓(𝑎𝑖, 𝑎𝑗) 与 𝑑𝑖𝑠(𝑖,𝑗)
的奇偶性不同</p>
<span id="more"></span>
<p>首先鸣谢<a href="https://www.cnblogs.com/wsdslll/">Tethys大佬</a></p>
<p><del>大佬说</del>一眼看出是个换根dp</p>
<p>无论从图论还是dp的角度来说，这都是一道不可多得的好题</p>
<p>考虑对于一个节点x，一个能与他组成点对并造成贡献的点必定属于以下两种：</p>
<ul>
<li>距离x奇数条边，且<span class="math inline">\(a_i\)</span>与<span
class="math inline">\(a_x\)</span>有偶数位不同</li>
<li>距离x偶数条便，且<span class="math inline">\(a_i\)</span>与<span
class="math inline">\(a_x\)</span>有奇数位不同</li>
</ul>
<p>然后考虑x与其儿子y，y如何继承来自x的价值？</p>
<p><strong>显然：x与y只差着一条边，如果一个点需要经历奇数条边才能到达x，那么此点需要经历偶数条边才能到达y，反之亦然</strong></p>
<p>如果发现<span class="math inline">\(a_x\)</span>与<span
class="math inline">\(a_y\)</span>有奇数位不同，可以转化为：原来与x这个点的权值有偶数位不同的点，现在与y这个点有奇数位不同</p>
<p>如果发现<span class="math inline">\(a_x\)</span>与<span
class="math inline">\(a_y\)</span>有偶数位不同，可以转化为：原来与x这个点的权值有奇数位不同的点，现在与y这个点有偶数位不同</p>
<p>证明：</p>
<p>在<span class="math inline">\(a_x\)</span>与<span
class="math inline">\(a_y\)</span>有奇数位不同的情况下，设另一个点为t，且<span
class="math inline">\(a_t\)</span>与<span
class="math inline">\(a_x\)</span>有偶数位不同，偶数位？我们设为0</p>
<p><strong>显然</strong>此时<span
class="math inline">\(a_y\)</span>与<span
class="math inline">\(a_t\)</span>有奇数位不同，反之依然</p>
<p>这种类比化一的思想太niub了</p>
<p>特判除了1的情况，别的情况就都可以继承啦！</p>
<p>最后除以2的原因是因为我们的答案计算了两遍，设想在一个点<span
class="math inline">\(l\)</span>的时候，肯定计算了另一个点<span
class="math inline">\(r\)</span>所带来的贡献，在<span
class="math inline">\(r\)</span>的时候，又再次计算了<span
class="math inline">\(l\)</span>的贡献，而本质上<span
class="math inline">\(f(a,b)=f(b,a)\)</span>所以理所应当的除以2</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">s</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">w</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) w = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) s = s * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s * w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (! x) <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">num</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="type">char</span> c[<span class="number">66</span>];</span><br><span class="line">    <span class="keyword">while</span> (x) c[++ num] = x % <span class="number">10</span> + <span class="number">48</span>, x /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (num) <span class="built_in">putchar</span>(c[num --]);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ver[N &lt;&lt; <span class="number">1</span>], nex[N &lt;&lt; <span class="number">1</span>], head[N &lt;&lt; <span class="number">1</span>], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++ cnt] = y;</span><br><span class="line">    nex[cnt] = head[x];</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(head[x] = cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, res;</span><br><span class="line"><span class="type">int</span> a[N], f[N], h[N], dep[N], fa[N]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">fuck</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x || y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((x &amp; <span class="number">1</span>) != (y &amp; <span class="number">1</span>)) ++ ret;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>, y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> yhm_fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((dep[x] &amp; <span class="number">1</span>) != (<span class="built_in">fuck</span>(a[<span class="number">1</span>], a[x]) &amp; <span class="number">1</span>))</span><br><span class="line">        ++ h[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> ++ f[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i, y;</span><br><span class="line">    <span class="keyword">for</span> (i = head[x]; i; i = nex[i])</span><br><span class="line">    &#123;</span><br><span class="line">        y = ver[i];</span><br><span class="line">        <span class="keyword">if</span> (y == yhm_fa) <span class="keyword">continue</span>;</span><br><span class="line">        fa[y] = x;</span><br><span class="line">        dep[y] = dep[x] + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">build</span>(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, y;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res += h[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (i = head[x]; i; i = nex[i])</span><br><span class="line">        &#123;</span><br><span class="line">            y = ver[i];</span><br><span class="line">            <span class="built_in">dfs</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fuck</span>(a[fa[x]], a[x]) &amp; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            h[x] = h[fa[x]];</span><br><span class="line">            f[x] = f[fa[x]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            h[x] = f[fa[x]];</span><br><span class="line">            f[x] = h[fa[x]];</span><br><span class="line">        &#125;</span><br><span class="line">        res += h[x];</span><br><span class="line">        <span class="keyword">for</span> (i = head[x]; i; i = nex[i])</span><br><span class="line">        &#123;</span><br><span class="line">            y = ver[i];</span><br><span class="line">            <span class="keyword">if</span> (y == fa[x]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, x, y;</span><br><span class="line"></span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">add_edge</span>(x, y), <span class="built_in">add_edge</span>(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) a[i] = <span class="built_in">read</span>();</span><br><span class="line">    </span><br><span class="line">    f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">0</span>), <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">put</span>(res / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title>对拍</title>
    <url>/2020/10/27/%E5%AF%B9%E6%8B%8D/</url>
    <content><![CDATA[<p>关于对拍<span id="more"></span></p>
<p>自己也是学过OI的人，怕自己哪一天退役了都悄无声息，就仿佛没有来过一样，因此想尽可能的，在自己的心里留下自己存在过的回忆…</p>
<h3 id="第一步">第一步</h3>
<p>建一个名字叫做duipai的文件夹</p>
<h3 id="第二步">第二步</h3>
<p>在文件夹下放入名为b.cpp，z.cpp，shuju.cpp，分别为自己的暴力，正解，和随机数据</p>
<p>并分别建立对应的txt文档</p>
<p>注意：请分别运行出exe文件！</p>
<p><img
src="https://pic.downk.cc/item/5f981b971cd1bbb86b3040ae.png" /></p>
<h3 id="第三步">第三步</h3>
<p>写对拍程序：</p>
<p>给出一种模板：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;shuju.exe &gt; shuju.txt&quot;</span>);</span><br><span class="line">        <span class="type">double</span> t1 = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;b.exe &lt; shuju.txt &gt; b.txt&quot;</span>);</span><br><span class="line">        <span class="type">double</span> t2 = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;z.exe &lt; shuju.txt &gt; z.txt&quot;</span>);</span><br><span class="line">        <span class="type">double</span> t3 = <span class="built_in">clock</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">system</span>(<span class="string">&quot;fc b.txt z.txt&quot;</span>)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;%d %d %d\n&quot;</span>, ++ i, (<span class="type">int</span>)(t2 - t1), (<span class="type">int</span>)(t3 - t2));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;ERROR!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><span class="math inline">\(system(&quot;shuju.exe &gt;
shuju.txt&quot;)\)</span>可以形象理解为，把exe的东西流向txt，也就是输入进去</li>
<li><span class="math inline">\(system(&quot;b.exe &lt; shuju.txt &gt;
b.txt&quot;)\)</span>把txt文档里面的内容流到b.exe里面去，并把其答案输出到b.txt</li>
<li><span class="math inline">\(system(&quot;z.exe &lt; shuju.txt &gt;
z.txt&quot;)\)</span>同理</li>
</ul>
<p>别的自己理解不难</p>
<p><strong>一个很有用的小细节：有时候打开对拍程序，他会一动不动的，所以我们每次修改完b.cpp/z.cpp/shuju.cpp之后都要在对拍程序里面随机修改一个地方，并保存，比如说，我可以每次删去一个分号，再加上，告诉系统我们已经修改过，然后再运行就会正常对拍了</strong></p>
<hr />
<p>预祝每一个进行对拍的同学，都可以得到自己满意的结果</p>
]]></content>
      <categories>
        <category>mess</category>
      </categories>
      <tags>
        <tag>对拍</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串匹配</title>
    <url>/2020/10/23/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<p>题目大意：对于一个字符集大小为<span
class="math inline">\(C\)</span>的字符串<span
class="math inline">\(P\)</span>，我们可以将任意两种字符在<span
class="math inline">\(P\)</span>中的位置进行交换，例如<span
class="math inline">\(P\)</span>=<span
class="math inline">\(abcba\)</span>，我们交换<span
class="math inline">\(a,b\)</span>就变为了<span
class="math inline">\(bacab\)</span>，交换<span
class="math inline">\(a,d\)</span>就变为了<span
class="math inline">\(dbcbd\)</span>，交换可以进行任意多次。<span id="more"></span>若交换后<span
class="math inline">\(P\)</span>变为了字符串<span
class="math inline">\(Q\)</span>，则我们称字符串<span
class="math inline">\(Q\)</span>和<span
class="math inline">\(P\)</span>为匹配的现在给定两个字符集的大小为<span
class="math inline">\(C\)</span>的字符串<span
class="math inline">\(S,T\)</span>，请你求出<span
class="math inline">\(S\)</span>中有多少个连续子串与<span
class="math inline">\(T\)</span>匹配</p>
<p>考虑KMP的本质，是对完全相同的字符串进行匹配，而我们这里呢是对相对位置的匹配</p>
<p>将要求改为两个字符上一次出现的相对位置相同 (即位置差值) 即可</p>
<p>考察知识点：KMP的转化</p>
<p>不难，考场上应该想出来，但是心态爆炸了，没想到</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, t;</span><br><span class="line"><span class="type">int</span> a[N], b[N];</span><br><span class="line"><span class="type">int</span> nex[N], xa[N], xb[N], f[N], q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pres_dou</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">memset</span>(nex, <span class="number">0</span>, <span class="keyword">sizeof</span> nex);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i] = <span class="built_in">read</span>();</span><br><span class="line">        xa[i] = i - nex[a[i]], nex[a[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(nex, <span class="number">0</span>, <span class="keyword">sizeof</span> nex);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        b[i] = <span class="built_in">read</span>();</span><br><span class="line">        xb[i] = i - nex[b[i]], nex[b[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t = xb[m + <span class="number">1</span>] = <span class="number">0</span>; <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= m; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; <span class="built_in">min</span>(j + <span class="number">1</span>, xb[i]) != xb[j + <span class="number">1</span>]) j = f[j];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">min</span>(j + <span class="number">1</span>, xb[i]) == xb[j + <span class="number">1</span>]) ++ j;</span><br><span class="line">        f[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; <span class="built_in">min</span>(j + <span class="number">1</span>, xa[i]) != xb[j + <span class="number">1</span>]) j = f[j];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">min</span>(j + <span class="number">1</span>, xa[i]) == xb[j + <span class="number">1</span>]) ++ j;</span><br><span class="line">        <span class="keyword">if</span> (j == m) q[++ t] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">put</span>(t);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= t; ++ i) <span class="built_in">printf</span> (<span class="string">&quot;%d &quot;</span>, q[i] - m + <span class="number">1</span>); <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> T = <span class="built_in">read</span>(), C = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span> (T --) <span class="built_in">pres_dou</span>(), <span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>小R与排列</title>
    <url>/2020/10/28/%E5%B0%8FR%E4%B8%8E%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<p>题目大意：小 R 有 n 和一个 1～n
的排列，想求它的下一个排列（下一个排列的定义是：1～n
的所有全排列按字典序排好后，排在 A 后面的那个叫做 A
的下一个排列。字典序中最后一个排列的下一个排列认为是字典序中第一个排列）。<span id="more"></span></p>
<p>一眼题，从后往前找到第一个递减的，然后从这个递减的下标开始到结束找第一个大于it的</p>
<p>前边的不用管，直接输出就可以</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, top, tag;</span><br><span class="line">set&lt;<span class="type">int</span>&gt;s;</span><br><span class="line"><span class="type">int</span> a[N], sta[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i; n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) a[i] = <span class="built_in">read</span>();</span><br><span class="line">    sta[++ top] = a[n], s.<span class="built_in">insert</span>(a[n]);</span><br><span class="line">    <span class="keyword">for</span> (i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; -- i)</span><br><span class="line">    &#123;</span><br><span class="line">        s.<span class="built_in">insert</span>(a[i]);</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; sta[top]) sta[++ top] = a[i];</span><br><span class="line">        <span class="keyword">else</span> &#123;tag = i; <span class="keyword">break</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; tag; ++ i) <span class="built_in">put</span>(a[i]);</span><br><span class="line">    <span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); ++ it)</span><br><span class="line">        <span class="keyword">if</span> (*it &gt; a[tag]) &#123;<span class="built_in">put</span>(*it), s.<span class="built_in">erase</span>(it); <span class="keyword">break</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); ++ it) <span class="built_in">put</span>(*it);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fclose</span>(stdin), <span class="built_in">fclose</span>(stdout);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>小R与怪病</title>
    <url>/2020/10/27/%E5%B0%8FR%E4%B8%8E%E6%80%AA%E7%97%85/</url>
    <content><![CDATA[<p>题目大意：小镇上有 n
个人得了一种奇怪的病，他们两两熟悉并且可接触。现在有一种疫苗可以治愈这种疾病，小
R
作为镇长，希望可以利用小镇财政为他们治病。<span id="more"></span>这种疫苗有种奇怪的特性，可以通过病人间的接触接种（即一个接种过的病人
i接触一个未接种过的病人 j，则后者也被接种，费用是
pij）。当然也可以通过医护人员直接接种（费用是
ai）。上述两种方法对不同人的费用是不同的，现在小R
拿到了医护人员提供的费用明细（每个人通过直接接种和其他人接触接种的费用），求助你为他提供一个所有人都接种的最小总费用。</p>
<p>连个超极源点，最小生成树板子题目</p>
<p>注意坑点：</p>
<ul>
<li>边的数组需要开到N*N</li>
<li>并查集路径压缩</li>
<li><span class="math inline">\(fa[fx] = fy\)</span>不要搞错顺序</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">333</span>, inf = <span class="number">214748364</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, ycnt, num, res;</span><br><span class="line"><span class="type">int</span> fa[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yhzhyhm</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y, z;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> yhzhyhm &amp;yhm) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> z &lt; yhm.z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;yh[N * N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">yhm_find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = <span class="built_in">yhm_find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j; n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) fa[i] = i; fa[<span class="number">306</span>] = <span class="number">306</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> val = <span class="built_in">read</span>();</span><br><span class="line">        yh[++ ycnt].x = <span class="number">306</span>, yh[ycnt].y = i, yh[ycnt].z = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> val = <span class="built_in">read</span>();</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= j) <span class="keyword">continue</span>;</span><br><span class="line">            yh[++ ycnt].x = i, yh[ycnt].y = j;</span><br><span class="line">            yh[ycnt].z = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(yh + <span class="number">1</span>, yh + <span class="number">1</span> + ycnt);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= ycnt; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = yh[i].x, y = yh[i].y, z = yh[i].z;</span><br><span class="line">        <span class="type">int</span> fx = <span class="built_in">yhm_find</span>(x), fy = <span class="built_in">yhm_find</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (fx == fy) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        fa[fx] = fy;</span><br><span class="line">        res += yh[i].z;</span><br><span class="line">        ++ num;</span><br><span class="line">        <span class="keyword">if</span> (num == n) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">put</span>(res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>密码游戏</title>
    <url>/2020/11/14/%E5%AF%86%E7%A0%81%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<p>题目大意：YJC 很喜欢玩游戏，今天他决定和朋友们玩密码游戏。<span id="more"></span>
密码游戏的规则是这样的：初始时有两个大小为 m 的数组a 和b，分别是 0~m-1
的一个排列。每 一次操作在 0~m-1 之间选一个数 x，求出结果 y=b[a[x]]，把x
和y 写下来。之后，a 数组向前循环移动
一次，即(a[0],a[1],...,a[m-2],a[m-1])变成(a[1],a[2],...,a[m-1],a[0])。当a
数组变回初始状态时，b数组 向前循环移动一次。现在知道所有的 x
和y，如果YJC 能求出任意一组符合条件的 a 和b 的初值，YJC 就赢了。 YJC
很想赢得游戏，但他太笨了，他想让你帮他算出 a 和 b 的初值</p>
<p>这题正解推式子，不会</p>
<p>但是会暴力</p>
<p>代码没有自己写，太累了…</p>
<p>大致思想呢就是：先预处理出来一个映射数组，然后后正常的搜索一样有边界有回溯只不过这个回溯和递归比较操蛋</p>
<p>写的代码也多</p>
<p>我其实也不太透彻，慢慢消化吧</p>
<p>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">66</span>, G = <span class="number">1e5</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N], b[N]; <span class="type">bool</span> aa[N], bb[N], key; <span class="comment">//在a中某一个数是否被使用过</span></span><br><span class="line"><span class="type">int</span> n, m, cnt, dx, dy;</span><br><span class="line"><span class="type">int</span> x[G], y[G], head[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> re[<span class="number">30</span>][<span class="number">30</span>]; <span class="comment">//对应关系, re[i][j]表示a[i]对应的b[(a[i]+j)%m]等于多少</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print_res</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, b[i]);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> t)</span> <span class="comment">//在a中填数,记录a[]与b[]的对应关系,在a中填一个数就把有对应关系的数全部填上</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t == m) <span class="keyword">return</span> (<span class="type">void</span>)(key = <span class="number">1</span>, <span class="built_in">Print_res</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; m; k ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (aa[k]) <span class="keyword">continue</span>;</span><br><span class="line">        a[t] = k;</span><br><span class="line">        <span class="type">bool</span> ok = <span class="number">1</span>; <span class="comment">//填这个数是否可行</span></span><br><span class="line">        <span class="type">bool</span> temp[<span class="number">30</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//记录哪些数是这一次新填入的　回溯时便于区分</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> e = <span class="number">0</span>; e &lt; m; e ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (re[t][e] == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> v = (a[t] + e) % m;</span><br><span class="line">            <span class="type">int</span> val = re[t][e]; <span class="comment">//要填的数</span></span><br><span class="line">            <span class="comment">//先看能不能填这个数　先不要往里面填数</span></span><br><span class="line">            <span class="keyword">if</span> ((b[v] == <span class="number">-1</span> &amp;&amp; bb[val] == <span class="number">0</span>) || b[v] == val);</span><br><span class="line">            <span class="keyword">else</span> &#123;ok = <span class="number">0</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    printf(&quot;在第%d位上填%d　ok=%d &quot;,t,k,ok);</span></span><br><span class="line"><span class="comment">    printf(&quot;a=&quot;);</span></span><br><span class="line"><span class="comment">    for (int i=0;i&lt;m;i++) printf(&quot;%d &quot;,a[i]);</span></span><br><span class="line"><span class="comment">    printf(&quot;b=&quot;);</span></span><br><span class="line"><span class="comment">    for (int i=0;i&lt;m;i++) printf(&quot;%d &quot;,b[i]);</span></span><br><span class="line"><span class="comment">    printf(&quot;\n&quot;);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        <span class="keyword">if</span> (ok == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        aa[k] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> e = <span class="number">0</span>; e &lt; m; e ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (re[t][e] == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> v = (a[t] + e) % m;</span><br><span class="line">            <span class="type">int</span> val = re[t][e];</span><br><span class="line">            <span class="keyword">if</span> (b[v] == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                b[v] = val;</span><br><span class="line">                bb[val] = <span class="number">1</span>;</span><br><span class="line">                temp[v] = <span class="number">1</span>; <span class="comment">//说明这个数是这次新填入的</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(t + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (key) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp[i]) &#123;</span><br><span class="line">                bb[b[i]] = <span class="number">0</span>;</span><br><span class="line">                b[i] = <span class="number">-1</span>; <span class="comment">//回溯　删除这一次新填的数　但是不能删除以前填过的而在这一次又满足条件的数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        aa[k] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) x[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) y[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++) a[i] = b[i] = <span class="number">-1</span>; <span class="comment">//未填数</span></span><br><span class="line">    <span class="built_in">memset</span>(re, <span class="number">-1</span>, <span class="built_in">sizeof</span>(re));</span><br><span class="line">    <span class="keyword">while</span> (cnt &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        ++ cnt;</span><br><span class="line">        re[(x[cnt] + dx) % m][dy] = y[cnt];</span><br><span class="line">        ++ dx;</span><br><span class="line">        <span class="keyword">if</span> (dx == m) dx = <span class="number">0</span>, ++ dy;</span><br><span class="line">        <span class="keyword">if</span> (dy == m) dy = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>小R与群山</title>
    <url>/2020/10/27/%E5%B0%8FR%E4%B8%8E%E7%BE%A4%E5%B1%B1/</url>
    <content><![CDATA[<p>题目大意：一个n位数，删除其中k个数字，使得留下的数字最小，问最小是多少其中n属于1e6，k属于n<span id="more"></span></p>
<p>我们可以显然的证明这样的贪心是错误的：删掉其中前k大的数字</p>
<p>做法很多，给出一种简单，易证的做法：</p>
<p>首先要求最小，显然是希望首位尽可能小，因为199…要比919…优秀</p>
<p>所以我们可以从第一位开始枚举，维护一个单调递增的栈，一旦发现某一位置小于栈顶，就不断弹</p>
<p>因为是递增的，所以首位一定是尽可能的小，这就满足了贪心的正确性</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k, top;</span><br><span class="line"><span class="type">int</span> a[N], sta[N], vis[N];</span><br><span class="line"><span class="type">char</span> ch[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%s&quot;</span>, ch + <span class="number">1</span>), k = <span class="built_in">read</span>(), n = <span class="built_in">strlen</span>(ch + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (n == k) &#123;<span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>); <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) a[i] = ch[i] - <span class="string">&#x27;0&#x27;</span>, vis[i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    sta[++ top] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; a[sta[top]]) sta[++ top] = i;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (a[i] &lt; a[sta[top]])</span><br><span class="line">            &#123;</span><br><span class="line">                vis[sta[top]] = <span class="number">0</span>, top --;</span><br><span class="line">                <span class="keyword">if</span> (! (-- k)) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sta[++ top] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (k) <span class="keyword">for</span> (i = n; i &gt;= <span class="number">1</span>; -- i) <span class="keyword">if</span> (vis[i]) &#123;vis[i] = <span class="number">0</span>; <span class="keyword">if</span> (! (-- k)) <span class="keyword">break</span>;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span> a), top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="keyword">if</span> (vis[i]) a[++ top] = ch[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> now = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (a[now] == <span class="number">0</span> &amp;&amp; now &lt; top) ++ now;</span><br><span class="line">    <span class="keyword">for</span> (i = now; i &lt;= top; ++ i) cout &lt;&lt; a[i];</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fclose</span>(stdin), <span class="built_in">fclose</span>(stdout);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<p>期望得分：100+？+50pts</p>
<p>实际得分：100+22+50pts</p>
<p>考场上灵感突然就来了，一眼切，但是debug，写对拍，总共花了55分钟，一道水题浪费这么多时间，实属不应该，但是同机房dalao有人用单调队列切了有人用线段树码了一百多行切了%%%</p>
<p>第二题是个很简单的最小生成树的问题，但是考场脑子过于紧张，一直在思考最短路，没反应过来是个生成树</p>
<p>第三题神仙题，会搜索加上换根dp50分暴力，正解是换根dp</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>小p的单调数列</title>
    <url>/2020/11/18/%E5%B0%8Fp%E7%9A%84%E5%8D%95%E8%B0%83%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<p>题目大意:我们定义个数列的价值为:将这个数列顺次划分为若干个<strong>极长</strong>单调区间(相邻两个单调区间的单调性不必相同)后,每个单调区间中元素总和的平均值.(第一个区间强制规定为递增的)<span id="more"></span>想在想问你在给定的序列中,价值最大的是哪个子序列.(严格单调,不存在等于的情况)</p>
<p>这个题目废话很多,但是最废话的是这么一句:相邻两个单调区间的单调性不必相同.</p>
<p>我认为只要保证第一个区间是递增的(符合题解),后边随意就行.</p>
<p>考虑反证:后边有个区间也是递增的,那么如果后边区间的第一个数字比我当前递增区间的最后一个数字还要大,那么我显然可以接上去,把两个合并为一个;如果后边那个区间是递减的,符合题意.</p>
<p>证毕.</p>
<p>再来考虑答案的最有性选择.结论:最优的一定出自<strong>一条递增的区间</strong>或者<strong>一条递增和一条递减的区间</strong></p>
<p>证明:</p>
<p><img
src="https://pic.downk.cc/item/5fb4febfb18d62711360841f.png" /></p>
<p>假设上图中靠上部分的"1-2-3"为当前答案,"3-4"为新找到的答案</p>
<p>设ans为原先答案,x为新找到的答案,</p>
<p>考虑合并之后的答案:<span class="math inline">\(\dfrac {ans \times 2 +
x} 3\)</span></p>
<p>解方程<span class="math inline">\(ans &lt; \dfrac {ans \times 2 + x}
3\)</span></p>
<p>所以<span class="math inline">\(ans &lt; x\)</span></p>
<p>那么显然x单独作为答案更合理,因为他加上一个比他小的数字,显然不如自己一个人大(因为答案是求平均值)</p>
<p>对于上图靠下部分的"5-6-7"为当前答案,"7-8"为新找到的答案</p>
<p>读者自证不难</p>
<p>代码很好写,dp的同时用树状数组来维护</p>
<p>其中<span
class="math inline">\(f_i\)</span>表示以i为结尾的最长的递增权值,<span
class="math inline">\(g_i\)</span>是同理,只不过是递减的</p>
<p>代码如下: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, cnt;</span><br><span class="line"><span class="type">int</span> a[N], b[N], d[N], f[N], g[N], tree[N];</span><br><span class="line"><span class="type">double</span> res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">updata</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x &lt;= cnt)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[x] = <span class="built_in">max</span>(tree[x], val);</span><br><span class="line">        x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ret</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (x)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = <span class="built_in">max</span>(ret, tree[x]);</span><br><span class="line">        x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i; n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) b[i] = a[i] = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + n);</span><br><span class="line">    cnt = <span class="built_in">unique</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + n) - b - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        d[i] = <span class="built_in">lower_bound</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + cnt, a[i]) - b;</span><br><span class="line">        f[i] = <span class="built_in">query</span>(d[i] - <span class="number">1</span>) + a[i];</span><br><span class="line">        <span class="built_in">updata</span>(d[i], f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= cnt; ++ i) tree[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = n; i &gt;= <span class="number">1</span>; -- i)</span><br><span class="line">    &#123;</span><br><span class="line">        g[i] = <span class="built_in">query</span>(d[i] - <span class="number">1</span>) + a[i];</span><br><span class="line">        <span class="built_in">updata</span>(d[i], g[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) res = <span class="built_in">max</span>(res, <span class="built_in">max</span>(f[i] / <span class="number">1.000</span>, (f[i] + g[i] - a[i]) / <span class="number">2.000</span>));</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%.3lf\n&quot;</span>, res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>后记:</p>
<p>实在是思维极其巧妙的树状数组优化dp题目</p>
<p>膜拜出题人的巧妙灵感</p>
<p>膜拜建业大佬考场一遍切题!</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维题</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串</title>
    <url>/2020/10/17/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>题目大意：他看见了两个字符串 s,t，其中 s
只包含小写字母以及<code>*</code>，t
只包含小写字母。<span id="more"></span>可以进行任意多次操作，每次选择 s
中的一个<code>*</code>，将它修改为任意多个（可以是 0
个）它的前一个字符。他想知道是否能将 s 修改为 t。请即将入选 IOI
国家队的你帮 infinite32768 求解这道简单字符串题</p>
<p>考场上没看出来是个模拟，把简单的问题复杂化了</p>
<p>其实就是无脑匹配，但是有个坑点：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">a****a</span><br><span class="line">aa</span><br></pre></td></tr></table></figure>
<p>必须要记录能跳多少个，如果发现s串跳的比t串长就No了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e4</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (T --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pd = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%s&quot;</span>, a + <span class="number">1</span>), <span class="built_in">scanf</span> (<span class="string">&quot;%s&quot;</span>, b + <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">strlen</span>(a + <span class="number">1</span>), m = <span class="built_in">strlen</span>(b + <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> t = <span class="number">1</span>, k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (t &lt;= n &amp;&amp; k &lt;= m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[t] != b[k])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">                pd = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a[t + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">char</span> ch = a[t];</span><br><span class="line">                <span class="type">int</span> num = <span class="number">0</span>, num1 = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (a[t + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span> || a[t + <span class="number">1</span>] == ch)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (a[t + <span class="number">1</span>] == ch) ++ num;</span><br><span class="line">                    ++ t;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (k &lt; m &amp;&amp; b[k + <span class="number">1</span>] == ch)</span><br><span class="line">                &#123;</span><br><span class="line">                    ++ num1;</span><br><span class="line">                    ++ k;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (num &gt; num1)</span><br><span class="line">                &#123;</span><br><span class="line">                    pd = <span class="number">1</span>;</span><br><span class="line">                    <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++ t, ++ k;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pd != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (t == n + <span class="number">1</span> &amp;&amp; k == m + <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>小朋友</title>
    <url>/2020/11/11/%E5%B0%8F%E6%9C%8B%E5%8F%8B/</url>
    <content><![CDATA[<p>题目大意：n 个小朋友在一起做游戏，第 i 个小朋友的快乐值为 Di。当第 i
个小朋友和 第 j 个小朋友一起玩时，他们能获得 Di xor Dj
的快乐值。每一个小朋友 i 都
想知道，他和谁一起玩能够获得最大的快乐值，请你帮他们每个人分别求出这个
值。<span id="more"></span></p>
<p>看到异或联系二进制，显然的贪心是我们按位进行操作，每一位都取与他不同的</p>
<p>二进制拆分之后弄到01Trie上就好</p>
<p>小细节：初始化时候p=1,tot=1 还有 特判零</p>
<p>代码如下：（代码正确性没有问题，就是这个题目的读入比较操蛋）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e6</span> + <span class="number">66</span>, mod = (<span class="number">1</span> &lt;&lt; <span class="number">24</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">s</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">w</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) w = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) s = s * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s * w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">put</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (! x) <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">num</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="type">char</span> c[<span class="number">66</span>];</span><br><span class="line">    <span class="keyword">while</span> (x) c[++ num] = x % <span class="number">10</span> + <span class="number">48</span>, x /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (num) <span class="built_in">putchar</span>(c[num --]);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, yhm, maxv, t, pd;</span><br><span class="line"><span class="type">int</span> d[N], ans[N];</span><br><span class="line"><span class="type">int</span> ch[N][<span class="number">30</span>], tot = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">ksm</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ret</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">yhm_insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, <span class="built_in">p</span>(<span class="number">1</span>), k;</span><br><span class="line">    <span class="keyword">for</span> (i = t; i &gt;= <span class="number">0</span>; -- i)</span><br><span class="line">    &#123;</span><br><span class="line">        k = (x &amp; (<span class="number">1</span> &lt;&lt; i)) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (! ch[p][k]) ch[p][k] = ++ tot;</span><br><span class="line">        p = ch[p][k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">yhm_query</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, <span class="built_in">p</span>(<span class="number">1</span>), k, <span class="built_in">sum</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = t; i &gt;= <span class="number">0</span>; -- i)</span><br><span class="line">    &#123;</span><br><span class="line">        k = (x &amp; (<span class="number">1</span> &lt;&lt; i)) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (! ch[p][k]) p = ch[p][<span class="number">1</span> - k];</span><br><span class="line">        <span class="keyword">else</span> sum = (sum + (<span class="number">1</span> &lt;&lt; i)) % mod, p = ch[p][k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pres_dou</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> K = <span class="built_in">read</span>(), B = <span class="built_in">read</span>(), P = <span class="built_in">read</span>(), i;</span><br><span class="line">    d[<span class="number">1</span>] = P;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; ++ i) d[i] = (K * d[i - <span class="number">1</span>] + B % mod) % mod, maxv = <span class="built_in">max</span>(maxv, d[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (maxv == <span class="number">0</span>) <span class="keyword">return</span> (<span class="type">void</span>)(pd = <span class="number">1</span>);</span><br><span class="line">    t = <span class="built_in">log</span>(maxv) / <span class="built_in">log</span>(<span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">    t += (maxv &amp; (<span class="number">1</span> &lt;&lt; t)) ? <span class="number">0</span> : <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">yhm_insert</span>(d[i]);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;friend.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin), <span class="built_in">freopen</span>(<span class="string">&quot;friend.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> i; n = <span class="built_in">read</span>(); <span class="built_in">pres_dou</span>();</span><br><span class="line">    <span class="keyword">if</span> (pd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">put</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">fclose</span>(stdin), <span class="built_in">fclose</span>(stdout);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) ans[i] = d[i] ? <span class="built_in">yhm_query</span>(d[i]) : maxv;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) yhm = (yhm + ans[i] * <span class="built_in">ksm</span>(<span class="number">3</span>, i - <span class="number">1</span>) % mod) % mod;</span><br><span class="line">    <span class="built_in">put</span>(yhm);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fclose</span>(stdin), <span class="built_in">fclose</span>(stdout);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>小王子</title>
    <url>/2020/10/01/%E5%B0%8F%E7%8E%8B%E5%AD%90/</url>
    <content><![CDATA[<p>题目大意：在一棵无根树上加上M条新边，然后能毁掉两条边，规定一条是树边，一条是新边，问有多少种方案能使树断裂。</p>
<span id="more"></span>
<p>每次加上一条新边(u,v)，必定会形成一个环<span
class="math inline">\(u-lca(u,v)-v-u\)</span>，给这个路径上的边的覆盖数都认为加1，考虑加完之后：</p>
<p>如果一条树边的覆盖数为0，显然断掉这个之后，再随便断掉一条新边都可以使得树不联通，所以贡献为m</p>
<p>如果一条树边的覆盖数为1，显然断掉这个之后，再断掉覆盖在他这条边上的那个新边就可以使得树不联通，贡献为1</p>
<p>如果一条树边的覆盖树大于1，那显然无贡献</p>
<p>如何统计一个边的覆盖数？树上差分</p>
<p>首先给树定个方向，选1为根，令<span
class="math inline">\(g[i]\)</span>表示以i为终点（在树中深度较大的点）的边的覆盖数，那么每次只要新加一条新边<span
class="math inline">\((u,v)\)</span></p>
<p>只需要更新<span class="math inline">\(u-lca(u,v)\)</span>与<span
class="math inline">\(v-lca(u,v)\)</span>两条路径上的边就可以了</p>
<p><span class="math inline">\(++g[u],++g[v],g[lca(u,v)]-=2\)</span></p>
<p>最后再来一遍树形dp，自上而下统计一遍就好</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">s</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">w</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) w = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) s = s * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s * w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (! x) <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">num</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="type">char</span> c[<span class="number">66</span>];</span><br><span class="line">    <span class="keyword">while</span> (x) c[++ num] = x % <span class="number">10</span> + <span class="number">48</span>, x /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (num) <span class="built_in">putchar</span>(c[num --]);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> to[N &lt;&lt; <span class="number">1</span>], nex[N &lt;&lt; <span class="number">1</span>], head[N], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    to[++ cnt] = y;</span><br><span class="line">    nex[cnt] = head[x];</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(head[x] = cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, res;</span><br><span class="line"><span class="type">int</span> g[N], dep[N], fa[N][<span class="number">66</span>], vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, y;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">30</span>; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (fa[x][i - <span class="number">1</span>]) fa[x][i] = fa[fa[x][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = head[x]; i; i = nex[i])</span><br><span class="line">    &#123;</span><br><span class="line">        y = to[i];</span><br><span class="line">        <span class="keyword">if</span> (y == fa[x][<span class="number">0</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        fa[y][<span class="number">0</span>] = x;</span><br><span class="line">        dep[y] = dep[x] + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[x] &lt; dep[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">    <span class="type">int</span> delta = dep[x] - dep[y], i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; -- i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (delta &amp; (<span class="number">1</span> &lt;&lt; i))</span><br><span class="line">            x = fa[x][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; -- i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (fa[x][i] != fa[y][i])</span><br><span class="line">        &#123;</span><br><span class="line">            x = fa[x][i], y = fa[y][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, y;</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = head[x]; i; i = nex[i])</span><br><span class="line">    &#123;</span><br><span class="line">        y = to[i];</span><br><span class="line">        <span class="keyword">if</span> (! vis[y])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dp</span>(y);</span><br><span class="line">            g[x] += g[y];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, x, y;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">add_edge</span>(x, y), <span class="built_in">add_edge</span>(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>();</span><br><span class="line">        ++ g[x], ++ g[y], g[<span class="built_in">lca</span>(x, y)] -= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dp</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (! g[i]) res += m;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (g[i] == <span class="number">1</span>) ++ res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">put</span>(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>小豪的花园</title>
    <url>/2020/11/16/%E5%B0%8F%E8%B1%AA%E7%9A%84%E8%8A%B1%E5%9B%AD/</url>
    <content><![CDATA[<p>题目大意:小豪每个花棚里有一定数量的花 ai,即形成树结构，其中根节点是 1
号花棚。<span id="more"></span>现在小豪打算重新分配每个花棚里花的数量。为了能方便快捷地知道花园的情况，小豪现在需要你的帮助。具体地说，小豪共有
m 个操作。操作有三种：</p>
<p>1 u k 表示如果一个花棚在以 u
号花棚为根的子树中，那么小豪会把这个花棚花的数量 模 k；</p>
<p>2 u x 表示小豪将 u 号花棚花的数量变成 x；</p>
<p>3 u v 表示小豪询问从 u 号花棚走到 v 号花棚总共能看到的花的数量。</p>
<p>说白了就是给你一棵树,让你维护三种操作:单点修改,区间修改,区间查询</p>
<p>这种东西就是得多写多做</p>
<p>区间取模的话,就是维护一个最大值,方便处理,如果发现区间最大值小于这个模数,那么就可以跳过了,否则暴力修改</p>
<p>代码如下: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ll <span class="title">s</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">w</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) w = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) s = s * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s * w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">put</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (! x) <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">num</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="type">char</span> c[<span class="number">66</span>];</span><br><span class="line">    <span class="keyword">while</span> (x) c[++ num] = x % <span class="number">10</span> + <span class="number">48</span>, x /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (num) <span class="built_in">putchar</span>(c[num --]);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ver[N &lt;&lt; <span class="number">1</span>], nex[N &lt;&lt; <span class="number">1</span>], head[N], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++ cnt] = y;</span><br><span class="line">    nex[cnt] = head[x];</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(head[x] = cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> fa[N], siz[N], dep[N], son[N];</span><br><span class="line"><span class="type">int</span> dfn[N], top[N], a[N], v[N], tot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SEGMENTTREE</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> dat, maxv;</span><br><span class="line">&#125;tree[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> yhm_fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, y;</span><br><span class="line">    siz[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = head[x]; i; i = nex[i])</span><br><span class="line">    &#123;</span><br><span class="line">        y = ver[i];</span><br><span class="line">        <span class="keyword">if</span> (y == yhm_fa) <span class="keyword">continue</span>;</span><br><span class="line">        fa[y] = x;</span><br><span class="line">        dep[y] = dep[x] + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(y, x);</span><br><span class="line">        siz[x] += siz[y];</span><br><span class="line">        <span class="keyword">if</span> (siz[y] &gt; siz[son[x]]) son[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> yhm_top)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x] = ++ tot, a[tot] = v[x];</span><br><span class="line">    top[x] = yhm_top;</span><br><span class="line">    <span class="keyword">if</span> (! son[x]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(son[x], yhm_top);</span><br><span class="line">    <span class="type">int</span> i, y;</span><br><span class="line">    <span class="keyword">for</span> (i = head[x]; i; i = nex[i])</span><br><span class="line">    &#123;</span><br><span class="line">        y = ver[i];</span><br><span class="line">        <span class="keyword">if</span> (y == son[x] || y == fa[x]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(y, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = p &lt;&lt; <span class="number">1</span>, r = (p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>;</span><br><span class="line">    tree[p].dat = tree[l].dat + tree[r].dat;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(tree[p].maxv = <span class="built_in">max</span>(tree[l].maxv, tree[r].maxv));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> (<span class="type">void</span>)(tree[p].dat = tree[p].maxv = a[l]);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>((p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(<span class="built_in">up</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">updata</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> nl, <span class="type">int</span> nr, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nl &lt;= l &amp;&amp; nr &gt;= r &amp;&amp; c &gt; tree[p].maxv) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> (<span class="type">void</span>)(tree[p].dat %= c, tree[p].maxv %= c);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (nl &lt;= mid) <span class="built_in">updata</span>(p &lt;&lt; <span class="number">1</span>, l, mid, nl, nr, c);</span><br><span class="line">    <span class="keyword">if</span> (nr &gt; mid) <span class="built_in">updata</span>((p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>, mid + <span class="number">1</span>, r, nl, nr, c);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(<span class="built_in">up</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">bianch</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> (<span class="type">void</span>)(tree[p].dat = tree[p].maxv = c);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= mid) <span class="built_in">bianch</span>(p &lt;&lt; <span class="number">1</span>, l, mid, k, c);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">bianch</span>((p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>, mid + <span class="number">1</span>, r, k, c);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(<span class="built_in">up</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> nl, <span class="type">int</span> nr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nl &lt;= l &amp;&amp; nr &gt;= r) <span class="keyword">return</span> tree[p].dat;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, <span class="built_in">res</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (nl &lt;= mid) res = <span class="built_in">query</span>(p &lt;&lt; <span class="number">1</span>, l, mid, nl, nr);</span><br><span class="line">    <span class="keyword">if</span> (nr &gt; mid) res += <span class="built_in">query</span>((p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>, mid + <span class="number">1</span>, r, nl, nr);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query_path</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">res</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (top[x] != top[y])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[top[x]] &lt; dep[top[y]]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">        res += <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, dfn[top[x]], dfn[x]);</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dep[x] &lt; dep[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">    res += <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, dfn[y], dfn[x]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, x, y, opt;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">add_edge</span>(x, y), <span class="built_in">add_edge</span>(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) v[i] = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    dep[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>), <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        opt = <span class="built_in">read</span>(), x = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>) y = <span class="built_in">read</span>(), <span class="built_in">updata</span>(<span class="number">1</span>, <span class="number">1</span>, n, dfn[x], dfn[x] + siz[x] - <span class="number">1</span>, y);</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">2</span>) y = <span class="built_in">read</span>(), <span class="built_in">bianch</span>(<span class="number">1</span>, <span class="number">1</span>, n, dfn[x], y);</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">3</span>) y = <span class="built_in">read</span>(), <span class="built_in">put</span>(<span class="built_in">query_path</span>(x, y));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">End...</span></span><br><span class="line"><span class="comment">the first is correct!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<p>后记:</p>
<p>代码巨长,细节巨多</p>
<p>但是我一次写对了,开心</p>
<p>纪念于此,不枉存在</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>幸运数字</title>
    <url>/2020/12/01/%E5%B9%B8%E8%BF%90%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<p>题目大意:定义幸运数字为只包含6,8的数字,扩展定义"近似幸运数字"为:是"幸运数字"的倍数都是"近似幸运数字".求一个区间内幸运数字的个数.<span id="more"></span></p>
<p>正解貌似是数位dp,但是没有题解介绍这个,大多都是搜索剪枝.</p>
<p>首先预处理出来范围内的幸运数字</p>
<p>然后考虑一个显然的性质:<span class="math inline">\(\dfrac B x -
\dfrac A x\)</span>是<span
class="math inline">\([A,B]\)</span>中x的倍数的个数.</p>
<p>但是考虑到有交集,所以选择容斥一下:</p>
<p>选1个幸运数字-选2个幸运数字的lcm+选3个幸运数字的lcm</p>
<p>然后剪枝,减掉了好多好多状态:</p>
<ul>
<li><p>对于一个数字a,和b如果发现b是a的倍数,那么对于所有的为b的倍数的数字,一定是a的倍数,所以这样的b就无用了.</p></li>
<li><p>当前lcm大于B就stop</p></li>
<li><p>倒序排序,方便更快超越上限(常用技巧)</p></li>
</ul>
<p>代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line">ll a, b, res, num[N], nam[N];</span><br><span class="line"><span class="type">int</span> cnt, vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pres_dou</span><span class="params">(<span class="type">int</span> now, ll sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; b) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (sum != <span class="number">0</span>) num[++ cnt] = sum;</span><br><span class="line">    <span class="keyword">if</span> (now &gt; <span class="number">10</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">pres_dou</span>(now + <span class="number">1</span>, sum * <span class="number">10</span> + <span class="number">6</span>), <span class="built_in">pres_dou</span>(now + <span class="number">1</span>, sum * <span class="number">10</span> + <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">yhm_cut</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, <span class="built_in">ret</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= cnt; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (num[i] &lt;= b / <span class="number">2</span>) nam[++ ret] = num[i];</span><br><span class="line">        <span class="keyword">else</span> res += b / num[i] - a / num[i];</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= cnt; ++ j) <span class="keyword">if</span> (num[j] % num[i] == <span class="number">0</span>) vis[j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(cnt = ret);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;<span class="keyword">return</span> x &gt; y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> now, ll sum, <span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; b) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (now &gt; cnt) <span class="keyword">return</span> (<span class="type">void</span>)((sum == <span class="number">1</span>) ? a = a : (res += (b / sum - a / sum) * ((t &amp; <span class="number">1</span>) ? <span class="number">1</span> : <span class="number">-1</span>)));</span><br><span class="line">    <span class="built_in">dfs</span>(now + <span class="number">1</span>, sum, t);</span><br><span class="line">    ll tmp = nam[now] / __gcd(nam[now], sum);</span><br><span class="line">    <span class="keyword">if</span> (tmp * sum &lt;= b) <span class="built_in">dfs</span>(now + <span class="number">1</span>, tmp * sum, t + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">    a = <span class="built_in">read</span>(), b = <span class="built_in">read</span>(), -- a;</span><br><span class="line">    <span class="built_in">pres_dou</span>(<span class="number">1</span>, <span class="number">0</span>), <span class="built_in">sort</span>(num + <span class="number">1</span>, num + <span class="number">1</span> + cnt);</span><br><span class="line">    <span class="built_in">yhm_cut</span>(), <span class="built_in">sort</span>(nam + <span class="number">1</span>, nam + <span class="number">1</span> + cnt, cmp);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>), <span class="built_in">put</span>(res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后记:</p>
<p>学好搜索,打遍天下无敌手...</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>数学</tag>
        <tag>容斥</tag>
        <tag>剪枝</tag>
        <tag>最小公倍数</tag>
      </tags>
  </entry>
  <entry>
    <title>小迟的数字2</title>
    <url>/2020/11/16/%E5%B0%8F%E8%BF%9F%E7%9A%84%E6%95%B0%E5%AD%972/</url>
    <content><![CDATA[<p>题目大意：如果一个数字的十进制表示中，有连续的 1 个 1，或者有连续的 2
个 2，或者有连续的 3 个 3，或者有连续的 4 个 4，或 者有连续的 5 个
5，或者有连续的 6 个 6，或者有连续的 7 个 7，或者有连 续的 8 个
8，或者有连续的 9 个 9，认为这个数字是 good number。
<span id="more"></span>现在想知道在所有 N 位数中有多少个 good number？
这个数字可能有点大，所以对 109 + 7 取模就好了</p>
<p>区别上一道题,此题动规(因为有<strong>连续</strong>)</p>
<p>状态:设<span
class="math inline">\(f[i][j][k]\)</span>表示前i位,结尾位j,且持续了k个的方案数目</p>
<p>转移:见代码.主要就是把零和别的数字区别开来</p>
<p>边界:0至9</p>
<p>代码如下: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">6</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">inline int func(int x)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    if (x == 1) return 1;</span></span><br><span class="line"><span class="comment">    if (x == 2) return 19;</span></span><br><span class="line"><span class="comment">    if (x == 3) return 269;</span></span><br><span class="line"><span class="comment">    if (x == 4) return 3393;</span></span><br><span class="line"><span class="comment">    if (x == 5) return 40175;</span></span><br><span class="line"><span class="comment">    if (x == 6) return 457247;</span></span><br><span class="line"><span class="comment">    if (x == 7) return 5065622;</span></span><br><span class="line"><span class="comment">    if (x == 8) return 55038455;</span></span><br><span class="line"><span class="comment">    if (x == 9) return 589325826;</span></span><br><span class="line"><span class="comment">    return 239296951;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> f[N][<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">ksm</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ret</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, k, l;</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; <span class="number">10</span>; ++ i) f[<span class="number">1</span>][i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//		j = 0;</span></span><br><span class="line">        &#123;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">            k = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (l = <span class="number">0</span>; l &lt; <span class="number">10</span>; ++ l)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (! l) (f[i + <span class="number">1</span>][<span class="number">0</span>][<span class="number">1</span>] += f[i][<span class="number">0</span>][<span class="number">1</span>]) %= mod;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">1</span> &lt; l) (f[i + <span class="number">1</span>][l][<span class="number">1</span>] += f[i][<span class="number">0</span>][<span class="number">1</span>]) %= mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; <span class="number">10</span>; ++ j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; j; ++ k)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span> (l = <span class="number">0</span>; l &lt; <span class="number">10</span>; ++ l)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> (l == j)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span> (k + <span class="number">1</span> &lt; j)</span><br><span class="line">                            &#123;</span><br><span class="line">                                (f[i + <span class="number">1</span>][j][k + <span class="number">1</span>] += f[i][j][k]) %= mod;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span> (<span class="number">1</span> &lt; l || ! l) (f[i + <span class="number">1</span>][l][<span class="number">1</span>] += f[i][j][k]) %= mod;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = ((<span class="built_in">ksm</span>(<span class="number">10</span>, n) - <span class="built_in">ksm</span>(<span class="number">10</span>, n - <span class="number">1</span>)) % mod + mod) % mod;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">10</span>; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (! i || j &lt; i)</span><br><span class="line">            &#123;</span><br><span class="line">                res -= f[n][i][j];</span><br><span class="line">                res = (res % mod + mod) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">put</span>(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>后记:</p>
<p>打表程序并没有消除</p>
<p>因为打出来这个表,程序就跑了将近半个小时</p>
<p>在此记录,不枉存在</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动规</tag>
      </tags>
  </entry>
  <entry>
    <title>康复训练_普及组</title>
    <url>/2023/11/29/%E5%BA%B7%E5%A4%8D%E8%AE%AD%E7%BB%83/</url>
    <content><![CDATA[<p>康复训练_普及组 <span id="more"></span></p>
<h1 id="年">1998年</h1>
<h2 id="三连击">三连击</h2>
<p>普通模拟</p>
<h2 id="阶乘和">阶乘和</h2>
<p>高精度</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">bigint</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> num[N], len;</span><br><span class="line">&#125;a, b, c;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Read</span><span class="params">(<span class="type">int</span> x, bigint &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   string s = <span class="built_in">to_string</span>(x);</span><br><span class="line">   t.len = s.<span class="built_in">length</span>();</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; t.len; ++ i)</span><br><span class="line">      t.num[i] = s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">   <span class="built_in">reverse</span>(t.num, t.num + t.len);</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Plus</span><span class="params">(bigint &amp;a, bigint &amp;b, big <span class="type">int</span> &amp;c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   c.len = <span class="built_in">max</span>(a.len, b.len);</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; c.len; ++ i)</span><br><span class="line">      c.num[i] = a.num[i] + b.num[i];</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; c.len; ++ i)</span><br><span class="line">      <span class="keyword">if</span> (c.num[i] &gt; <span class="number">9</span>)</span><br><span class="line">         c.num[i + <span class="number">1</span>] += <span class="number">1</span>, c.num[i] -= <span class="number">10</span>;</span><br><span class="line">   <span class="keyword">if</span> (c.num[c.len + <span class="number">1</span>]) ++ c.len;</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Minus</span><span class="params">(bigint &amp;a, bigint &amp;b, big <span class="type">int</span> &amp;c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   c.len = a.len;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; c.len; ++ i)</span><br><span class="line">      c.num[i] = a.num[i] - b.num[i];</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; c.len; ++ i)</span><br><span class="line">      <span class="keyword">if</span> (c.num[i] &lt; <span class="number">0</span>)</span><br><span class="line">         c.num[i + <span class="number">1</span>] -= <span class="number">1</span>, c.num[i] += <span class="number">10</span>;</span><br><span class="line">   <span class="keyword">while</span> (c.len &gt; <span class="number">1</span> &amp;&amp; c.num[c.len - <span class="number">1</span>] == <span class="number">0</span>) -- c.len;</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Multi</span><span class="params">(bigint &amp;a, <span class="type">int</span> b, bigint &amp;c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   c.len = a.len;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; c.len; ++ i)</span><br><span class="line">      c.num[i] = a.num[i] * b;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; c.len; ++ i)</span><br><span class="line">   &#123;</span><br><span class="line">      c.num[i + <span class="number">1</span>] += c.num[i] / <span class="number">10</span>;</span><br><span class="line">      c.num[i] %= <span class="number">10</span>;</span><br><span class="line">      <span class="keyword">if</span> (c.num[i + <span class="number">1</span>] &amp;&amp; i + <span class="number">1</span> == c.len) ++ c.len;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Multi</span><span class="params">(bigint &amp;a, bigint &amp;b, bigint &amp;c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   c.len = a.len + b.len;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.len; ++ i)</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; b.len; ++ j)</span><br><span class="line">      c.num[i + j] += a.num[i] * b.num[j];</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; c.len; ++ i)</span><br><span class="line">      <span class="keyword">if</span> (c.num[i] &gt; <span class="number">9</span>)</span><br><span class="line">         c.num[i + <span class="number">1</span>] += (c.num[i] / <span class="number">10</span>), c.num[i] %= <span class="number">10</span>;</span><br><span class="line">   <span class="keyword">while</span> (c.num[c.len - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; c.len &gt; <span class="number">1</span>) -- c.len;</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="comment">//高精度乘高精</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Divide</span><span class="params">(bigint &amp;a, <span class="type">int</span> b, bigint &amp;c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   c.len = a.len;</span><br><span class="line">   ll t = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = c.len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; -- i)</span><br><span class="line">   &#123;</span><br><span class="line">      t = t * <span class="number">10</span> + a.num[i];</span><br><span class="line">      c.num[i] = t / b;</span><br><span class="line">      t %= b;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">while</span> (c.len &gt; <span class="number">1</span> &amp;&amp; c.num[c.len - <span class="number">1</span>] == <span class="number">0</span>) -- c.len;</span><br><span class="line">   <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><font color=Red>t是余数，会爆int</font></p>
<h2 id="幂次方">幂次方</h2>
<p>基本构造</p>
<p>观察题目发现最终结果只能是"2"或者"2(0)"
所以考虑在dfs边界设置为0和1，表示<span class="math inline">\(2^0,
2^1\)</span> 什么时候需要带括号呢？1 = "2(0)"</p>
<p>联想快速幂:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">ksm</span><span class="params">(ll a, ll b, <span class="type">int</span> mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   ll res = <span class="number">1ll</span>;</span><br><span class="line">   <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res = res * a % mod;</span><br><span class="line">      a = a * a % mod;</span><br><span class="line">      b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">ksm</span><span class="params">(ll a, ll b, <span class="type">int</span> mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (! b) <span class="keyword">return</span> <span class="number">1ll</span>;</span><br><span class="line">   <span class="keyword">if</span> (b &amp; <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">ksm</span>(a, b - <span class="number">1</span>, mod) * a % mod;</span><br><span class="line">   ll res = <span class="built_in">ksm</span>(a, b &gt;&gt; <span class="number">1</span>, mod);</span><br><span class="line">   <span class="keyword">return</span> res * res % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="section">1999</h1>
<h2 id="cantor-表">Cantor 表</h2>
<p>找规律的一题，先找出该项在杨辉三角里面的哪一行，然后判断奇偶</p>
<p>奇：从左下到右上递增, 偶：从右上到左下递增</p>
<p>找到行首，接下来一个for就可以</p>
<h2 id="回文数">回文数</h2>
<p>这是一道高精+模拟的一个思维好题</p>
<p>有几个坑点，第一个是传址调用，新建局部变量数组，要清空，第二个是传值调用尽量从a开始，而不是从a+1，第三个是十六进制，d[i]
= tmp - 10 + 'A'</p>
<p>不可以写d[i] = tmp - 10 + '0' + 'A'从ascil的角度来看，多了48</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> t, <span class="type">char</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">char</span> b[N]; <span class="built_in">strcpy</span>(b, a);</span><br><span class="line">   <span class="built_in">reverse</span>(b, b + <span class="built_in">strlen</span>(b));</span><br><span class="line">   <span class="comment">// printf(&quot;\nthis is %d times:\n&quot;, t);</span></span><br><span class="line">   <span class="comment">// printf(&quot;a:%s\tb:%s\n&quot;, a, b);</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">strcmp</span>(a, b) == <span class="number">0</span>) <span class="keyword">return</span> (<span class="type">void</span>)(flag2 = t - <span class="number">1</span>);</span><br><span class="line">   <span class="keyword">if</span> (t &gt; LIM) <span class="keyword">return</span> (<span class="type">void</span>)(flag1 = <span class="number">1</span>);</span><br><span class="line">   <span class="keyword">if</span> (flag1 || flag2) <span class="keyword">return</span>;</span><br><span class="line">   <span class="type">int</span> c[N], len = <span class="built_in">strlen</span>(a);</span><br><span class="line">   <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span> c);</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++ i)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="type">int</span> tmp1, tmp2;</span><br><span class="line">      <span class="keyword">if</span> (a[i] &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; a[i] &gt;= <span class="string">&#x27;0&#x27;</span>) tmp1 = a[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">      <span class="keyword">else</span> tmp1 = a[i] - <span class="string">&#x27;A&#x27;</span> + <span class="number">10</span>;</span><br><span class="line">      <span class="keyword">if</span> (b[i] &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; b[i] &gt;= <span class="string">&#x27;0&#x27;</span>) tmp2 = b[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">      <span class="keyword">else</span> tmp2 = b[i] - <span class="string">&#x27;A&#x27;</span> + <span class="number">10</span>;</span><br><span class="line">      c[i] = tmp1 + tmp2;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++ i) <span class="keyword">if</span> (c[i] &gt;= n) c[i + <span class="number">1</span>] += c[i] / n, c[i] %= n;</span><br><span class="line">   <span class="keyword">if</span> (c[len]) ++ len;</span><br><span class="line">   <span class="comment">// printf (&quot;c:&quot;);</span></span><br><span class="line">   <span class="comment">// for (int i = len - 1; i &gt;= 0; -- i) cout &lt;&lt; c[i];</span></span><br><span class="line">   <span class="type">char</span> d[N]; <span class="type">int</span> len2 = len;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++ i)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="type">int</span> tmp = c[-- len2];</span><br><span class="line">      <span class="keyword">if</span> (tmp &lt;= <span class="number">9</span>) d[i] = tmp + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">      <span class="keyword">else</span> d[i] = tmp - <span class="number">10</span> + <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> (<span class="type">void</span>)(<span class="built_in">dfs</span>(t + <span class="number">1</span>, d));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="旅行家的预算">旅行家的预算</h2>
<p>贪心加模拟</p>
<p>由于数据量很小，我的做法是，开一个结构体，除了n个油站放进去，起点和终点也塞进去，以距起点的距离为第一关键字排个序</p>
<p>递归边界是，到达终点，</p>
<p>递归过程是，针对于每一个油站可去的范围内，如果下一个比当前油价便宜，那么只需要恰好到达下一站即可，如果下一个比当前贵，那么最优选项就是当前加满再去</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> t, <span class="type">double</span> money, <span class="type">double</span> h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// printf(&quot;t = %d, money = %.2lf, h = %.2lf\n&quot;, t, money, h);</span></span><br><span class="line">   <span class="keyword">if</span> (t == n) <span class="keyword">return</span> (<span class="type">void</span>)(flag = <span class="number">1</span>, res = <span class="built_in">min</span>(res, money));</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = t + <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="type">double</span> s = (a[i].d - a[t].d) / d_2;</span><br><span class="line">      <span class="keyword">if</span> (s &gt; c) <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span> (h &gt;= s) <span class="built_in">dfs</span>(i, money, h - s);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">if</span> (a[i].p &gt;= a[t].p)</span><br><span class="line">            <span class="built_in">dfs</span>(i, money + (c - h) * a[t].p, c - s);</span><br><span class="line">         <span class="keyword">else</span> <span class="built_in">dfs</span>(i, money + (s - h) * a[t].p, <span class="number">0.0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="section-1">2000</h1>
<h2 id="计算器的改良">计算器的改良</h2>
<p>普通模拟，有点类似栈但不是栈,因为没有括号，没有乘除</p>
<p>我的思路是根据'='分成两段，分别处理,最后整合</p>
<p>考虑针对每一段，每遇到一个特殊符号就处理，减号flag=1，加号不管，也就是flag=0,遇到数字就把上次的符号弹出，处理，然后复原</p>
<p>细节有点多，考虑以下几种情况</p>
<p><code>3-a=3</code>//-0.000?</p>
<p><code>a+2a=6</code>//3a=6</p>
<p><code>5a=5</code>//a=inf?</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= pos; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span> ((s[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;Z&#x27;</span>) || (s[i] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;z&#x27;</span>))</span><br><span class="line">   &#123;</span><br><span class="line">      x1 = s[i];</span><br><span class="line">      <span class="type">int</span> now = tmp;</span><br><span class="line">      <span class="keyword">if</span> (now == <span class="number">0</span>)<span class="comment">//系数为1</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">if</span> (flag) now = <span class="number">-1</span>, flag = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">else</span> now = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">if</span> (flag) now = -now, flag = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">else</span> now = now;</span><br><span class="line">      &#125;</span><br><span class="line">      l += now;</span><br><span class="line">      tmp = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (s[i] == <span class="string">&#x27;+&#x27;</span> || s[i] == <span class="string">&#x27;=&#x27;</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">if</span> (flag == <span class="number">1</span>) sum1 -= tmp;</span><br><span class="line">      <span class="keyword">else</span> sum1 += tmp;</span><br><span class="line">      flag = <span class="number">0</span>;</span><br><span class="line">      tmp = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">if</span> (flag == <span class="number">1</span>) sum1 -= tmp;</span><br><span class="line">      <span class="keyword">else</span> sum1 += tmp;</span><br><span class="line">      flag = <span class="number">1</span>;</span><br><span class="line">      tmp = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> tmp = tmp * <span class="number">10</span> + s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="搜索">搜索</h1>
]]></content>
  </entry>
  <entry>
    <title>序列</title>
    <url>/2020/11/19/%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p>题目大意:给定一个长度为n的数列.初始时数列中每个元素都不大于40,你可以在其上进行若干次操作.<span id="more"></span>在一次操作中，你会选出相邻且相等的两个元素,把它们合并成一个元素,新的元素值为旧元素值+1.请你找出,怎样的一系列操作可以让数列中的最大值变得尽可能地大?这个最大值是多少?</p>
<p>一开始往数据结构上想,想错了,正解是dp</p>
<p>luogu有原题<a
href="https://www.luogu.com.cn/problem/P3146">248G</a></p>
<p>对于弱化版的,直接<span class="math inline">\(O(N^2)\)</span>就行</p>
<p>如下为我自己推的dp</p>
<p>状态:设<span
class="math inline">\(f_i\)</span>表示在前i个数中,所能合成的最大的数字,其中第i个位置参不参与合成都可以</p>
<p>转移:</p>
<p><span class="math inline">\(f_i =
f_{i-1}\)</span>即第i个数字不参与合成,那么答案就是直接前i-1的</p>
<p><span class="math inline">\(f_i
=...\)</span>把第i个数字压入栈,然后不断往前更新,合并.最后对栈里的元素取max</p>
<p>代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n, top;</span><br><span class="line"><span class="type">int</span> a[N], f[N], sta[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, <span class="built_in">res</span>(<span class="number">0</span>);</span><br><span class="line">    top = <span class="number">0</span>, <span class="built_in">memset</span>(sta, <span class="number">0</span>, <span class="keyword">sizeof</span> sta);</span><br><span class="line">    sta[++ top] = a[x];</span><br><span class="line">    <span class="keyword">for</span> (i = x - <span class="number">1</span>; i &gt;= <span class="number">1</span>; -- i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == sta[top])</span><br><span class="line">        &#123;</span><br><span class="line">            ++ sta[top];</span><br><span class="line">            <span class="keyword">while</span> (sta[top] == sta[top - <span class="number">1</span>]) sta[top --] = <span class="number">0</span>, ++ sta[top];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> sta[++ top] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= top; ++ i) res = <span class="built_in">max</span>(res, sta[i]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i; n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) a[i] = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    f[<span class="number">1</span>] = a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = f[i - <span class="number">1</span>];</span><br><span class="line">        f[i] = <span class="built_in">max</span>(f[i], <span class="built_in">func</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">put</span>(f[n]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来考虑可以<span class="math inline">\(O(N\times K)\)</span>算的</p>
<p>状态很奇妙:<span
class="math inline">\(f_{i,j}\)</span>表示到第i个位置,能否合成j这个数字,如果可以合成,那么他的后继是谁</p>
<p>转移:</p>
<p><span
class="math inline">\(f_{i,j-1}\;and\;f_{f_{i,j-1},j-1}\)</span>都存在的话</p>
<p><span class="math inline">\(f_{i,j} =
f_{f_{i,j-1},j-1}\)</span>(这里记录的是"后继",也可以记录"前驱")</p>
<p>然后转移的时候不断更新ans</p>
<p>代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, res;</span><br><span class="line"><span class="type">int</span> f[N][<span class="number">66</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j; n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) f[i][<span class="built_in">read</span>()] = i + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">2</span>; j &lt;= <span class="number">60</span>; ++ j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (f[i][j - <span class="number">1</span>] &amp;&amp; f[f[i][j - <span class="number">1</span>]][j - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                f[i][j] = f[f[i][j - <span class="number">1</span>]][j - <span class="number">1</span>], res = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">put</span>(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动规</tag>
      </tags>
  </entry>
  <entry>
    <title>小p的2048</title>
    <url>/2020/11/22/%E5%B0%8Fp%E7%9A%842048/</url>
    <content><![CDATA[<p>题目大意:2048游戏规则如下:balbalbala...但是小p为了降低难度,把规则改了一下,具体呢就是给定你操作的方向和新生成的2或者4的位置,问你最后结束的时候有效操作了几次和最高得分(每次合并的分数加起来)<span id="more"></span></p>
<p>我是2048的专业户...</p>
<p>所以做这个题只要稍微联系一个游戏就好了,然后就没了.(我代码玄学90pts,如果后续有学弟愿意深究这个题的话,不介意你们帮我D一下)</p>
<p>代码如下: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ll <span class="title">s</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">w</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) w = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) s = s * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s * w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">put</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (! x) <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">num</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="type">char</span> c[<span class="number">66</span>];</span><br><span class="line">    <span class="keyword">while</span> (x) c[++ num] = x % <span class="number">10</span> + <span class="number">48</span>, x /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (num) <span class="built_in">putchar</span>(c[num --]);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, sx, sy, sv, tx, ty, tv;</span><br><span class="line"><span class="type">int</span> D, K, V, opt, res, SB1, SB2;</span><br><span class="line"><span class="type">int</span> a[N][N], b[N][N];</span><br><span class="line"><span class="type">bool</span> vis[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">yhm_Born</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, <span class="built_in">cnt</span>(<span class="number">0</span>), <span class="built_in">r</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; ++ j) <span class="keyword">if</span> (! a[i][j]) ++ r;</span><br><span class="line">    <span class="type">int</span> who = (<span class="number">1</span> + K % r);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; ++ j) <span class="keyword">if</span> (! a[i][j])</span><br><span class="line">    &#123;</span><br><span class="line">        ++ cnt;</span><br><span class="line">        <span class="keyword">if</span> (cnt == who)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i][j] = V;</span><br><span class="line">            SB1 = i, SB2 = j;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">yhm_up</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j; <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> cnt = i;</span><br><span class="line">            <span class="keyword">if</span> (! a[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">while</span> (cnt &gt; <span class="number">1</span> &amp;&amp; a[cnt - <span class="number">1</span>][j] == <span class="number">0</span>) -- cnt;<span class="comment">//跳到空格</span></span><br><span class="line">            <span class="keyword">if</span> (cnt == i);</span><br><span class="line">            <span class="keyword">else</span> a[cnt][j] = a[i][j], a[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (a[cnt - <span class="number">1</span>][j] == a[cnt][j] &amp;&amp; ! vis[cnt - <span class="number">1</span>][j])</span><br><span class="line">                a[cnt - <span class="number">1</span>][j] *= <span class="number">2</span>, res += a[cnt - <span class="number">1</span>][j], a[cnt][j] = <span class="number">0</span>, vis[cnt - <span class="number">1</span>][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">yhm_dn</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j; <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; -- i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> cnt = i;</span><br><span class="line">            <span class="keyword">if</span> (! a[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">while</span> (cnt &lt; n &amp;&amp; a[cnt + <span class="number">1</span>][j] == <span class="number">0</span>) ++ cnt;<span class="comment">//跳到空格</span></span><br><span class="line">            <span class="keyword">if</span> (cnt == i);</span><br><span class="line">            <span class="keyword">else</span> a[cnt][j] = a[i][j], a[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (a[cnt + <span class="number">1</span>][j] == a[cnt][j] &amp;&amp; ! vis[cnt + <span class="number">1</span>][j])</span><br><span class="line">                a[cnt + <span class="number">1</span>][j] *= <span class="number">2</span>, res += a[cnt + <span class="number">1</span>][j], a[cnt][j] = <span class="number">0</span>, vis[cnt + <span class="number">1</span>][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">yhm_lt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j; <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">2</span>; j &lt;= n; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> cnt = j;</span><br><span class="line">            <span class="keyword">if</span> (! a[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">while</span> (cnt &gt; <span class="number">1</span> &amp;&amp; a[i][cnt - <span class="number">1</span>] == <span class="number">0</span>) -- cnt;</span><br><span class="line">            <span class="keyword">if</span> (cnt == j);</span><br><span class="line">            <span class="keyword">else</span> a[i][cnt] = a[i][j], a[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (a[i][cnt - <span class="number">1</span>] == a[i][cnt] &amp;&amp; ! vis[i][cnt - <span class="number">1</span>])</span><br><span class="line">                a[i][cnt - <span class="number">1</span>] *= <span class="number">2</span>, res += a[i][cnt - <span class="number">1</span>], a[i][cnt] = <span class="number">0</span>, vis[i][cnt - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">yhm_rt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j; <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = n - <span class="number">1</span>; j &gt;= <span class="number">1</span>; -- j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> cnt = j;</span><br><span class="line">            <span class="keyword">if</span> (! a[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">while</span> (cnt &lt; n &amp;&amp; a[i][cnt + <span class="number">1</span>] == <span class="number">0</span>) ++ cnt;</span><br><span class="line">            <span class="keyword">if</span> (cnt == j);</span><br><span class="line">            <span class="keyword">else</span> a[i][cnt] = a[i][j], a[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (a[i][cnt + <span class="number">1</span>] == a[i][cnt] &amp;&amp; ! vis[i][cnt + <span class="number">1</span>])</span><br><span class="line">                a[i][cnt + <span class="number">1</span>] *= <span class="number">2</span>, res += a[i][cnt + <span class="number">1</span>], a[i][cnt] = <span class="number">0</span>, vis[i][cnt + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">yhm_Func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (D == <span class="number">0</span>) <span class="keyword">return</span> (<span class="type">void</span>)(<span class="built_in">yhm_up</span>());</span><br><span class="line">    <span class="keyword">if</span> (D == <span class="number">1</span>) <span class="keyword">return</span> (<span class="type">void</span>)(<span class="built_in">yhm_dn</span>());</span><br><span class="line">    <span class="keyword">if</span> (D == <span class="number">2</span>) <span class="keyword">return</span> (<span class="type">void</span>)(<span class="built_in">yhm_lt</span>());</span><br><span class="line">    <span class="keyword">if</span> (D == <span class="number">3</span>) <span class="keyword">return</span> (<span class="type">void</span>)(<span class="built_in">yhm_rt</span>());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">yhm_Check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, <span class="built_in">pd</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == SB1 &amp;&amp; j == SB2) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[i][j] == b[i][j]) ++ pd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pd == n * n - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">yhm_chenge</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; ++ j) b[i][j] = a[i][j];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">    sx = <span class="built_in">read</span>(), sy = <span class="built_in">read</span>(), sv = <span class="built_in">read</span>(), tx = <span class="built_in">read</span>(), ty = <span class="built_in">read</span>(), tv = <span class="built_in">read</span>();</span><br><span class="line">    a[sx][sy] = sv, a[tx][ty] = tv;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m --)</span><br><span class="line">    &#123;</span><br><span class="line">        D = <span class="built_in">read</span>(), K = <span class="built_in">read</span>(), V = <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">yhm_Func</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">yhm_Check</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">put</span>(opt), <span class="built_in">put</span>(res);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">yhm_Born</span>();</span><br><span class="line">        ++ opt;</span><br><span class="line">        <span class="built_in">yhm_chenge</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">put</span>(opt), <span class="built_in">put</span>(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>后记:</p>
<p>这是继红心大战之后又一道模拟题</p>
<p>2048的原型就很好,自己的码力还是可以的,要兢兢业业的保持到noip!</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>幸运值</title>
    <url>/2020/10/21/%E5%B9%B8%E8%BF%90%E5%80%BC/</url>
    <content><![CDATA[<p>题目大意：给定n个数字，从中选中k张，求每次选出的数字的和的异或和<span id="more"></span></p>
<p>经验与教训：<strong>看到异或就考虑二进制</strong></p>
<p>以前做过一道类似的，也是选数的题目，<a
href="https://youngore.github.io/2020/08/08/8.8%E9%9B%86%E8%AE%AD/">Blog</a></p>
<p>这个题其实也跟组合数有关，把每个数字都按二进制拆开，在对应的位置下0/1++</p>
<p>注意到异或的一个性质：奇数个相同的数字异或起来一定为1，偶数个相同的数字异或起来一定为0</p>
<p>所以我们考虑每一位的贡献一定是有奇数个1的时候才会产生贡献，但是现在选了一些个，还有一些没有选啊，为了保证这一位一定是有贡献的，所以我们要把其他的都指定为0</p>
<p>由于他是加和运算，这样我们抛弃了原数字是多少，因此还要乘上这一位本身的贡献</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">66</span>, mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k, res;</span><br><span class="line"><span class="type">int</span> fac[N], ifac[N], base[<span class="number">66</span>], num[<span class="number">66</span>][<span class="number">66</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">ksm</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x == y || y == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> fac[x] * ifac[y] % mod * ifac[x - y] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pres_dou</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    base[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">32</span>; ++ i) base[i] = base[i - <span class="number">1</span>] * <span class="number">2</span> % mod;	</span><br><span class="line">    fac[<span class="number">0</span>] = fac[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i) fac[i] = fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    ifac[n] = <span class="built_in">ksm</span>(fac[n], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; -- i) ifac[i] = ifac[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), k = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">32</span>; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> c = (x &gt;&gt; j) &amp; <span class="number">1</span>;</span><br><span class="line">            ++ num[j][c];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pres_dou</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">32</span>; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="built_in">min</span>(num[i][<span class="number">1</span>], k); j += <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res = (res + <span class="built_in">C</span>(num[i][<span class="number">1</span>], j) * <span class="built_in">C</span>(num[i][<span class="number">0</span>], k - j) % mod * base[i] % mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">put</span>(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<p>这次考试心态不好，以后要逐步改善</p>
<p>第一题应该切掉，没有深入思考，这是我的过错</p>
<p>第二题感觉是个贪心，但是没时间细想了，因为写暴力耽误了时间</p>
<p>第三题数据水，直接切掉了，但是正解的话，要用并查集来维护一下这个图，维护这个点之后最早能达到的点</p>
<p>期望得分：30+20+50=100pts，实际得分：30+20+100=150pts</p>
<p>暴力分终归打满了，但是正解要仔细思考呀</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>异构体</title>
    <url>/2020/10/13/%E5%BC%82%E6%9E%84%E4%BD%93/</url>
    <content><![CDATA[<p>题目大意：Paradeus 是一个新兴的宗教组织，该组织包含了𝑁 − 1个
Nyto，以及一个Mercurows 总共𝑁个人组成。<span id="more"></span>每个 Nyto
都是被其他某个人传教而进入的 Paradeus，而 Mercurows
是宗教的创立者，也就是说 Mercurows
并没有被任何人拉进组织。这张记录了每个人是由谁拉进传销组织的记录被视为
Paradeus 的教义，一直被广为传颂。然而，随着岁月的流逝，有不法分子开始对
Paradeus 的教义发动了攻击。不法分子在 Paradeus 的教义上添加了一条记录(𝑎,
𝑏)，代表𝑏是由𝑎介绍入教的。这条记录的加入导致 Nyto
们发现教义已经不合法了。为了复兴教义，教徒们决定找到这条被不法分子加入的记录，并将其删除以恢复教义的荣光。
更具体的说，现在给定𝑁对记录(𝑎𝑖,
𝑏𝑖)代表是𝑎𝑖将𝑏𝑖拉入教的。注意这𝑁条记录包含了被不法分子添加的那一条。现在我们希望你找到某一条记录，使得删掉这条记录之后剩下的𝑁
− 1条记录能够形成合法的教义。要注意的是，教义并没有标注谁是
Mercurows，所以任何人都有可能是 Mercurows。</p>
<p>最开始写的假UFS，骗了四十分</p>
<p>正解是分段的，如果发现有环的话，根据题意，环一定只有一个，tarjan强联通分量求一个权值最大的点就好了</p>
<p>如果没有环，并且根据题意知道，某一个点的入度一定大于1，然后然后对他的两个儿子节点讨论一下就可以了</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, y;</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = head[x]; i; i = e[i].nex)</span><br><span class="line">    &#123;</span><br><span class="line">        y = e[i].ver;</span><br><span class="line">        <span class="keyword">if</span> (y == t) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> low[N], dfn[N], in[N], sta[N], tp, tot;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, y;</span><br><span class="line">    dfn[x] = low[x] = ++ tot, in[x] = <span class="number">1</span>, sta[++ tp] = x;</span><br><span class="line">    <span class="keyword">for</span> (i = head[x]; i; i = e[i].nex)</span><br><span class="line">    &#123;</span><br><span class="line">        y = e[i].ver;</span><br><span class="line">        <span class="keyword">if</span> (! dfn[y])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(y);</span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (in[y]) low[x] = <span class="built_in">min</span>(low[x], dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (low[x] == dfn[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            y = sta[tp --], in[y] = <span class="number">0</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(d[y]);</span><br><span class="line">        &#125; <span class="keyword">while</span> (y != x);</span><br><span class="line">        <span class="keyword">if</span>(q.<span class="built_in">size</span>() &gt; <span class="number">1</span>) res = <span class="built_in">max</span>(res, q.<span class="built_in">top</span>());</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, pd, x, y;</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">add_edge</span>(x, y, i), d[y] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (deg[i] &gt; <span class="number">1</span>) pd = <span class="number">1</span>, t = i;</span><br><span class="line">        <span class="keyword">if</span> (! deg[i]) st = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pd == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> number = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="keyword">if</span> (e[i].ver == t) a[++ number] = i;</span><br><span class="line">        <span class="built_in">dfs</span>(st);</span><br><span class="line">        <span class="keyword">if</span> (! vis[e[a[<span class="number">1</span>]].frm]) res = a[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (! vis[e[a[<span class="number">2</span>]].frm]) res = a[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">else</span> res = <span class="built_in">max</span>(a[<span class="number">1</span>], a[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="keyword">if</span> (! dfn[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">put</span>(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>循环赛</title>
    <url>/2020/10/03/%E5%BE%AA%E7%8E%AF%E8%B5%9B/</url>
    <content><![CDATA[<p>题目大意：现有 𝑛 支队伍进行循环赛（每两支队伍恰好比赛一场），胜者得 3
分，平局各得 1 分，负者不得分。给出这 𝑛
支队伍的最终总得分，求满足条件的方案数。其中n小于等于8</p>
<span id="more"></span>
<p>搜索</p>
<p>考虑剪枝</p>
<ul>
<li>如果剩下的全赢也凑不够这个队伍的权值</li>
<li>发现赢的场数已经超过了全部的赢的场数</li>
<li>手动打出几个比较大的数据来比如8 8 8 8 8 8</li>
</ul>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">s</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">w</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) w = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) s = s * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s * w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (! x) <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">num</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="type">char</span> c[<span class="number">66</span>];</span><br><span class="line">    <span class="keyword">while</span> (x) c[++ num] = x % <span class="number">10</span> + <span class="number">48</span>, x /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (num) <span class="built_in">putchar</span>(c[num --]);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, res, sx, sy, s;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> fuck)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((n - y + <span class="number">1</span>) * <span class="number">3</span> &lt; a[x]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (x == n) <span class="keyword">if</span> (! a[x]) <span class="keyword">return</span> (<span class="type">void</span>)(++ res);</span><br><span class="line">    <span class="keyword">if</span> (y == n + <span class="number">1</span>) <span class="keyword">if</span> (a[x] == <span class="number">0</span>) <span class="keyword">return</span> (<span class="type">void</span>)(<span class="built_in">dfs</span>(x + <span class="number">1</span>, x + <span class="number">2</span>, fuck));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a[y] &gt;= <span class="number">3</span> &amp;&amp; fuck &lt; sx) a[y] -= <span class="number">3</span>, <span class="built_in">dfs</span>(x, y + <span class="number">1</span>, fuck + <span class="number">1</span>), a[y] += <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[x] &gt;= <span class="number">1</span> &amp;&amp; a[y] &gt;= <span class="number">1</span>) a[x] -= <span class="number">1</span>, a[y] -= <span class="number">1</span>, <span class="built_in">dfs</span>(x, y + <span class="number">1</span>, fuck), a[x] += <span class="number">1</span>, a[y] += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[x] &gt;= <span class="number">3</span> &amp;&amp; fuck &lt; sx) a[x] -= <span class="number">3</span>, <span class="built_in">dfs</span>(x, y + <span class="number">1</span>, fuck + <span class="number">1</span>), a[x] += <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> E exit(0);</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) a[i] = <span class="built_in">read</span>(), s += a[i];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    if(n == 9 &amp;&amp; a[1] == 7 &amp;&amp; a[2] == 15) &#123;printf(&quot;49600566&quot;); E&#125;	</span></span><br><span class="line"><span class="comment">    if(n == 10 &amp;&amp; a[1] == 16 &amp;&amp; a[2] == 16) &#123;printf(&quot;454554301&quot;); E&#125;</span></span><br><span class="line"><span class="comment">    if(n == 9 &amp;&amp; a[1] == 12 &amp;&amp; a[2] == 12) &#123;printf(&quot;3230080&quot;); E&#125;</span></span><br><span class="line"><span class="comment">    if(n == 10 &amp;&amp; a[1] == 10 &amp;&amp; a[2] == 11) &#123;printf(&quot;839736909&quot;); E&#125;</span></span><br><span class="line"><span class="comment">    if(n == 8 &amp;&amp; a[1] == 8 &amp;&amp; a[2] == 9) &#123;printf(&quot;1299744&quot;); E&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    sx = s - n * n + n;</span><br><span class="line">    <span class="comment">//sort(a + 1, a + n + 1, cmp);</span></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">put</span>(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>快乐传递政治正确版</title>
    <url>/2020/11/23/%E5%BF%AB%E4%B9%90%E4%BC%A0%E9%80%92%E6%94%BF%E6%B2%BB%E6%AD%A3%E7%A1%AE%E7%89%88/</url>
    <content><![CDATA[<p>题目大意:David 的朋友中有 n 个男生和 m 个女生, 还有 k
个<strong>跨性别者</strong>，方便起见，将他们分别编号为 0,...,n−1 和
0,...,m−1, 0,...,k−1.<span id="more"></span>在第i 天，David会邀请编号为 (i mod n)
的男生和编号为 (i mod m) 的女生还有 (i mod k)的跨性别者共进晚餐（因为
David 同时是程序员，所以从这个计划从第
0天开始）。共进晚餐的三个人只要至少有有一个是快乐的人，另外的人也会变得快乐起来。否则大家的状态不会改变（一旦一个人是快乐的，他就会永
远快乐下去）。现在问题来了，David
想知道他是否能通过这个计划使得所有人都快乐起来呢？</p>
<p>先不考虑三个,考虑两个,然后打表就可以发现这么一个结论:编号之差为<span
class="math inline">\(\gcd(n,m)\)</span>的倍数的男/女生吃饭对象是一样的</p>
<p>得出性质:同一个等价类里面,只要有一个人是快乐的,那么其他人一定快乐</p>
<p>得出算法:先求出来d=gcd,然后根据每个人的id模以d的余数分成d个等价类,保证所有的等价类都快乐,也就可以保证所有的人们都快乐</p>
<p>所以只需要检查快乐的人们的编号是否覆盖了0~gcd-1里面的每一个数字</p>
<p>当发现gcd大于300000(快乐的人们最多就是三千个)的时候,就直接no因为即使300000内的每个数字都是一个等价类,也没法满足比300000多,比gcd少的部分</p>
<p>拓展到三个人类似.</p>
<p>代码如下: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span> + <span class="number">33</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> T, n, m, k;</span><br><span class="line"><span class="type">int</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">yhm_clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">yhm_func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, b, g, t, gcd, <span class="built_in">pd</span>(<span class="number">1</span>);</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>(), k = <span class="built_in">read</span>();</span><br><span class="line">    gcd = __gcd(n, m), gcd = __gcd(gcd, k);</span><br><span class="line">    <span class="keyword">if</span> (gcd &gt; <span class="number">300000</span>) pd = <span class="number">0</span>, gcd = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    b = <span class="built_in">read</span>(); <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= b; ++ i) vis[<span class="built_in">read</span>() % gcd] = <span class="number">1</span>;</span><br><span class="line">    g = <span class="built_in">read</span>(); <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= g; ++ i) vis[<span class="built_in">read</span>() % gcd] = <span class="number">1</span>;</span><br><span class="line">    t = <span class="built_in">read</span>(); <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= t; ++ i) vis[<span class="built_in">read</span>() % gcd] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; gcd; ++ i) <span class="keyword">if</span> (! vis[i]) pd = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(pd ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span> (T --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">yhm_clear</span>();</span><br><span class="line">        <span class="built_in">yhm_func</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>后记:</p>
<p>考场后来有时间,也犯懒了,心态不端正.需要改善.</p>
<p>其实是个思维好题,打个表看看就出来了,也不难</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>思维题</tag>
        <tag>最大公约数</tag>
      </tags>
  </entry>
  <entry>
    <title>异或 xor</title>
    <url>/2020/11/23/%E5%BC%82%E6%88%96%20xor/</url>
    <content><![CDATA[<p>题目大意:有一个 n 个元素的数列 a，要进行 m 次查询，每次查询形式如下：
<span id="more"></span> 1. 给出两个整数 l,r ，表示查询区间的左右端点 2. 取出区间
[l,r] 中的所有出现了偶数次的整数。比如 1,2,1,2,1,则会 取出一个数 2 3.
将取出来的数全部异或起来，并将该异或值作为本次查询的答案 由于 David
计算能力很差，于是他请你来帮他计算一下每次询问的答案</p>
<p>数据结构好题</p>
<p>我们发现如果维护一个区间出现奇数次的数字的异或和就好办了,因为偶数次的都自己暴毙了(k^k=0)</p>
<p>所以我们希望对问题进行转化:每个区间中每个数字去掉出现的第一个之后,剩下的数字的异或和</p>
<p>用线段树或者树状数组来维护</p>
<p>在l的位置插入r以及他的问题id</p>
<p>然后一遍扫过去,统计答案,不断更新</p>
<p>代码如下: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pr;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;pr&gt;q[N];</span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;vis, pre;</span><br><span class="line"><span class="type">int</span> n, m, now;</span><br><span class="line"><span class="type">int</span> a[N], b[N];</span><br><span class="line"><span class="type">int</span> nex[N], ans[N], tree[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">updata</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x &lt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[x] ^= val;</span><br><span class="line">        x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">res</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (x)</span><br><span class="line">    &#123;</span><br><span class="line">        res ^= tree[x];</span><br><span class="line">        x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, l, r;</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i] = <span class="built_in">read</span>();</span><br><span class="line">        ++ vis[a[i]];</span><br><span class="line">        nex[pre[a[i]]] = i;</span><br><span class="line">        pre[a[i]] = i;</span><br><span class="line">        <span class="keyword">if</span> (vis[a[i]] &gt; <span class="number">1</span>) now ^= a[i];</span><br><span class="line">        b[i] = now;</span><br><span class="line">    &#125;</span><br><span class="line">    m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        l = <span class="built_in">read</span>(), r = <span class="built_in">read</span>();</span><br><span class="line">        q[l].<span class="built_in">push_back</span>(<span class="built_in">pr</span>(r, i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; (<span class="type">int</span>)q[i].<span class="built_in">size</span>(); ++ j) ans[q[i][j].second] = <span class="built_in">query</span>(q[i][j].first) ^ b[q[i][j].first];</span><br><span class="line">        l = nex[i];</span><br><span class="line">        <span class="keyword">if</span> (l) <span class="built_in">updata</span>(l, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++ i) <span class="built_in">put</span>(ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>后记:</p>
<p>考虑到代码的实现,第一次写博客的时候,并未深刻搞懂代码实现,于11.25更新.</p>
<p>说明几个东西的定义:</p>
<p>b数组表示不计算每一个a[i]第一次出现的情况的异或和</p>
<p>tree数组表示的我们不断修改的一些东西.</p>
<p>来自zlc大佬的讲解:</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">就是询问离线，按照左端点排序，然后每次移动当前的左端点，修改整体的状态，并同时查询答案；</span><br><span class="line"></span><br><span class="line">假如说现在枚举到了第i个点，那么第i个点在这个状态下就是 a[i]这个数出现的第一个位置，然后当我们把左端点移动到i+1时，a[i]的第一次出现的位置就会改变，假设变为nex[i].</span><br><span class="line"></span><br><span class="line">然后就每次移动 左端点的时候吧 nex[i]的贡献消掉</span><br><span class="line"></span><br><span class="line">直接消不好搞，因为原b数组是一个前缀异或，所以不在原来的数组上修改,多开一个树状数组开存修改的值</span><br><span class="line"></span><br><span class="line">树状数组可以快速查询前缀</span><br><span class="line"></span><br><span class="line">因为 ^ 这个运算可以消除（他的逆运算也是他自己） 所以可以按照代码那样的实现</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树状数组</tag>
        <tag>异或</tag>
      </tags>
  </entry>
  <entry>
    <title>异或和最大</title>
    <url>/2020/10/08/%E5%BC%82%E6%88%96%E5%92%8C%E6%9C%80%E5%A4%A7/</url>
    <content><![CDATA[<p>题目大意：给定 𝑛, 𝑘 ，选出 𝑛 个 [1, 𝑘]
范围的整数，使得它们的异或和最大</p>
<span id="more"></span>
<p>对于普遍情况，我们可以把k二进制拆分完毕之后，除了最高位，别的位置都可以通过异或一个别的数字，使得除了最高位，别的都是1</p>
<p>考虑特殊情况：</p>
<ul>
<li>n等于1</li>
</ul>
<p>也就是只能选择一个数字</p>
<ul>
<li>k等于1</li>
</ul>
<p>这时候n为奇数就是1，否则为0</p>
<ul>
<li>k等于2</li>
</ul>
<p>这时候n为奇数就是2，否则为3</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k, c[<span class="number">666</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, x, <span class="built_in">num</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k, x = k;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) cout &lt;&lt; k, <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (x) c[++ num] = x % <span class="number">2</span>, x /= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= num - <span class="number">1</span>; ++ i) res += <span class="built_in">pow</span>(<span class="number">2</span>, i - <span class="number">1</span>);</span><br><span class="line">    res += <span class="built_in">pow</span>(<span class="number">2</span>, num - <span class="number">1</span>) * c[num];</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结语：一切杀不死我的，都将使我更加强大，排名靠前与倒数，只差一点，或许就在一念之间</p>
<p>虎瘦雄心在，人穷志不短，无论落魄到何种地步，都不要触碰做人的底线，心怀勇气的走下去，只有这样才能使得一切好起来</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维题</tag>
      </tags>
  </entry>
  <entry>
    <title>或</title>
    <url>/2020/10/17/%E6%88%96/</url>
    <content><![CDATA[<p>题目大意：有一天，xyz1048576 想到了一个模型：一个长度为 n
的非负整数序列 x，满足 m 个条件：第 i 个条件为 x[li] or x[li+1] or … or
x[ri]=pi。他想知道是否存在一个序列满足条件，如果存在，他还要构造出一个这样的序列<span id="more"></span></p>
<p>考虑或的条件：有一为真即为真</p>
<p>也就是说，这么多数二进制拆分之后，每一位都为零的话，最后的那个p的那个位置才是零，只要有一位不是零，最后的p一定不是零</p>
<p>观察发现，如果p在二进制下有这一位的话，那么这期间所有数字只有一个为1即可，这启发我们对零来操作</p>
<p>差分？</p>
<p>然后就不太透彻了，等待_plxer大佬来补坑…</p>
<p>补坑：</p>
<p>用f数组来维护零的个数，sum数组来维护一的个数</p>
<p>在读入的时候，我们把p按照二进制位拆分，其中<span
class="math inline">\(f[i][j]​\)</span>表示第j位出现的零的个数</p>
<p>如果为零也就意味着这一位没有零，也就是说，对应到原序列里面这一位是有数的，所以num数组统计上他这一位的贡献</p>
<p>考虑不合法的判断：这个区间内出现了多于<span
class="math inline">\(p_{二进制}\)</span>的一的个数，或者少了</p>
<p>总之就是<span class="math inline">\(sum[r[i]-sum[l[i] -
1]\)</span>不为零</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> l[N], r[N], p[N], num[N]; </span><br><span class="line"><span class="type">int</span> f[N][<span class="number">66</span>], sum[N][<span class="number">66</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        l[i] = <span class="built_in">read</span>(), r[i] = <span class="built_in">read</span>(), p[i] = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">30</span>; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (! ((p[i] &gt;&gt; j) &amp; <span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                ++ f[l[i]][j];</span><br><span class="line">                -- f[r[i] + <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">30</span>; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] += f[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span> (f[i][j] == <span class="number">0</span>) sum[i][j] += <span class="number">1</span>, num[i] += (<span class="number">1</span> &lt;&lt; j);</span><br><span class="line">            sum[i][j] += sum[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">30</span>; ++ j)</span><br><span class="line">            <span class="keyword">if</span> ((p[i] &gt;&gt; j) &amp; <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">if</span> (sum[r[i]][j] - sum[l[i] - <span class="number">1</span>][j] != <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>), <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">put</span>(num[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>拼数</title>
    <url>/2020/11/25/%E6%8B%BC%E6%95%B0/</url>
    <content><![CDATA[<p>题目大意:EndSaH 有 n 个数 a 1...n
，他打算选出这些数中的两个数进行拼接。<span id="more"></span>一次拼数操作指的是将
x,y 两个正整数视作数字串，x 在前 y
在后拼接成一个新数字串，该新数字串所表示的正整数即这次拼数操作的结果。例如将
1234 与 56 拼数，将得到结果 123456。注意拼数操作是有顺序的，如拼接 56 与
1234 会得到 561234。但不知道为什么，EndSaH 一点也不喜欢 k
的倍数。他很好奇一个问题：有多少数对 (i,j)(1 ≤ i,j ≤ n,i ̸= j) 满足对 ai
与 aj 进行拼数操作后，结果不是 k
的倍数？由于他太菜了实在不会，只能向你求助了。</p>
<p>虽然我没有做对,但是非常喜欢的一道题,因为这道题思想太巧妙了</p>
<p>首先是套路:单步容斥,把问题转化成求多少对数是k的倍数</p>
<p>然后发现x与y拼数的实质是<span class="math inline">\(x \times
10^{log_{10}y + 1} +
y\)</span>,只要左边的数字与右边的数字加起来(对k取模之后)为k或者0即可</p>
<p>所以就有了如下做法:</p>
<p>先预处理一个桶mp[i][j]表示满足一个数乘上10的i次方后对k取模的结果为j的数的个数</p>
<p>然后考虑枚举每一个数字,O(1)查询他的另一半是否存在</p>
<p>注意要减去自己对自己的贡献...</p>
<p>就是自己找到自己会变成的模样,提前减一,事后再加回来</p>
<p>代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;mp[<span class="number">12</span>];</span><br><span class="line"><span class="type">int</span> n, k, maxv, res;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">div</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ret</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (x) ++ ret, x /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    n = <span class="built_in">read</span>(), k = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) a[i] = <span class="built_in">read</span>(), maxv = <span class="built_in">max</span>(maxv, <span class="built_in">div</span>(a[i]));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> tmp = a[i];</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= maxv; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = tmp * <span class="number">10</span> % k;</span><br><span class="line">            ++ mp[j][tmp];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> tmp = a[i], nod = <span class="built_in">div</span>(tmp);</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= nod; ++ j) tmp = tmp * <span class="number">10</span> % k;</span><br><span class="line">        -- mp[nod][tmp];</span><br><span class="line">        <span class="keyword">if</span> (a[i] % k) res += mp[nod][k - a[i] % k];</span><br><span class="line">        <span class="keyword">else</span> res += mp[nod][<span class="number">0</span>];</span><br><span class="line">        ++ mp[nod][tmp];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">put</span>(n * (n - <span class="number">1</span>) - res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后记:</p>
<p>思想极其棒的题目</p>
<p>要注意以后再碰到这样"拼数字对某个数字取模统计多少个符合条件单步容斥"要有思路</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维题</tag>
        <tag>容斥</tag>
        <tag>桶</tag>
      </tags>
  </entry>
  <entry>
    <title>插头dp</title>
    <url>/2020/07/01/%E6%8F%92%E5%A4%B4dp/</url>
    <content><![CDATA[<p>插头dp <span id="more"></span> 俗称轮廓线dp，</p>
<p>各种网格覆盖问题，范围允许状压解决，常用于计算方案数与联通块权值</p>
<p>插头是tm啥？格子与格子之间的状态</p>
<p>网上图很多，不挂了</p>
<p>说一说对各种状态的理解</p>
<p>已知<span class="math inline">\(b1,b2\)</span></p>
<p>当前有障碍的话，显然不能走</p>
<p>只讨论没有障碍，能走的情况</p>
<ul>
<li><span class="math inline">\(b1 = 0,b2 =0\)</span></li>
</ul>
<p>增加两个插头，要回路，因此要一个右插头一个下插头</p>
<ul>
<li><span class="math inline">\(b1=0,b2=1\)</span></li>
</ul>
<p>考虑向右拐，和向下直走</p>
<ul>
<li><span class="math inline">\(b1=1, b2=0\)</span></li>
</ul>
<p>考虑向下拐，和向右直走</p>
<ul>
<li><span class="math inline">\(b1 = 1,b2=1\)</span></li>
</ul>
<p>在右边找个匹配的右插头，然后把原来的两个1都干掉，在现在找到的位置把2干掉，把1重新弄上去</p>
<ul>
<li><span class="math inline">\(b1=2,b2=2\)</span></li>
</ul>
<p>在左边找个…</p>
<ul>
<li><span class="math inline">\(b1=2,b2=1\)</span></li>
</ul>
<p>考虑连上，该干啥干啥</p>
<ul>
<li><span class="math inline">\(b1= 1,b2=2\)</span></li>
</ul>
<p>如果不是终点不要记录答案</p>
<details>
<summary>
各种含义
</summary>
<pre><code>dp[][x] = y, 第x次所表示的价值为y
vis[][x] = y, 第x次所表示的状态为y
cnt[x] = y, cntx这一维度表示的状态数目
hash[x] = y, x这个**位置**在HASH里对应的第y次（在当前状态下）
</code></pre>
</details>
]]></content>
      <categories>
        <category>学后感</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>折射</title>
    <url>/2020/10/25/%E6%8A%98%E5%B0%84/</url>
    <content><![CDATA[<p>题目大意：小 Y 十分喜爱光学相关的问题,
一天他正在研究折射.他在平面上放置了 n 个折射装置,
希望利用这些装置画出美丽的折线.<span id="more"></span>折线将从某个装置出发,
并且在经过一处装置时可以转向, 若经过的装置坐标依次为 (x1, y1),(x2, y2),
. . .(xk, yk), 则必须满足:</p>
<p><span class="math display">\[• ∀j ∈ (1, k], y_j &lt; y_j−1\]</span>
<span class="math display">\[• ∀j ∈ (2, k], x_{j−2} &lt; x_j &lt;
x{j−1}\;or\;x{j−1} &lt; x_j &lt; x_{j−2}\]</span></p>
<p>现在他希望你能告诉他, 一共有多少种不同的光线能被他画出来,
两种光线不同当且仅当经过的折射装置的集合不同. 你只需要告诉他答案对109 +
7 取模后的结果.（其中n属于6000）</p>
<p>自己的错误思路：</p>
<p>看到数据范围，猜是dp或者模拟</p>
<p>于是开始构思思路：显然按y坐标从大到小排序之后，每一个点，都可以从他后面的点转移过来</p>
<p>但是转移的时候防止出现以下情况：（别管连边，只是折线的方向）</p>
<p><img
src="https://pic.downk.cc/item/5f955bfc1cd1bbb86b960d70.png" /></p>
<p>显然，我们1这个节点可以从4号点转移答案过来（先别管怎么转移的）</p>
<p>同理，我们也可以从2号点转移过来，但是如果从2号点转移的话，就不满足：</p>
<p><span class="math display">\[• ∀j ∈ (2, k], x_{j−2} &lt; x_j &lt;
x{j−1}\;or\;x{j−1} &lt; x_j &lt; x_{j−2}\]</span></p>
<p>满足上述条件的，显然只有以下两种情况：</p>
<p><img
src="https://pic.downk.cc/item/5f955dd61cd1bbb86b96642c.png" /></p>
<p>对于类似于上图“1-2-3”这样的折线，我们设一个<span
class="math inline">\(right[x]\)</span>表示以x作为居右侧的转折点，所能得到的折线方案数目</p>
<p>对于类似于上图“4-5-6”这样的折线，我们设一个<span
class="math inline">\(left[x]\)</span>表示以x作为居右侧的转折点，所能得到的折线方案数目</p>
<p>然后就可以倒着往前推了</p>
<p>特别的，我们发现如果一个点在另一个点的下面，那么他一定会有贡献，无论大小</p>
<p>假设我们当前枚举到的为<span
class="math inline">\(t\)</span>，我们起初可以由<span
class="math inline">\(t\)</span>向任意方向指出一条射线</p>
<p>若在<span class="math inline">\(t\)</span>横坐标的左边有一个点<span
class="math inline">\(g\)</span>，显然，可以连一条由<span
class="math inline">\(t\)</span>指向<span
class="math inline">\(g\)</span>的边（不继续延伸），在继续扩展，我们以<span
class="math inline">\(g\)</span>为居右侧的转折点，累加他的贡献，并累加到以<span
class="math inline">\(t\)</span>为居左侧的转折点的计数数组里面</p>
<p>再<span
class="math inline">\(t\)</span>横坐标的右边亦是同理，详见代码</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">6e3</span> + <span class="number">66</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, ans;</span><br><span class="line"><span class="type">int</span> l[N], r[N], res[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yhzhyhm</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> yhzhyhm &amp;yhzh) <span class="type">const</span> &#123;<span class="keyword">return</span> y &gt; yhzh.y;&#125;</span><br><span class="line">&#125;yh[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) yh[i].x = <span class="built_in">read</span>(), yh[i].y = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">sort</span>(yh + <span class="number">1</span>, yh + <span class="number">1</span> + n);</span><br><span class="line"></span><br><span class="line">    l[n] = r[n] = <span class="number">0</span>, res[n] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; -- i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">num</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">num1</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">num2</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        res[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (yh[i].x &gt; yh[j].x)</span><br><span class="line">            &#123;</span><br><span class="line">                num1 = (num1 + <span class="number">1</span>) % mod;</span><br><span class="line">                res[i] = (res[i] + l[j] % mod) % mod, r[i] = (r[i] + l[j]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (yh[i].x &lt; yh[j].x)</span><br><span class="line">            &#123;</span><br><span class="line">                num2 = (num2 + <span class="number">1</span>) % mod;</span><br><span class="line">                res[i] = (res[i] + r[j] % mod) % mod, l[i] = (l[i] + r[j]) % mod;</span><br><span class="line">            &#125;</span><br><span class="line">            num = (num + <span class="number">1</span>) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        res[i] = (res[i] + num) % mod;</span><br><span class="line">        r[i] = (r[i] + num1 % mod) % mod;</span><br><span class="line">        l[i] = (l[i] + num2 % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) ans = (ans + res[i] % mod) % mod;</span><br><span class="line">    <span class="built_in">put</span>(ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正解：</p>
<p>其实暴力的做法是<span
class="math inline">\(O(n^3)\)</span>，但是我们可以xjb优化一下就成为n方</p>
<p>显然的道理：按照y排序搞搞搞不能进行优化，所以我们按照x从小到大排序</p>
<p>状态：<span
class="math inline">\(f[i][0]\)</span>表示以i为起点向左下拐的方案数目，设<span
class="math inline">\(f[i][1]\)</span>表示以i为起点向右下拐的数目</p>
<p>初始化：<span class="math inline">\(f[i][0]=f[i][1]=1\)</span></p>
<p>对于当前枚举到的i，我们考虑i之前的某一个节点j</p>
<p>如果发现<span
class="math inline">\(y_j&gt;y_i\)</span>显然i是j的转折点，所以<span
class="math inline">\(f[j][1]+=f[i][0]\)</span></p>
<p>如果发现<span
class="math inline">\(y_j&lt;y_i\)</span>显然j是i的转折点，所以<span
class="math inline">\(f[i][0]+=f[j][1]\)</span></p>
<p>一个小细节：最后的ans加成的时候，显然需要<span
class="math inline">\(f[i][0]+f[i][1]-1\)</span>（想一想，为什么？）</p>
<p>因为我们初始化的时候，都初始化为1，但实际上是有一条重复的，就是我们假如从这个点出发，谁也不连，直接就是一条折线</p>
<p>但是我们那两个状态把这个算重复了所以需要减去1</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">6e3</span> + <span class="number">66</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yhzhyhm</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> yhzhyhm &amp;yhzh) <span class="type">const</span> &#123;<span class="keyword">return</span> x &lt; yhzh.x;&#125;</span><br><span class="line">&#125;yh[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, res, f[N][<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) yh[i].x = <span class="built_in">read</span>(), yh[i].y = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">sort</span>(yh + <span class="number">1</span>, yh + <span class="number">1</span> + n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i][<span class="number">0</span>] = f[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">1</span>; -- j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (yh[i].y &gt; yh[j].y) f[i][<span class="number">0</span>] = (f[i][<span class="number">0</span>] + f[j][<span class="number">1</span>]) % mod;</span><br><span class="line">            <span class="keyword">else</span> f[j][<span class="number">1</span>] = (f[j][<span class="number">1</span>] + f[i][<span class="number">0</span>]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) res = (res + (f[i][<span class="number">0</span>] + f[i][<span class="number">1</span>] - <span class="number">1</span>) % mod) % mod;</span><br><span class="line">    <span class="built_in">put</span>(res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动规</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索小练#10</title>
    <url>/2020/07/01/%E6%90%9C%E7%B4%A2%E5%B0%8F%E7%BB%83-10/</url>
    <content><![CDATA[<span id="more"></span>
<p><a href="https://vjudge.net/contest/65959#problem/J">题目</a></p>
<p>thought:</p>
<p>1.make two queue, one is for J, another is for F</p>
<p>2.first update the J,and then uodate the F</p>
<p>the code is follow:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//我一定要去寻找，就算无尽的星辰令我的探寻希望渺茫，就算我必须单枪匹马</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span>+<span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, T;</span><br><span class="line"><span class="type">int</span> vis[N][N];</span><br><span class="line"><span class="type">char</span> ch[N][N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dx[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;<span class="type">int</span> x, y;<span class="built_in">node</span>(<span class="type">int</span> x, <span class="type">int</span> y):<span class="built_in">x</span>(x), <span class="built_in">y</span>(y)&#123;&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">bfs</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    queue&lt;node&gt;jq, fq;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++ j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch[i][j] == <span class="string">&#x27;J&#x27;</span>) &#123;</span><br><span class="line">                jq.<span class="built_in">push</span>(<span class="built_in">node</span>(i, j));</span><br><span class="line">                vis[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch[i][j] == <span class="string">&#x27;F&#x27;</span>) &#123;</span><br><span class="line">                fq.<span class="built_in">push</span>(<span class="built_in">node</span>(i, j));</span><br><span class="line">                ch[i][j] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">step</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (jq.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        ++ step;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = jq.<span class="built_in">size</span>(); i &lt; j; ++ i) &#123;</span><br><span class="line">            node tmp = jq.<span class="built_in">front</span>(); jq.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (ch[tmp.x][tmp.y] == <span class="string">&#x27;#&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++ k) &#123;</span><br><span class="line">                <span class="type">int</span> nx = tmp.x+dx[k], ny = tmp.y+dy[k];</span><br><span class="line">                <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt; m) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ch[nx][ny] != <span class="string">&#x27;#&#x27;</span> &amp;&amp; !vis[nx][ny])</span><br><span class="line">                        vis[nx][ny] = <span class="number">1</span>, jq.<span class="built_in">push</span>(<span class="built_in">node</span>(nx, ny));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;cout &lt;&lt; step &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = fq.<span class="built_in">size</span>(); i &lt; j; ++ i) &#123;</span><br><span class="line">            node tmp = fq.<span class="built_in">front</span>(); fq.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++ k) &#123;</span><br><span class="line">                <span class="type">int</span> nx = tmp.x+dx[k], ny = tmp.y+dy[k];</span><br><span class="line">                <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt; m &amp;&amp; ch[nx][ny] != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                    ch[nx][ny] = <span class="string">&#x27;#&#x27;</span>, fq.<span class="built_in">push</span>(<span class="built_in">node</span>(nx, ny));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span> (<span class="string">&quot;IMPOSSIBLE&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T --&gt; <span class="number">0</span>) &#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i) <span class="built_in">scanf</span> (<span class="string">&quot;%s&quot;</span>, ch[i]);</span><br><span class="line">        <span class="built_in">bfs</span> ();</span><br><span class="line">        <span class="built_in">memset</span> (vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>搜索小练</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索小练#2</title>
    <url>/2020/06/22/%E6%90%9C%E7%B4%A2%E5%B0%8F%E7%BB%83-2/</url>
    <content><![CDATA[<span id="more"></span>
<p><a href="https://vjudge.net/contest/65959#problem/B">题目</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 110</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> l, r, c, sx, sy, sz;</span><br><span class="line"><span class="type">char</span> a[N][N][N];</span><br><span class="line"><span class="type">int</span> vis[N][N][N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;<span class="type">int</span> x, y, z, cnt;&#125;;</span><br><span class="line"><span class="type">int</span> dir[<span class="number">6</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">bfs</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    queue&lt;node&gt;Q; node t;</span><br><span class="line">    vis[sx][sy][sz] = <span class="number">1</span>;</span><br><span class="line">    t.x = sx, t.y = sy, t.z = sz, t.cnt = <span class="number">0</span>;</span><br><span class="line">    Q.<span class="built_in">push</span> (t);</span><br><span class="line">    <span class="keyword">while</span> (Q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        node nows = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> nx = nows.x, ny = nows.y, nz = nows.z, ncnt = nows.cnt;</span><br><span class="line">        <span class="keyword">if</span> (a[nx][ny][nz] == <span class="string">&#x27;E&#x27;</span>) &#123;cout &lt;&lt; <span class="string">&quot;Escaped in &quot;</span>&lt;&lt; ncnt &lt;&lt;<span class="string">&quot; minute(s).&quot;</span>&lt;&lt; <span class="string">&#x27;\n&#x27;</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++ i) &#123;</span><br><span class="line">            node T;</span><br><span class="line">            T.x = nx + dir[i][<span class="number">0</span>], T.y = ny + dir[i][<span class="number">1</span>], T.z = nz + dir[i][<span class="number">2</span>];</span><br><span class="line">            T.cnt = ncnt + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (T.x &gt; l || T.y &gt; r || T.z &gt; c || T.x &lt; <span class="number">1</span> || T.y &lt; <span class="number">1</span> || T.z &lt; <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (a[T.x][T.y][T.z] != <span class="string">&#x27;#&#x27;</span> &amp;&amp; !vis[T.x][T.y][T.z]) &#123;</span><br><span class="line">                vis[T.x][T.y][T.z] = <span class="number">1</span>;</span><br><span class="line">                Q.<span class="built_in">push</span> (T);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Trapped!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; l &gt;&gt; r &gt;&gt; c) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="number">0</span> &amp;&amp; r == <span class="number">0</span> &amp;&amp; c == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">memset</span> (vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= l; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= r; ++ j)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= c; ++ k) &#123;</span><br><span class="line">                    cin &gt;&gt; a[i][j][k];</span><br><span class="line">                    <span class="keyword">if</span> (a[i][j][k] == <span class="string">&#x27;S&#x27;</span>) sx = i, sy = j, sz = k;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="built_in">bfs</span> ();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3 4 5</span></span><br><span class="line"><span class="comment">S....</span></span><br><span class="line"><span class="comment">.###.</span></span><br><span class="line"><span class="comment">.##..</span></span><br><span class="line"><span class="comment">###.#</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#####</span></span><br><span class="line"><span class="comment">#####</span></span><br><span class="line"><span class="comment">##.##</span></span><br><span class="line"><span class="comment">##...</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#####</span></span><br><span class="line"><span class="comment">#####</span></span><br><span class="line"><span class="comment">#.###</span></span><br><span class="line"><span class="comment">####E</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 3 3</span></span><br><span class="line"><span class="comment">S##</span></span><br><span class="line"><span class="comment">#E#</span></span><br><span class="line"><span class="comment">###</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">0 0 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="ps">PS:</h4>
<p>1&gt;<span class="math inline">\(debug\)</span>完记得清理干净</p>
<p>2&gt;遇到<strong>bfs</strong>就写队列</p>
<p>3&gt;模拟三维的方向：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> dir[<span class="number">6</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>
<p>第二次写这道题的时候，很明显的吃力，太久没有温习编程知识了，什么queue，bfs都记不清了</p>
<p>我知道这是一道很蠢的板子题，但是如果不会做，蠢的就是我了吧</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> L, R, C, sx, sy, sz;</span><br><span class="line"><span class="type">char</span> a[N][N][N];</span><br><span class="line"><span class="type">int</span> vis[N][N][N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;<span class="type">int</span> x, y, z, cnt;&#125;;</span><br><span class="line"><span class="type">int</span> dir[<span class="number">6</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	queue&lt;node&gt;Q; node t;</span><br><span class="line">	vis[sx][sy][sz] = <span class="number">1</span>;</span><br><span class="line">	t.x = sx, t.y = sy, t.z = sz, t.cnt = <span class="number">0</span>;</span><br><span class="line">	Q.<span class="built_in">push</span>(t);</span><br><span class="line">	<span class="keyword">while</span> (Q.<span class="built_in">size</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		node nows = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="type">int</span> nx = nows.x, ny = nows.y, nz = nows.z, ncnt = nows.cnt;</span><br><span class="line">		<span class="keyword">if</span> (a[nx][ny][nz] == <span class="string">&#x27;E&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;Escaped in &quot;</span> &lt;&lt; ncnt &lt;&lt; <span class="string">&quot; minute(s).&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++ i)</span><br><span class="line">		&#123;</span><br><span class="line">			node T;</span><br><span class="line">			T.x = nx + dir[i][<span class="number">0</span>], T.y = ny + dir[i][<span class="number">1</span>], T.z = nz + dir[i][<span class="number">2</span>];</span><br><span class="line">			T.cnt = ncnt + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (T.x &gt; L || T.y &gt; R || T.z &gt; C || T.x &lt; <span class="number">1</span> || T.y &lt; <span class="number">1</span> || T.z &lt; <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span> (a[T.x][T.y][T.z] != <span class="string">&#x27;#&#x27;</span> &amp;&amp; ! vis[T.x][T.y][T.z])</span><br><span class="line">			&#123;</span><br><span class="line">				vis[T.x][T.y][T.z] = <span class="number">1</span>;</span><br><span class="line">				Q.<span class="built_in">push</span>(T);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;Trapped!&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">scanf</span> (<span class="string">&quot;%d%d%d&quot;</span>, &amp;L, &amp;R, &amp;C))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (L == <span class="number">0</span> &amp;&amp; R == <span class="number">0</span> &amp;&amp; C == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> k, i, j;</span><br><span class="line">		<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">		<span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= L; ++ k)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= R; ++ i)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= C; ++ j)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">//scanf (&quot;%c&quot;, &amp;a[k][i][j]);</span></span><br><span class="line">					cin &gt;&gt; a[k][i][j];</span><br><span class="line">					<span class="keyword">if</span> (a[k][i][j] == <span class="string">&#x27;S&#x27;</span>) sx = k, sy = i, sz = j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; sx &lt;&lt; &#x27; &#x27; &lt;&lt; sy &lt;&lt; &#x27; &#x27; &lt;&lt; sz &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">		<span class="built_in">bfs</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3 4 5</span></span><br><span class="line"><span class="comment">S....</span></span><br><span class="line"><span class="comment">.###.</span></span><br><span class="line"><span class="comment">.##..</span></span><br><span class="line"><span class="comment">###.#</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#####</span></span><br><span class="line"><span class="comment">#####</span></span><br><span class="line"><span class="comment">##.##</span></span><br><span class="line"><span class="comment">##...</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#####</span></span><br><span class="line"><span class="comment">#####</span></span><br><span class="line"><span class="comment">#.###</span></span><br><span class="line"><span class="comment">####E</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1 3 3</span></span><br><span class="line"><span class="comment">S##</span></span><br><span class="line"><span class="comment">#E#</span></span><br><span class="line"><span class="comment">###</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">0 0 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>搜索小练</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>排队</title>
    <url>/2020/09/20/%E6%8E%92%E9%98%9F/</url>
    <content><![CDATA[<p>他们写的都好复杂 <span id="more"></span> 什么谁隔开谁的。。。</p>
<p>麻烦！</p>
<p>老师不相邻=不考虑老师相邻-老师相邻</p>
<ul>
<li>不考虑老师相邻</li>
</ul>
<p>显然老师与男同学等价，用插空法解决 <span
class="math display">\[A_{n+2}^{n+2}\times A_{m}^{m}\times
C_{n+3}^{m}\]</span></p>
<p>其中C中的<span class="math inline">\(n+3\)</span>是因为有<span
class="math inline">\(n+2\)</span>个人，故有<span
class="math inline">\(n+3\)</span>个空</p>
<ul>
<li>老师相邻</li>
</ul>
<p>用捆绑法，两名老师<strong>整体</strong>与男同学等价，同样用插空法答案显然为
<span class="math display">\[A_2^2\times A_{n+1}^{n+1}\times A_m^m\times
C_{n+2}^m\]</span></p>
<p>二者做差就是答案</p>
<p>End...</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>组合数</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索小练#1</title>
    <url>/2020/06/20/%E6%90%9C%E7%B4%A2%E5%B0%8F%E7%BB%83-1/</url>
    <content><![CDATA[<span id="more"></span>
<p><a href="https://vjudge.net/contest/65959#problem/A">题目</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 214474444</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k, tot, stp;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>][<span class="number">10</span>], vis[<span class="number">10</span>];</span><br><span class="line"><span class="type">char</span> s[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span> <span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (stp == k) &#123;</span><br><span class="line">        ++ tot;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; n) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (!vis[i] &amp;&amp; a[x][i] == <span class="number">1</span>) &#123;</span><br><span class="line">            vis[i] = <span class="number">1</span>, ++ stp;</span><br><span class="line">            <span class="built_in">dfs</span> (x+<span class="number">1</span>);</span><br><span class="line">            vis[i] = <span class="number">0</span>, -- stp;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">dfs</span> (x+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span> &amp;&amp; k == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        tot = stp = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span> (vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">        <span class="built_in">memset</span> (a, <span class="number">0</span>, <span class="keyword">sizeof</span> a);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span> (<span class="string">&quot;%s&quot;</span>, s+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j) s[j] == <span class="string">&#x27;#&#x27;</span> ? a[i][j] = <span class="number">1</span> : a[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span> (<span class="number">1</span>);</span><br><span class="line">        cout &lt;&lt; tot &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2 1</span></span><br><span class="line"><span class="comment">#.</span></span><br><span class="line"><span class="comment">.#</span></span><br><span class="line"><span class="comment">4 4</span></span><br><span class="line"><span class="comment">...#</span></span><br><span class="line"><span class="comment">..#.</span></span><br><span class="line"><span class="comment">.#..</span></span><br><span class="line"><span class="comment">#...</span></span><br><span class="line"><span class="comment">-1 -1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="ps">PS:</h4>
<p>1.<span class="math inline">\(dfs\)</span>参数只可以有一个</p>
<p>2.<span
class="math inline">\(vis\)</span>记录<strong>每一列</strong>是否有棋子放置</p>
<p>时隔两年，重新做了一下，题目不算难，但是有一个小细节没注意到，就是搜索的时候，不允许在之前找过的行中重新找</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k, tot;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>][<span class="number">10</span>], vis[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="type">char</span> c[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; ++ j) <span class="keyword">if</span> (a[x][j] == <span class="number">1</span> &amp;&amp; vis[x][j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="keyword">if</span> (a[i][y] == <span class="number">1</span> &amp;&amp; vis[i][y]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> t, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &gt; k)</span><br><span class="line">	&#123;</span><br><span class="line">		++ tot;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; &quot;循环边界tot--&gt;&quot; &lt;&lt; tot &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line">	<span class="keyword">for</span> (i = t; i &lt;= n; ++ i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (a[i][j] == <span class="number">1</span> &amp;&amp; ! vis[i][j] &amp;&amp; <span class="built_in">pd</span>(i, j))</span><br><span class="line">			&#123;</span><br><span class="line">				vis[i][j] = <span class="number">1</span>;</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				cout &lt;&lt; &quot;put this i--&gt; &quot; &lt;&lt; i &lt;&lt; &#x27; &#x27; &lt;&lt; &quot;j --&gt;&quot; &lt;&lt; j &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="comment">				cout &lt;&lt; &quot;now_tot--&gt;&quot; &lt;&lt; tot &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="comment">				cout &lt;&lt; &quot;接下来dfs---&gt;&quot; &lt;&lt; x + 1 &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="comment">				*/</span></span><br><span class="line">				<span class="built_in">dfs</span>(i + <span class="number">1</span>, x + <span class="number">1</span>);</span><br><span class="line">				vis[i][j] = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> i, j; <span class="built_in">scanf</span> (<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">-1</span> &amp;&amp; k == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span> a), tot = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span> (<span class="string">&quot;%s&quot;</span>, c + <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; ++ j) a[i][j] = c[j] == <span class="string">&#x27;#&#x27;</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">		cout &lt;&lt; tot &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2 1</span></span><br><span class="line"><span class="comment">#.</span></span><br><span class="line"><span class="comment">.#</span></span><br><span class="line"><span class="comment">4 4</span></span><br><span class="line"><span class="comment">...#</span></span><br><span class="line"><span class="comment">..#.</span></span><br><span class="line"><span class="comment">.#..</span></span><br><span class="line"><span class="comment">#...</span></span><br><span class="line"><span class="comment">-1 -1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>搜索小练</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>披风</title>
    <url>/2020/10/17/%E6%8A%AB%E9%A3%8E/</url>
    <content><![CDATA[<p>题目大意：给定一张有向图，每个点有点权。试找到一条路径，使得该路径上的点权最大值减去点权最小值最大，问这个差最大是多少。<span id="more"></span></p>
<p>暴力分数给的很足，但是我没有去打，我想的<strong>真解</strong>，结果正解还没有搞出来，真jb傻逼</p>
<p>正解是：tarjan缩点，然后跑两边拓扑dp，一次最小值，一次最大值，然后就没了</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pr;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">66</span>, M = <span class="number">5e5</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">s</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">w</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) w = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) s = s * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s * w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (! x) <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">num</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="type">char</span> c[<span class="number">66</span>];</span><br><span class="line">    <span class="keyword">while</span> (x) c[++ num] = x % <span class="number">10</span> + <span class="number">48</span>, x /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (num) <span class="built_in">putchar</span>(c[num --]);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">map&lt;pr, <span class="type">bool</span>&gt;existed;</span><br><span class="line"><span class="type">int</span> ver[M], nex[M], head[N], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++ cnt] = y;</span><br><span class="line">    nex[cnt] = head[x];</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(head[x] = cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, top, tot, num, res;</span><br><span class="line"><span class="type">int</span> minv[N], maxv[N];</span><br><span class="line"><span class="type">int</span> dfn[N], low[N], sta[N], in[N], tar[N], v[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x] = low[x] = ++ tot, in[x] = <span class="number">1</span>, sta[++ top] = x;</span><br><span class="line">    <span class="type">int</span> i, y;</span><br><span class="line">    <span class="keyword">for</span> (i = head[x]; i; i = nex[i])</span><br><span class="line">    &#123;</span><br><span class="line">        y = ver[i];</span><br><span class="line">        <span class="keyword">if</span> (! dfn[y])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(y);</span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (in[y]) low[x] = <span class="built_in">min</span>(low[x], dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (low[x] == dfn[x])</span><br><span class="line">    &#123;</span><br><span class="line">        ++ num;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            y = sta[top --], in[y] = <span class="number">0</span>;</span><br><span class="line">            tar[y] = num;</span><br><span class="line">            minv[num] = <span class="built_in">min</span>(minv[num], v[y]);</span><br><span class="line">            maxv[num] = <span class="built_in">max</span>(maxv[num], v[y]);</span><br><span class="line">        &#125; <span class="keyword">while</span>(x != y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> vers[M], nexs[M], heads[N], cnts, deg[N], deg1[N], maxv1[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vers[++ cnts] = y;</span><br><span class="line">    nexs[cnts] = heads[x];</span><br><span class="line">    ++ deg[y];</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(heads[x] = cnts);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fuck1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= num; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (! deg[i]) q.<span class="built_in">push</span>(i);</span><br><span class="line">        maxv1[i] = maxv[i], deg1[i] = deg[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (! q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = heads[x]; i; i = nexs[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> y = vers[i];</span><br><span class="line">            maxv[y] = <span class="built_in">max</span>(maxv[y], maxv[x]);</span><br><span class="line">            <span class="keyword">if</span> (! --deg1[y]) q.<span class="built_in">push</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">max</span>(res, maxv[x] - minv[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fuck2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= num; ++ i) <span class="keyword">if</span> (! deg[i]) q.<span class="built_in">push</span>(i);</span><br><span class="line">    <span class="keyword">while</span> (! q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = heads[x]; i; i = nexs[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> y = vers[i];</span><br><span class="line">            minv[y] = <span class="built_in">min</span>(minv[y], minv[x]);</span><br><span class="line">            <span class="keyword">if</span> (! --deg[y]) q.<span class="built_in">push</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">max</span>(res, maxv1[x] - minv[x]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, x, y; n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">memset</span>(minv, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> minv), <span class="built_in">memset</span>(maxv, <span class="number">0xcf</span>, <span class="keyword">sizeof</span> maxv);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) v[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span> (existed[<span class="built_in">pr</span>(x, y)]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">add_edge</span>(x, y);</span><br><span class="line">        existed[<span class="built_in">pr</span>(x, y)] = <span class="number">1</span>;	</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="keyword">if</span> (! dfn[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (x = <span class="number">1</span>; x &lt;= n; ++ x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = head[x]; i; i = nex[i])</span><br><span class="line">        &#123;</span><br><span class="line">            y = ver[i];</span><br><span class="line">            <span class="keyword">if</span> (tar[x] == tar[y]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">add</span>(tar[x], tar[y]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;	</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fuck1</span>(), <span class="built_in">fuck2</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">put</span>(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：这次考试期望得分：100+60+0+60pts，实际得分：80+40+0+0，这跟期望得分差距也太大了吧，自己老是在后边，有种快起不来的感觉</p>
<p>第一题我傻逼没开ll</p>
<p>第二题思路错了，数据太水还给了40pts</p>
<p>第三题没时间看，</p>
<p>第四题题目审错了</p>
<p>我发誓以后无论什么题目，必须先打暴力</p>
<p>其实这次考试暴力分数给的非常足：100+60+60+60=280pts</p>
<p>第三题就tm是个搜索啊，第二题就tm是个傻逼拓扑啊，第一题就tm是个小学一年级都会的题吧</p>
<p>我感觉自己100+100+100+60没问题啊</p>
<p>是真tm操蛋</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索小练#4</title>
    <url>/2020/06/24/%E6%90%9C%E7%B4%A2%E5%B0%8F%E7%BB%83-4/</url>
    <content><![CDATA[<span id="more"></span>
<p><a href="https://vjudge.net/contest/65959#problem/D">题目</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">66</span>, INF = <span class="number">2147483647</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, res = INF;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="type">int</span> a[N][N], b[N][N], c[N][N], d[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">work</span> <span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    c[x][y] = <span class="number">1</span>-c[x][y];</span><br><span class="line">    c[x+<span class="number">1</span>][y] = <span class="number">1</span>-c[x+<span class="number">1</span>][y];</span><br><span class="line">    c[x<span class="number">-1</span>][y] = <span class="number">1</span>-c[x<span class="number">-1</span>][y];</span><br><span class="line">    c[x][y+<span class="number">1</span>] = <span class="number">1</span>-c[x][y+<span class="number">1</span>];</span><br><span class="line">    c[x][y<span class="number">-1</span>] = <span class="number">1</span>-c[x][y<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span> (b, <span class="number">0</span>, <span class="keyword">sizeof</span> b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line">            c[i][j] = a[i][j];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (f[i]) </span><br><span class="line">            <span class="built_in">work</span> (<span class="number">1</span>, i), b[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (c[i<span class="number">-1</span>][j])</span><br><span class="line">                <span class="built_in">work</span> (i, j), b[i][j] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (c[n][i])</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">nows</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (b[i][j])</span><br><span class="line">                ++ nows;</span><br><span class="line">    <span class="keyword">if</span> (nows &lt; res)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line">                d[i][j] = b[i][j];</span><br><span class="line">        res = nows;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span> <span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == m+<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">check</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f[x] = <span class="number">0</span>, <span class="built_in">dfs</span>(x+<span class="number">1</span>);</span><br><span class="line">    f[x] = <span class="number">1</span>, <span class="built_in">dfs</span>(x+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line">            <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line">    <span class="built_in">dfs</span> (<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (res == INF) <span class="built_in">puts</span> (<span class="string">&quot;IMPOSSIBLE&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line">                cout &lt;&lt; d[i][j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ps">ps:</h4>
<p>今天比较心累 就不想用英文了</p>
<p>因为拼单词还得动脑子</p>
<p>这个题先捋一遍思想吧:</p>
<p>我们枚举第一行的状态，通过第一行来决定以下的一些行数。</p>
<p>thus更新答案</p>
<p>但是这题特别tmd狗</p>
<p><strong>"如果最小解有多个，则输出在字典序意义下最小的那个"</strong></p>
<p>真恶心</p>
<p>先埋下一个坑</p>
<p>因为我还没有搞透彻</p>
<p>"先搜0，再搜1能保证字典序最优"</p>
<p>"check函数是s&lt;ans而不是s&lt;=ans"</p>
<p>"因为先搜到的答案一定字典序比后搜到的字符串优"</p>
<p>"#define 字符串 方案"</p>
<p>"
那么后搜到的方案如何干掉先搜到的方案呢——唯有移动步数比先搜到的少"</p>
<p><span class="math inline">\(7.14update\)</span>:</p>
<p>Q:为什么从零开始搜，要比从1开始搜 更正确？</p>
<p>A:因为字典序是 0 &lt; 1 并且是 '01111' &lt; '10000'还要比较最高位</p>
<p>所以我们从零开始搜的话，我们只可能是如下的搜索过程:‘00001’--&gt;'00011'
--&gt; '00111' --&gt; '.....'默认保证了字典序是从小往大搜的</p>
<p>而后面的方案数 如果想干掉之前的ans就必须满足
移动的步数比ans小（即为总的1的个数没有当前ans的1的个数多）</p>
<p><strong>我们不需要再考虑字典序的问题，因为我们先从0开始搜，默认保证了我们字典序几就是从小到大这样排列的</strong></p>
]]></content>
      <categories>
        <category>搜索小练</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索小练#7</title>
    <url>/2020/06/27/%E6%90%9C%E7%B4%A2%E5%B0%8F%E7%BB%83-7/</url>
    <content><![CDATA[<span id="more"></span>
<p><a href="https://vjudge.net/contest/65959#problem/G">题目</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span>+<span class="number">66</span>, INF = <span class="number">250</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> T, res, len;</span><br><span class="line"><span class="type">int</span> a, b, i, dy;</span><br><span class="line"><span class="type">char</span> p[N], t[N], s[N], f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T --&gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ++ i; res = a = b = <span class="number">0</span>;</span><br><span class="line">        cin &gt;&gt; len;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%s%s&quot;</span>, p+<span class="number">1</span>, t+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%s&quot;</span>, s+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            dy = a = b = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (res == INF) &#123;res = <span class="number">-1</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= (len&lt;&lt;<span class="number">1</span>); ++ i) </span><br><span class="line">                f[i] = (i&amp;<span class="number">1</span> == <span class="number">1</span>) ? t[++a] : p[++b];</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;--&gt;&quot;;</span></span><br><span class="line">            <span class="comment">// for (int i = 1; i &lt;= (len&lt;&lt;1); ++ i)</span></span><br><span class="line">                <span class="comment">// cout&lt;&lt;f[i];</span></span><br><span class="line">            <span class="comment">// cout &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">            ++ res;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= (len&lt;&lt;<span class="number">1</span>); ++ i)</span><br><span class="line">                <span class="keyword">if</span> (f[i] == s[i])</span><br><span class="line">                    ++ dy;</span><br><span class="line">            <span class="keyword">if</span> (dy == (len&lt;&lt;<span class="number">1</span>)) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; ++ i)</span><br><span class="line">                p[i] = f[i], t[i] = f[len+i];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>感觉做这个题真tm拉低我智商</p>
<p>这么水的数据</p>
<p>INF等于250 随便跑一跑就能水过“-1”</p>
<p>搜索个屁啊</p>
<p>就是个破模拟</p>
<p>不需要动一点脑子</p>
<p>花了我一个小时.....</p>
<p>草</p>
<p>垃圾题</p>
]]></content>
      <categories>
        <category>搜索小练</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索小练#6</title>
    <url>/2020/06/26/%E6%90%9C%E7%B4%A2%E5%B0%8F%E7%BB%83-6/</url>
    <content><![CDATA[<span id="more"></span>
<p><a href="https://vjudge.net/contest/65959#problem/F">题目</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Prime Path </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">21474836</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t, res, cnt;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dp[N], v[N], prime[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">work</span> <span class="params">(<span class="type">int</span> num, <span class="type">int</span> t, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="number">0</span>) <span class="keyword">return</span> num/<span class="number">10</span>*<span class="number">10</span>+c;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="number">1</span>) <span class="keyword">return</span> num/<span class="number">100</span>*<span class="number">100</span>+c*<span class="number">10</span>+num%<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="number">2</span>) <span class="keyword">return</span> num/<span class="number">1000</span>*<span class="number">1000</span>+c*<span class="number">100</span>+num%<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> c*<span class="number">1000</span>+num%<span class="number">1000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span> (v, <span class="number">1</span>, <span class="keyword">sizeof</span> v);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= N; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v[i]) prime[++cnt] = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j&lt;=cnt &amp;&amp; i*prime[j]&lt;=N; ++ j) </span><br><span class="line">                v[i*prime[j]] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t --&gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">if</span> (a == b) &#123;<span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);<span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="built_in">memset</span> (dp, INF, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        dp[a] = <span class="number">0</span>;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">        q.<span class="built_in">push</span>(a);</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> cur = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++ i)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; ++ j) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">3</span> &amp;&amp; j == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="type">int</span> nxt = <span class="built_in">work</span> (cur, i, j);</span><br><span class="line">                    <span class="keyword">if</span> (!v[nxt] || dp[nxt] &lt;= dp[cur]) <span class="keyword">continue</span>;</span><br><span class="line">                    dp[nxt] = dp[cur]+<span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(nxt);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; dp[b] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ps">PS:</h4>
<p>1.easy <span class="math inline">\(bfs\)</span></p>
<p>2.but is not very easy to find a thought</p>
<p>3.I felt that I have thought vaguely but I can'nt make it.</p>
<p><strong>I will still work hard!</strong></p>
<p>两年后，再一次做这道题，思路清晰但是代码能力下降好多，debug了好长时间</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * By Youngore</span></span><br><span class="line"><span class="comment"> * Time: 22.10.15</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 10000</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span> + <span class="number">66</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> T, cnt, a[<span class="number">66</span>];</span><br><span class="line"><span class="type">int</span> vis[N], pri[N], v[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pre</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">1</span>, <span class="keyword">sizeof</span> vis); vis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= inf; ++ i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (vis[i]) pri[++ cnt] = i;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * pri[j] &lt;= inf; ++ j)</span><br><span class="line">		&#123;</span><br><span class="line">			vis[i * pri[j]] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (! (i % pri[j])) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">youngore</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;T); <span class="built_in">pre</span>();</span><br><span class="line">	<span class="keyword">while</span> (T --&gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x, y, i, j;</span><br><span class="line">		<span class="built_in">scanf</span> (<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">		<span class="built_in">memset</span>(v, <span class="number">0</span>, <span class="keyword">sizeof</span> v);</span><br><span class="line">		queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt;q; q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(x,<span class="number">0</span>));</span><br><span class="line">		v[x] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (! q.<span class="built_in">empty</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; nows = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">if</span> (nows.first == y)</span><br><span class="line">			&#123;</span><br><span class="line">				cout &lt;&lt; nows.second &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">int</span> k = nows.first, cnt = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span> (k)</span><br><span class="line">			&#123;</span><br><span class="line">				a[++ cnt] = k % <span class="number">10</span>;</span><br><span class="line">				k /= <span class="number">10</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (k = cnt; k &gt;= <span class="number">1</span>; -- k)<span class="comment">//枚举每一位</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span> (i = ((k == cnt) ? <span class="number">1</span> : <span class="number">0</span>); i &lt;= <span class="number">9</span>; ++ i)<span class="comment">//枚举该位可以替换成那些数字</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (i == a[k]) <span class="comment">//如果碰到了原位上的数字</span></span><br><span class="line">						<span class="keyword">continue</span>;</span><br><span class="line">					<span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">					<span class="keyword">for</span> (j = cnt; j &gt;= <span class="number">1</span>; -- j)<span class="comment">//把每一位加和</span></span><br><span class="line">						res = res * <span class="number">10</span> + ((j == k) ? i : a[j]);</span><br><span class="line">					<span class="keyword">if</span> (vis[res] &amp;&amp; !v[res]) q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(res, nows.second + <span class="number">1</span>)), v[res] = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> search_ex = <span class="built_in">youngore</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">1033 8179</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>搜索小练</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索小练#5</title>
    <url>/2020/06/25/%E6%90%9C%E7%B4%A2%E5%B0%8F%E7%BB%83-5/</url>
    <content><![CDATA[<span id="more"></span>
<p><a href="https://vjudge.net/problem/POJ-1426">题目</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long int </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span> <span class="params">(ull ans, <span class="type">int</span> n, <span class="type">int</span> weishu)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (weishu == <span class="number">20</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (ans%n == <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span> (ans*<span class="number">10</span>, n, weishu+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs</span> (ans*<span class="number">10</span>+<span class="number">1</span>, n, weishu+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;n)&amp;&amp; n != <span class="number">0</span>) &#123;</span><br><span class="line">        k = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span> (<span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>this is a easy topic</p>
<p>but I can not make it unless I can read the answer</p>
<p>To tell the truth, I was very terrible</p>
<p>Although the topic is easy but I don't know how to solve it</p>
<p>I will also try my best to welcome the NOIP2020.</p>
<h4 id="ps">PS:</h4>
<p>1.we need the 'weishu == 20'</p>
<p>because the ull can held '19' so we much let the ull can search
all</p>
<p>两年后再写</p>
<p>尝试用bfs写了一下，mle了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * By Youngore</span></span><br><span class="line"><span class="comment"> * Time: 22.10.15</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">youngore</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;n))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		queue&lt;pair&lt;ull, <span class="type">int</span>&gt; &gt;q; q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">		<span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			pair&lt;ull, <span class="type">int</span>&gt; nows = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">			<span class="keyword">if</span> (nows.second == <span class="number">20</span>) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span> (! (nows.first % n)) </span><br><span class="line">			&#123;</span><br><span class="line">				cout &lt;&lt; nows.first &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(nows.first * <span class="number">10</span>, nows.second + <span class="number">1</span>));</span><br><span class="line">			q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(nows.first * <span class="number">10</span> + <span class="number">1</span>, nows.second + <span class="number">1</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> search_ex = <span class="built_in">youngore</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">19</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>搜索小练</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索小练#8</title>
    <url>/2020/06/28/%E6%90%9C%E7%B4%A2%E5%B0%8F%E7%BB%83-8/</url>
    <content><![CDATA[<span id="more"></span>
<p><a
href="https://vjudge.net/problem/POJ-3414#author=cxsys_">题目</a></p>
<p>这里很容易想到广搜，设初始状态为<span
class="math inline">\((i,j)\)</span>，一共就只有六种变化</p>
<p>A杯倒满，B杯倒满，A杯倒出完，B杯倒出完，A到给B，B到给A</p>
<p>任意一种状态<span class="math inline">\(i\)</span> 或者 <span
class="math inline">\(j\)</span>达到 <span
class="math inline">\(C\)</span>
就停止，注意要打印路径，我这里用一个string存的操作顺序。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e2</span>+<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a, b, c;</span><br><span class="line"><span class="type">int</span> v[N][N];</span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">string str[<span class="number">10</span>] = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;FILL(1)&quot;</span>, <span class="string">&quot;FILL(2)&quot;</span>, <span class="string">&quot;DROP(1)&quot;</span>, <span class="string">&quot;DROP(2)&quot;</span>, <span class="string">&quot;POUR(1,2)&quot;</span>,<span class="string">&quot;POUR(2,1)&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y, step; string s;</span><br><span class="line">    <span class="built_in">node</span> (<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> step, string s):<span class="built_in">x</span>(x), <span class="built_in">y</span>(y), <span class="built_in">step</span>(step),<span class="built_in">s</span>(s)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">bfs</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    queue&lt;node&gt;q;</span><br><span class="line">    v[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">node</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;0&quot;</span>));</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        node tmp = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (tmp.x == c || tmp.y == c) &#123;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            cout &lt;&lt; tmp.step &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; tmp.s.<span class="built_in">length</span>(); ++ i)</span><br><span class="line">                cout &lt;&lt; str[tmp.s[i]-<span class="string">&#x27;0&#x27;</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tmp.x &lt; a)</span><br><span class="line">            <span class="keyword">if</span> (!v[a][tmp.y])</span><br><span class="line">                v[a][tmp.y] = <span class="number">1</span>, q.<span class="built_in">push</span>(<span class="built_in">node</span>(a, tmp.y, tmp.step+<span class="number">1</span>, tmp.s+<span class="string">&quot;1&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span> (tmp.y &lt; b)</span><br><span class="line">            <span class="keyword">if</span> (!v[tmp.x][b])</span><br><span class="line">                v[tmp.x][b] = <span class="number">1</span>, q.<span class="built_in">push</span>(<span class="built_in">node</span>(tmp.x, b, tmp.step+<span class="number">1</span>, tmp.s+<span class="string">&quot;2&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span> (tmp.x != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> (!v[<span class="number">0</span>][tmp.y])</span><br><span class="line">                v[<span class="number">0</span>][tmp.y] = <span class="number">1</span>, q.<span class="built_in">push</span>(<span class="built_in">node</span>(<span class="number">0</span>, tmp.y, tmp.step+<span class="number">1</span>, tmp.s+<span class="string">&quot;3&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span> (tmp.y != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> (!v[tmp.x][<span class="number">0</span>])</span><br><span class="line">                v[tmp.x][<span class="number">0</span>] = <span class="number">1</span>, q.<span class="built_in">push</span>(<span class="built_in">node</span>(tmp.x, <span class="number">0</span>, tmp.step+<span class="number">1</span>, tmp.s+<span class="string">&quot;4&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span> (tmp.x != <span class="number">0</span> &amp;&amp; tmp.y &lt; b) &#123;</span><br><span class="line">            <span class="type">int</span> nx, ny;</span><br><span class="line">            <span class="keyword">if</span> (tmp.x &lt;= b-tmp.y) nx = <span class="number">0</span>, ny = tmp.x+tmp.y;</span><br><span class="line">            <span class="keyword">else</span> nx = tmp.x+tmp.y-b, ny = b;</span><br><span class="line">            <span class="keyword">if</span> (!v[nx][ny]) </span><br><span class="line">                v[nx][ny] = <span class="number">1</span>, q.<span class="built_in">push</span>(<span class="built_in">node</span>(nx, ny, tmp.step+<span class="number">1</span>, tmp.s+<span class="string">&quot;5&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tmp.y != <span class="number">0</span> &amp;&amp; tmp.x &lt; a) &#123;</span><br><span class="line">            <span class="type">int</span> nx, ny;</span><br><span class="line">            <span class="keyword">if</span> (tmp.y &lt;= a-tmp.x) nx = tmp.x+tmp.y, ny = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> nx = a, ny = tmp.x+tmp.y-a;</span><br><span class="line">            <span class="keyword">if</span> (!v[nx][ny]) </span><br><span class="line">                v[nx][ny] = <span class="number">1</span>, q.<span class="built_in">push</span>(<span class="built_in">node</span>(nx, ny, tmp.step+<span class="number">1</span>, tmp.s+<span class="string">&quot;6&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    <span class="built_in">bfs</span> ();</span><br><span class="line">     <span class="keyword">if</span> (!flag) <span class="built_in">puts</span> (<span class="string">&quot;impossible&quot;</span>);	</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分为六种情况讨论</p>
<p>反正现在的我一眼看上去，不知道正解</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * By Youngore</span></span><br><span class="line"><span class="comment"> * Time:20.10.16</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a, b, c, flg;</span><br><span class="line"><span class="type">int</span> v[N][N];</span><br><span class="line">string str[<span class="number">10</span>] = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;FILL(1)&quot;</span>, <span class="string">&quot;FILL(2)&quot;</span>, <span class="string">&quot;DROP(1)&quot;</span>, <span class="string">&quot;DROP(2)&quot;</span>, <span class="string">&quot;POUR(1,2)&quot;</span>, <span class="string">&quot;POUR(2,1)&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yhy</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x, y, stp;</span><br><span class="line">	string s;</span><br><span class="line">	<span class="built_in">yhy</span>(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> stp, string s):<span class="built_in">x</span>(x), <span class="built_in">y</span>(y), <span class="built_in">stp</span>(stp), <span class="built_in">s</span>(s)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	queue&lt;yhy&gt;q; v[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	q.<span class="built_in">push</span>(<span class="built_in">yhy</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;0&quot;</span>));</span><br><span class="line">	<span class="keyword">while</span> (! q.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		yhy tmp = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span> (tmp.x == c || tmp.y == c)</span><br><span class="line">		&#123;</span><br><span class="line">			flg = <span class="number">1</span>;</span><br><span class="line">			cout &lt;&lt; tmp.stp &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= tmp.stp; ++ i) cout &lt;&lt; str[tmp.s[i] - <span class="string">&#x27;0&#x27;</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (tmp.x != a &amp;&amp; ! v[a][tmp.y])</span><br><span class="line">		&#123;</span><br><span class="line">			v[a][tmp.y] = <span class="number">1</span>;</span><br><span class="line">			q.<span class="built_in">push</span>(<span class="built_in">yhy</span>(a, tmp.y, tmp.stp + <span class="number">1</span>, tmp.s + <span class="string">&quot;1&quot;</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (tmp.y != b &amp;&amp; ! v[tmp.x][b])</span><br><span class="line">		&#123;</span><br><span class="line">			v[tmp.x][b] = <span class="number">1</span>;</span><br><span class="line">			q.<span class="built_in">push</span>(<span class="built_in">yhy</span>(tmp.x, b, tmp.stp + <span class="number">1</span>, tmp.s + <span class="string">&quot;2&quot;</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (tmp.x &amp;&amp; ! v[<span class="number">0</span>][tmp.y])</span><br><span class="line">		&#123;</span><br><span class="line">			v[<span class="number">0</span>][tmp.y] = <span class="number">1</span>;</span><br><span class="line">			q.<span class="built_in">push</span>(<span class="built_in">yhy</span>(<span class="number">0</span>, tmp.y, tmp.stp + <span class="number">1</span>, tmp.s + <span class="string">&quot;3&quot;</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (tmp.y &amp;&amp; !v[tmp.x][<span class="number">0</span>])</span><br><span class="line">		&#123;</span><br><span class="line">			v[tmp.x][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">			q.<span class="built_in">push</span>(<span class="built_in">yhy</span>(tmp.x, <span class="number">0</span>, tmp.stp + <span class="number">1</span>, tmp.s + <span class="string">&quot;4&quot;</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (tmp.x &amp;&amp; tmp.y != b)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> nx, ny;</span><br><span class="line">			<span class="keyword">if</span> (tmp.y + tmp.x &lt;= b) nx = <span class="number">0</span>, ny = tmp.x + tmp.y;</span><br><span class="line">			<span class="keyword">else</span> nx = tmp.x + tmp.y - b, ny = b;</span><br><span class="line">			<span class="keyword">if</span> (! v[nx][ny]) q.<span class="built_in">push</span>(<span class="built_in">yhy</span>(nx, ny, tmp.stp + <span class="number">1</span>, tmp.s + <span class="string">&quot;5&quot;</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (tmp.y &amp;&amp; tmp.x != a)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> nx, ny;</span><br><span class="line">			<span class="keyword">if</span> (tmp.x + tmp.y &lt;= a) nx = tmp.x + tmp.y, ny = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span> nx = a, ny = tmp.x + tmp.y - a;</span><br><span class="line">			<span class="keyword">if</span> (! v[nx][ny]) q.<span class="built_in">push</span>(<span class="built_in">yhy</span>(nx, ny, tmp.stp + <span class="number">1</span>, tmp.s + <span class="string">&quot;6&quot;</span>));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (! flg) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">youngore</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">	<span class="built_in">bfs</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> search_ex = <span class="built_in">youngore</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>搜索小练</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>摸鱼带师</title>
    <url>/2020/11/22/%E6%91%B8%E9%B1%BC%E5%B8%A6%E5%B8%88/</url>
    <content><![CDATA[<p>题目大意:给你一个二维平面,然后有一些点随机落在上面,给定一些贴在x轴上的点,给定一个距离l为一个点若能看到周围点的话必须在l内(曼哈顿距离),问每个点可以看到多少个点<span id="more"></span></p>
<p>考场思路几近正解但是由于状态心态身体等各种原因,没能复现</p>
<p>现重新屡一下思路:</p>
<p>求解每个x轴上的选定点可以看到多少点,可以转化思维,考虑每一个平面上的一个点对x轴上的点的贡献,然后对下标<strong>差分</strong>答案就行了</p>
<p>代码如下: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, l;</span><br><span class="line"><span class="type">int</span> x[N], y[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yhzhyhm</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, id, res;</span><br><span class="line"><span class="comment">//constructor</span></span><br><span class="line">    <span class="built_in">yhzhyhm</span> (<span class="type">int</span> A = <span class="number">0</span>) : <span class="built_in">a</span>(A) &#123;&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> yhzhyhm &amp;yhm) <span class="type">const</span> &#123;<span class="keyword">return</span> a &lt; yhm.a;&#125;</span><br><span class="line">&#125;yh[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">cmp</span><span class="params">(yhzhyhm X, yhzhyhm Y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> X.id &lt; Y.id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i; n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>(), l = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) x[i] = <span class="built_in">read</span>(), y[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++ i) yh[i].a = <span class="built_in">read</span>(), yh[i].id = i;</span><br><span class="line">    <span class="built_in">sort</span>(yh + <span class="number">1</span>, yh + <span class="number">1</span> + m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (y[i] &gt; l) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> lx = x[i] - (l - y[i]), rx = x[i] + (l - y[i]);</span><br><span class="line">        <span class="type">int</span> lp = <span class="built_in">lower_bound</span>(yh + <span class="number">1</span>, yh + <span class="number">1</span> + m, <span class="built_in">yhzhyhm</span>(lx)) - yh,</span><br><span class="line">            rp = <span class="built_in">upper_bound</span>(yh + <span class="number">1</span>, yh + <span class="number">1</span> + m, <span class="built_in">yhzhyhm</span>(rx)) - yh;</span><br><span class="line">        ++ yh[lp].res, -- yh[rp].res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= m; ++ i) yh[i].res += yh[i - <span class="number">1</span>].res;</span><br><span class="line">    <span class="built_in">sort</span>(yh + <span class="number">1</span>, yh + <span class="number">1</span> + m, cmp);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++ i) <span class="built_in">put</span>(yh[i].res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维题</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索小练#9</title>
    <url>/2020/06/29/%E6%90%9C%E7%B4%A2%E5%B0%8F%E7%BB%83-9/</url>
    <content><![CDATA[<span id="more"></span>
<p><a href="https://vjudge.net/contest/65959#problem/I">题目</a></p>
<p>今天没写完</p>
<p>晚上倒是有一段时间</p>
<p>不过我去弄Atom了......</p>
<p>明天计划:</p>
<p>切掉这个题 把以前做过的搜索题复习一下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = 	<span class="number">66</span>, INF = <span class="number">214748364</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> T, n, m, res = INF;</span><br><span class="line"><span class="type">int</span> a[N][N], flag;</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dx[<span class="number">3</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> vs[N][N], vt[N][N];</span><br><span class="line"><span class="type">int</span> sdis[N][N], tdis[N][N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;<span class="type">int</span> x, y;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">bfs</span> <span class="params">(<span class="type">int</span> curx, <span class="type">int</span> cury, <span class="type">int</span> curs, <span class="type">int</span> curt)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// if (x == nx &amp;&amp; y == ny) calc();</span></span><br><span class="line">    queue&lt;node&gt;qs; queue&lt;node&gt;qt;</span><br><span class="line">  node l, r;</span><br><span class="line">    l.x = curx, l.y = cury, r.x = curs, r.y = curt;</span><br><span class="line">    qs.<span class="built_in">push</span>(l); qt.<span class="built_in">push</span>(r);</span><br><span class="line">    <span class="built_in">memset</span> (vs, <span class="number">0</span>, <span class="keyword">sizeof</span> vs), <span class="built_in">memset</span> (vt, <span class="number">0</span>, <span class="keyword">sizeof</span> vt);</span><br><span class="line">    <span class="built_in">memset</span> (sdis, <span class="number">0</span>, <span class="keyword">sizeof</span> sdis), <span class="built_in">memset</span> (tdis, <span class="number">0</span>, <span class="keyword">sizeof</span> tdis);</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (qs.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        node tmp = qs.<span class="built_in">front</span>(); qs.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++ i) &#123;</span><br><span class="line">            node nows;</span><br><span class="line">            nows.x = tmp.x+dx[i], nows.y = tmp.y+dy[i];</span><br><span class="line">            <span class="keyword">if</span> ((nows.x &gt; n)||(nows.x &lt; <span class="number">1</span>)||(nows.y &gt; m)||(nows.y &lt; <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!vs[nows.x][nows.y] &amp;&amp; a[nows.x][nows.y])&#123;</span><br><span class="line">                vs[nows.x][nows.y] = <span class="number">1</span>;</span><br><span class="line">                qs.<span class="built_in">push</span>(nows);</span><br><span class="line">                sdis[nows.x][nows.y] = sdis[tmp.x][tmp.y]+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (qt.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        node tmp = qt.<span class="built_in">front</span>(); qt.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++ i) &#123;</span><br><span class="line">            node nows;</span><br><span class="line">            nows.x = tmp.x+dx[i], nows.y = tmp.y+dy[i];</span><br><span class="line">            <span class="keyword">if</span> ((nows.x &gt; n)||(nows.x &lt; <span class="number">1</span>)||(nows.y &gt; m)||(nows.y &lt; <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!vt[nows.x][nows.y] &amp;&amp; a[nows.x][nows.y])&#123;</span><br><span class="line">                vt[nows.x][nows.y] = <span class="number">1</span>;</span><br><span class="line">                qt.<span class="built_in">push</span>(nows);</span><br><span class="line">                tdis[nows.x][nows.y] = tdis[tmp.x][tmp.y]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((!vs[i][j] || !vt[i][j]) &amp;&amp; a[i][j]) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T --&gt; <span class="number">0</span>) &#123;</span><br><span class="line">        flag = <span class="literal">false</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span> (<span class="string">&quot;%s&quot;</span>, s+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line">                a[i][j] = (s[j] == <span class="string">&#x27;#&#x27;</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line">                <span class="keyword">if</span> (a[i][j])</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> ni = <span class="number">1</span>; ni &lt;= n; ++ ni)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> nj = <span class="number">1</span>; nj &lt;= m; ++ nj)</span><br><span class="line">                <span class="keyword">if</span> (a[ni][nj])</span><br><span class="line">                    <span class="built_in">bfs</span> (i, j, ni, nj);</span><br><span class="line">        <span class="keyword">if</span> (flag) cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>搜索小练</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>放假回家</title>
    <url>/2020/10/28/%E6%94%BE%E5%81%87%E5%9B%9E%E5%AE%B6/</url>
    <content><![CDATA[<p>题目大意：给定一个 N 个数的数列 a[i]和数字 M，对于每一个 i，计算出在
1~i-1 中，最多能选多少个数字，使得这些数字的和不超过
M-a[i]。<span id="more"></span></p>
<p>正解是权值线段树巴拉巴拉的，但是用对顶堆就可以卡过去</p>
<p>大根堆存储我们要去装的，小根堆存储我们没装的</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> T, n, m, sum;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt; &gt;yh;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">yhm_clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (! q.<span class="built_in">empty</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">while</span> (! yh.<span class="built_in">empty</span>()) yh.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">yhm_func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) a[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (! yh.<span class="built_in">empty</span>() &amp;&amp; ! q.<span class="built_in">empty</span>() &amp;&amp; q.<span class="built_in">top</span>() &gt; yh.<span class="built_in">top</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            yh.<span class="built_in">push</span>(q.<span class="built_in">top</span>());</span><br><span class="line">            sum -= q.<span class="built_in">top</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (! yh.<span class="built_in">empty</span>() &amp;&amp; sum + yh.<span class="built_in">top</span>() &lt;= m - a[i])</span><br><span class="line">        &#123;</span><br><span class="line">            sum += yh.<span class="built_in">top</span>();</span><br><span class="line">            q.<span class="built_in">push</span>(yh.<span class="built_in">top</span>());</span><br><span class="line">            yh.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum &lt;= m - a[i])</span><br><span class="line">        &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(a[i]), sum += a[i];</span><br><span class="line">            <span class="keyword">while</span> (! yh.<span class="built_in">empty</span>() &amp;&amp; sum + yh.<span class="built_in">top</span>() &lt;= m)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += yh.<span class="built_in">top</span>();</span><br><span class="line">                q.<span class="built_in">push</span>(yh.<span class="built_in">top</span>());</span><br><span class="line">                yh.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (! q.<span class="built_in">empty</span>() &amp;&amp; sum &gt; m - a[i])</span><br><span class="line">            &#123;</span><br><span class="line">                sum -= q.<span class="built_in">top</span>();</span><br><span class="line">                yh.<span class="built_in">push</span>(q.<span class="built_in">top</span>());</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            q.<span class="built_in">push</span>(a[i]);</span><br><span class="line">            sum += a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">put</span>(yh.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (T --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">yhm_clear</span>();</span><br><span class="line">        <span class="built_in">yhm_func</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索小练#3</title>
    <url>/2020/06/23/%E6%90%9C%E7%B4%A2%E5%B0%8F%E7%BB%83-3/</url>
    <content><![CDATA[<span id="more"></span>
<p><a href="https://vjudge.net/contest/65959#problem/C">题目</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// catch that cow</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e7</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k, x;</span><br><span class="line"><span class="type">int</span> q[N], v[N], dis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; k) &#123;cout &lt;&lt; n-k; <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="type">int</span> s = <span class="number">0</span>, t = <span class="number">1</span>;</span><br><span class="line">    q[<span class="number">1</span>] = n, v[n] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (s &lt;= t) &#123;</span><br><span class="line">        ++ s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; ++ i) &#123;</span><br><span class="line">            <span class="type">int</span> x = q[s];</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>) ++ x; </span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">2</span>) -- x;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">3</span>) x&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt;= <span class="number">100000</span>) </span><br><span class="line">                <span class="keyword">if</span> (!v[x]) &#123;</span><br><span class="line">                    v[x] = <span class="number">1</span>;</span><br><span class="line">                    q[++ t] = x;</span><br><span class="line">                    dis[x] = dis[q[s]] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dis[k];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS:</p>
<p>1.before today I break for two days;</p>
<p>2.It is a very easy bfs.</p>
<p>The only season why I cann't solve this problem is I was very
sily</p>
<p>第二次做，考虑一下正确性</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">s.cnt = now.cnt + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">int</span> vis[<span class="number">100066</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yhy</span>&#123;<span class="type">int</span> w, cnt;&#125;;</span><br><span class="line">queue&lt;yhy&gt;q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">youngore</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span> (<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">	yhy now; now.w = n, now.cnt = <span class="number">0</span>;</span><br><span class="line">	q.<span class="built_in">push</span>(now);</span><br><span class="line">	<span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		now = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span> (now.w == k)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; now.cnt;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		yhy s;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; ++ i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">1</span>) s.w = now.w + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">2</span>) s.w = now.w - <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">3</span>) s.w = now.w * <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span> (s.w &lt; <span class="number">0</span> || s.w &gt; <span class="number">100000</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (! vis[s.w])</span><br><span class="line">			&#123;</span><br><span class="line">				vis[s.w] = <span class="number">1</span>;</span><br><span class="line">				s.cnt = now.cnt + <span class="number">1</span>;</span><br><span class="line">				q.<span class="built_in">push</span>(s);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//cout &lt;&lt; &quot;!!!----&gt; &quot; &lt;&lt; q.size() &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;<span class="built_in">youngore</span>();&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>搜索小练</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>放爆竹</title>
    <url>/2020/10/12/%E6%94%BE%E7%88%86%E7%AB%B9/</url>
    <content><![CDATA[<p>题目大意：有n个初始字符串，由这n个初始字符串延伸出实际字符串。</p>
<span id="more"></span>
<p>每个实际字符串为初始字符串循环后得到。字符集为 {0,1}。如初始字符串
01，循环后得到实际字符串
01010101…。求n个实际字符串中任意两个串的最长公共前缀。第i个初始字符串的长度小于500。保证每个初始字符串都不存在周期。其中n属于20000.</p>
<p>一个很显然的思路：既然只有01，那么我们分治来做，对于每一位，是0的分一堆儿，是1的分一堆儿</p>
<p>然后分到最后，l=r的时候，分到了哪一位就是最长的公共前缀，然后每个都取max</p>
<p>注意：一定要提前处理好字符串的长度，不可边算边处理</p>
<p>hack数据：</p>
<p>10与101</p>
<p>如果先排序后处理的话，会得到：10，101</p>
<p>如果先处理后排序的话，会得到101，10(10)</p>
<p>这就是tm20pts与100pts的区别</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e4</span> + <span class="number">66</span>, inf = <span class="number">214748364</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, res; string s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> (<span class="type">void</span>)(res = <span class="built_in">max</span>(res, x - <span class="number">1</span>));</span><br><span class="line">    <span class="type">int</span> i, mid = -inf;</span><br><span class="line">    <span class="keyword">for</span> (i = l + <span class="number">1</span>; i &lt;= r; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i][x] != s[i - <span class="number">1</span>][x])</span><br><span class="line">        &#123;</span><br><span class="line">            mid = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mid != -inf) <span class="built_in">solve</span>(x + <span class="number">1</span>, l, mid), <span class="built_in">solve</span>(x + <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">solve</span>(x + <span class="number">1</span>, l, r);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i; n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">getline</span>(cin, s[i]);</span><br><span class="line">        string a = s[i];</span><br><span class="line">        <span class="keyword">while</span> ((s[i].<span class="built_in">length</span>() + a.<span class="built_in">length</span>()) &lt;= <span class="number">1000</span>) s[i] += a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(s + <span class="number">1</span>, s + n + <span class="number">1</span>), <span class="built_in">solve</span>(<span class="number">0</span>, <span class="number">1</span>, n);	</span><br><span class="line">    <span class="built_in">put</span>(res);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">fclose</span>(stdin), <span class="built_in">fclose</span>(stdout);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：细节决定成败，我今天的经历仿佛一场梦，从第一到倒数，无法预料</p>
<p>还是要以积极的态度面对生活，放下分数，拿起知识，尽人事，听天命，面临CSP-S最后一个月，冲冲冲！</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title>数列极限与性质</title>
    <url>/2022/09/21/%E6%95%B0%E5%88%97%E6%9E%81%E9%99%90%E4%B8%8E%E6%80%A7%E8%B4%A8/</url>
    <content><![CDATA[<p>关于数列极限与性质</p>
<span id="more"></span>
<h1 id="数列极限">数列极限</h1>
<h2 id="通俗定义">通俗定义</h2>
<p>n趋近于无限大，数列中的一般项<span
class="math inline">\(x_n\)</span>无限接近于某一个常数，那么称该常数为该数列的极限，或称该数列收敛该常数，记作
<span class="math display">\[
{\lim_{x \to +\infty}} x_n = a
\]</span> 否则，称该数列发散，或者 <span class="math display">\[
{\lim_{x \to +\infty}}x_n
\]</span> 不存在。 <span class="math display">\[
\begin{aligned}
n \to +\infty,x_n \to a \iff \\
n \to +\infty,|x_n - a| \to \iff \\
n \to +\infty,|x_n - a| \to 任意小，可以小于给定的任何正数
\end{aligned}
\]</span></p>
<h2 id="精确定义">精确定义</h2>
<p><span class="math inline">\(\forall \varepsilon,\exists
N\)</span>，使得<span class="math inline">\(n &gt; N\)</span>,<span
class="math inline">\(|x_n - a|&lt;
\varepsilon\)</span>总成立，那么称该常数为该数列的极限，或称该数列收敛该常数</p>
<h2 id="极限的四则运算法则">极限的四则运算法则</h2>
假设 <span class="math display">\[
\begin{aligned}
{\lim_{n \to +\infty}} a_n = a \\
{\lim_{n \to +\infty}} b_n = b \\
\end{aligned}
\]</span> 那么，满足 $$
<span class="math display">\[\begin{aligned}
\lim_{n \to +\infty}(C_1a_n + C_2b_n) = C_1\lim_{n \to +\infty}a_n +
C_2\lim_{n \to +\infty}b_n = C_1a+C_2b\\

\lim_{n \to +\infty}(a_n+ b_n) = \lim_{n \to +\infty}a_n \lim_{n \to
+\infty}b_n = ab
\end{aligned}\]</span>
<p>$$ 其中，极限的相除，分母不可为零</p>
<h2 id="求极限的方法">求极限的方法</h2>
<ul>
<li>多项式比多项式</li>
</ul>
<p>若最高次幂相同，那么该极限即为最高次幂的系数</p>
<p>若最高次幂不同，则该数列不存在极限</p>
<ul>
<li>遇见根式，有理化</li>
<li>永远只看最高项</li>
</ul>
<h2 id="相关定理">相关定理</h2>
<ul>
<li>夹逼定理</li>
</ul>
<p><span class="math inline">\(\forall n
\text{使得}\left\{x_n\right\}\left\{y_n
\right\}\left\{z_n\right\}\)</span>，且满足 <span
class="math display">\[
\begin{aligned}
y_n &lt; x_n &lt;z_n\\
\lim_{n \to +\infty} y_n = \lim_{n \to +\infty}z_n = a
\end{aligned}
\]</span> 那么 <span class="math display">\[
\lim_{n \to +\infty}x_n = a
\]</span> 应用：</p>
<p>遇到数列，考虑放缩，不改变最高次幂，改变次要项</p>
<p>日后不坑，没精力继续写了</p>
<ul>
<li>单调有界数列必有极限</li>
</ul>
<p>单调递增序列有上界</p>
<p>单调递减数列有下界</p>
<h1 id="数列极限的性质">数列极限的性质</h1>
<ul>
<li>唯一性</li>
<li>收敛的数列必有界（反过来不成立，<span
class="math inline">\((-1)^{n+1}\)</span>）</li>
<li>保号性</li>
</ul>
]]></content>
      <categories>
        <category>Univ秋1</category>
      </categories>
      <tags>
        <tag>高数</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索小练#9后续</title>
    <url>/2020/06/30/%E6%90%9C%E7%B4%A2%E5%B0%8F%E7%BB%83-9%E5%90%8E%E7%BB%AD/</url>
    <content><![CDATA[<p>给出完整的AC代码 <span id="more"></span> 这个题只需要写一个队列....</p>
<p>枚举两个人可能选的坐标情况，作为不同的初始状态</p>
<p>对每个初始状态进行bfs搜索，得到木板上的每块草地被烧完的时间</p>
<p>其中烧完杯子耗时最久的时间就是总时间</p>
<p>然后根据此初始状态的耗时去更新答案</p>
<p>得到所有初始状态中耗时最小的时间</p>
<p>若无法更新得到，则输出-1</p>
<p><strong>注意标点符号</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">66</span>, INF = <span class="number">214748364</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> T, n, m, k, res;</span><br><span class="line"><span class="type">int</span> a[N][N], v[N][N], cost[N][N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dx[N] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[N] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;<span class="type">int</span> x, y;<span class="built_in">node</span> (<span class="type">int</span> x, <span class="type">int</span> y):<span class="built_in">x</span>(x),<span class="built_in">y</span>(y)&#123;&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">getsum</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i][j] &amp;&amp; !v[i][j]) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (a[i][j] &amp;&amp; cost[i][j] &gt; tmp)</span><br><span class="line">                tmp = cost[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (tmp &lt; res) res = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">bfs</span> <span class="params">(<span class="type">int</span> nx, <span class="type">int</span> ny, <span class="type">int</span> s, <span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span> (v, <span class="number">0</span>, <span class="keyword">sizeof</span> v);</span><br><span class="line">    <span class="built_in">memset</span> (cost, <span class="number">-1</span>, <span class="keyword">sizeof</span> cost);</span><br><span class="line">    queue&lt;node&gt;q;</span><br><span class="line">    v[nx][ny] = <span class="number">1</span>, cost[nx][ny] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">node</span>(nx, ny));</span><br><span class="line">    <span class="keyword">if</span> (!v[s][t]) &#123;</span><br><span class="line">        v[s][t] = <span class="number">1</span>;</span><br><span class="line">        cost[s][t] = <span class="number">0</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="built_in">node</span>(s, t));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        node tmp = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++ i) &#123;</span><br><span class="line">            <span class="type">int</span> curx = tmp.x+dx[i], cury = tmp.y+dy[i];</span><br><span class="line">            <span class="keyword">if</span> ((curx &lt; <span class="number">1</span>) || (curx &gt; n) || (cury &lt; <span class="number">1</span>) || (cury &gt; m)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!v[curx][cury] &amp;&amp; a[curx][cury]) &#123;</span><br><span class="line">                v[curx][cury] = <span class="number">1</span>;</span><br><span class="line">                cost[curx][cury] = cost[tmp.x][tmp.y]+<span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(<span class="built_in">node</span>(curx, cury));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getsum</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch[N];</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T --&gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ++ k; res = INF;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span> (<span class="string">&quot;%s&quot;</span>, ch+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line">                a[i][j] = (ch[j] == <span class="string">&#x27;#&#x27;</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> ni = <span class="number">1</span>; ni &lt;= n; ++ ni)</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> nj = <span class="number">1</span>; nj &lt;= m; ++ nj)</span><br><span class="line">                        <span class="keyword">if</span> (a[i][j] &amp;&amp; a[ni][nj])</span><br><span class="line">                            <span class="built_in">bfs</span> (i, j, ni, nj);</span><br><span class="line">        <span class="keyword">if</span> (res != INF) <span class="built_in">printf</span> (<span class="string">&quot;Case %d: %d\n&quot;</span>, k, res);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span> (<span class="string">&quot;Case %d: -1\n&quot;</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>体会二维坐标的写法以及结构体的定义函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * By Youngore</span></span><br><span class="line"><span class="comment"> * Time:20.10.17</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 214748364</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, t, T, res;</span><br><span class="line"><span class="type">int</span> a[N][N], vis[N][N], dis[N][N];</span><br><span class="line"><span class="type">int</span> d[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yhy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="built_in">yhy</span>(<span class="type">int</span> x, <span class="type">int</span> y):<span class="built_in">x</span>(x), <span class="built_in">y</span>(y)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">yhy_clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">-1</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">get_sum</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, tmp = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a[i][j] &amp;&amp; ! vis[i][j])) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> (a[i][j] &amp;&amp; dis[i][j] &gt; tmp) tmp = dis[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(res = (res &gt; tmp) ? tmp : res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> nx, <span class="type">int</span> ny)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">yhy_clear</span>(); queue&lt;yhy&gt;q;</span><br><span class="line">    vis[x][y] = <span class="number">1</span>, dis[x][y] = <span class="number">0</span>, q.<span class="built_in">push</span>(<span class="built_in">yhy</span>(x, y));</span><br><span class="line">    <span class="keyword">if</span> (! vis[nx][ny])</span><br><span class="line">    &#123;</span><br><span class="line">        vis[nx][ny] = <span class="number">1</span>, dis[nx][ny] = <span class="number">0</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="built_in">yhy</span>(nx, ny));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (! q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        yhy tmp = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> curx = tmp.x + d[i][<span class="number">0</span>], cury = tmp.y + d[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (curx &lt; <span class="number">1</span> || curx &gt; n || cury &lt; <span class="number">1</span> || cury &gt; m) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (! vis[curx][cury] &amp;&amp; a[curx][cury])</span><br><span class="line">            &#123;</span><br><span class="line">                vis[curx][cury] = <span class="number">1</span>;</span><br><span class="line">                dis[curx][cury] = dis[tmp.x][tmp.y] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(<span class="built_in">yhy</span>(curx, cury));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(<span class="built_in">get_sum</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">youngore</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T --&gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ++ t; res = INF;</span><br><span class="line">        <span class="type">int</span> i, j, ni, nj; <span class="built_in">scanf</span> (<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> ch[N];</span><br><span class="line">            <span class="built_in">scanf</span> (<span class="string">&quot;%s&quot;</span>, ch + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= m; ++ j) a[i][j] = (ch[j] == <span class="string">&#x27;#&#x27;</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line">        <span class="keyword">for</span> (ni = <span class="number">1</span>; ni &lt;= n; ++ ni) <span class="keyword">for</span> (nj = <span class="number">1</span>; nj &lt;= m; ++ nj)</span><br><span class="line">            <span class="keyword">if</span> (a[i][j] &amp;&amp; a[ni][nj]) <span class="built_in">bfs</span>(i, j, ni, nj);</span><br><span class="line">        <span class="keyword">if</span> (res != INF) <span class="built_in">printf</span> (<span class="string">&quot;Case %d: %d\n&quot;</span>, t, res);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span> (<span class="string">&quot;Case %d: -1\n&quot;</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> search_ex = <span class="built_in">youngore</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>搜索小练</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>方差</title>
    <url>/2020/10/05/%E6%96%B9%E5%B7%AE/</url>
    <content><![CDATA[<p>题目大意：对于一个大小为 𝑛 的数集 {𝑎𝑖} ，设其平均值为 𝑥 =∑ 𝑎𝑖/𝑛
，则它的方差为<span class="math inline">\(∑(𝑎𝑖−𝑥)^2/𝑛\)</span>
。现在有一个数集，你需要求出这个数集的每个非空子集的方差之和对1e9 + 7
取模的结果</p>
<span id="more"></span>
<p>推式子可以得到：</p>
<p><span class="math display">\[\dfrac { \sum{a_i}^2} {n} - \dfrac
{(\sum a_i)^2}{n^2}\]</span></p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">666</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, sum1, sum2, res;</span><br><span class="line"><span class="type">int</span> a[N], sum[N], fac[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">ksm</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ret</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pres_dou</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) fac[i] = fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x == y || y == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> fac[x] * <span class="built_in">ksm</span>(fac[y] * fac[x - y] % mod, mod - <span class="number">2</span>) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">ifac</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ksm</span>(x, mod - <span class="number">2</span>) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, x, y;</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i] = <span class="built_in">read</span>();</span><br><span class="line">        sum[i] = ( sum[i - <span class="number">1</span>] + a[i]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">	(sum1 += a[i] * a[i] % mod) %= mod, (sum2 += <span class="number">2</span> * a[i] * ((sum[n] - sum[i]) % mod + mod) % mod) %= mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pres_dou</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">	x = ifac(i), y = ifac(i * i % mod);</span><br><span class="line"></span><br><span class="line">	res += ((sum1 * <span class="built_in">C</span>(n - <span class="number">1</span>, i - <span class="number">1</span>) % mod * x</span><br><span class="line">        - (sum1 * <span class="built_in">C</span>(n - <span class="number">1</span>, i - <span class="number">1</span>) % mod + sum2 * <span class="built_in">C</span>(n - <span class="number">2</span>, i - <span class="number">2</span>) % mod) * y + mod) % mod + mod) % mod;</span><br><span class="line"></span><br><span class="line">	res = res % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">put</span>(res % mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>旅行</title>
    <url>/2020/10/02/%E6%97%85%E8%A1%8C/</url>
    <content><![CDATA[<p>题目大意：小Y得到了一个长度为n的序列a <span id="more"></span></p>
<p>选定一个区间 <span class="math inline">\([l,r] (l\not=r)\)</span>
，设区间中的最大值为x，最小值为y，则他定义该区间的价值为 <span
class="math inline">\(\dfrac {x-y}
{r-l}\)</span>。现在，他想让你找出这个序列价值最大的区间。你只需输出最大的价值下取整的结果。</p>
<p>这道题目和“计数”长得挺像，但是做法却一点也不同</p>
<p>首先我们可以发现，最优解的那个区间，其最大/小值一定在两个端点（可以反证）</p>
<p>那么最大值就会变成<span class="math inline">\(\dfrac{abs(a_l
-a_r)}{r-l}\)</span>，这个式子挺像文化课里面算斜率的那个式子</p>
<p>所以我们可以大胆假设，把<span
class="math inline">\((i,a_i)\)</span>看成二维平面的点，求两点间斜率的最大值</p>
<p>这时候，显然所有的点都在凸包上，再画个图就可以发现，我们只需要考虑最近的两个点</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span> (T --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i, n = <span class="built_in">read</span>();</span><br><span class="line">        <span class="type">int</span> maxv = <span class="number">0</span>;</span><br><span class="line">        a[<span class="number">0</span>] = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i &amp; <span class="number">1</span>] = <span class="built_in">read</span>();</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(a[<span class="number">0</span>] - a[<span class="number">1</span>]) &gt; maxv)</span><br><span class="line">               maxv = <span class="built_in">abs</span>(a[<span class="number">0</span>] - a[<span class="number">1</span>]); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">put</span>(maxv);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维题</tag>
      </tags>
  </entry>
  <entry>
    <title>映射与函数</title>
    <url>/2022/09/14/%E6%98%A0%E5%B0%84%E4%B8%8E%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>关于函数与映射的相关内容 <span id="more"></span></p>
<h1 id="映射">映射</h1>
<h2 id="映射的分类">映射的分类</h2>
<p>单射，满射，非单非满，既单既满</p>
<p>所有的“射”指的是被映射后的域</p>
<p>且根据映射的定义，我们知道，从左往右看，可以多对一，不允许一对多，X中必须全部映射</p>
<p><span class="math inline">\(f:X \rightarrow Y\)</span> ，且<span
class="math inline">\(R_f = f(X) = \{ f(x) \mid x \in X \}\)</span></p>
<h2 id="关于逆映射">关于逆映射</h2>
<p>很类似于 乘法逆元</p>
<p>要求：原映射是单射</p>
<p>逆映射的定义域是原映射的值域，或者说，反函数的定义域是原函数值域</p>
<p>其中存在一种恒等映射，即</p>
<p><span class="math inline">\(f \circ f^{-1}(x) = x\)</span></p>
<h2 id="关于复合映射">关于复合映射</h2>
<p><span class="math inline">\(g:X \rightarrow Y_1\)</span>, <span
class="math inline">\(f:Y_2 \rightarrow Z\)</span></p>
<p>且 <span class="math inline">\(Y_1 \subset Y_2\)</span></p>
<p>那么，我们可以定义复合映射<span class="math inline">\(f \circ g:X
\rightarrow Z\)</span></p>
<p>也即 $(f g)(x) = f[g(x)], x X $</p>
<p>注意</p>
<ul>
<li><span class="math inline">\(R_g \subset
D_f\)</span>，g的值域包含在f的定义域内</li>
<li><span class="math inline">\(f \circ g \ne g \circ f\)</span></li>
</ul>
<h1 id="函数">函数</h1>
<h2 id="函数与映射的区别">函数与映射的区别</h2>
<ol type="1">
<li>函数有先后关系，map没有</li>
<li>map中元素无要求，可以是字符，也可以是数集</li>
<li>函数一定是满射</li>
</ol>
<h2 id="判别两个函数是否相同">判别两个函数是否相同</h2>
<ol type="1">
<li>定义域</li>
<li>对应法则</li>
</ol>
<p>example：</p>
<p><span class="math inline">\(ln_x^2 ,2linx\)</span></p>
<h2 id="函数的特性">函数的特性</h2>
<ul>
<li>有界性</li>
</ul>
<p>有界：</p>
<p><span class="math inline">\(X \subset D, \exists M&gt; 0,\forall x
\in X\)</span> ，有$ | f(x)| M$</p>
<p>无界：</p>
<p><span class="math inline">\(X \subset D, \forall M&gt;0,\exists
x_0\)</span>，使得<span class="math inline">\(\left| f(x_0)\right| &gt;
M\)</span></p>
<p>说白了，有界无界是在看一段区域内，值域是否存在<span
class="math inline">\(\infty\)</span></p>
<p>额外提一嘴，最小上界叫做上确界，最大下界叫做下确界</p>
<p>所以我们可以知道，界不是唯一的</p>
<ul>
<li>单调性</li>
</ul>
<p>做差，做商，求导判正负</p>
<ul>
<li>奇偶性</li>
</ul>
<p>关于奇偶性的判断</p>
<ol type="1">
<li>定义域必须关于原点对称</li>
<li>写<span class="math inline">\(f(-x)\)</span>，化简</li>
</ol>
<ul>
<li>周期性</li>
</ul>
<p>存在一个特例，是周期函数，但是无最小正周期</p>
<p>迪利克雷函数 <span class="math display">\[
f(x)=\left\{
\begin{aligned}
1 &amp;&amp; x &amp; \in Q \\
0 &amp;&amp; x &amp; \in I
\end{aligned}
\right.
\]</span></p>
<p>任意有理数都是其正周期</p>
<h2 id="求解反函数">求解反函数</h2>
<p>变换字母，化简</p>
<p><span class="math inline">\(example:\)</span></p>
<p><span class="math inline">\(y = 1 + log_{10}(x + 2)\)</span></p>
<p>解决： <span class="math display">\[
\begin{aligned}
x = 1 + log_{10}(y+2)\\
x - 1 = log_{10}(y+2)\\
10^{x-1}=y+2\\
y=10^{x-1} - 2
\end{aligned}
\]</span> End.</p>
]]></content>
      <categories>
        <category>Univ秋1</category>
      </categories>
      <tags>
        <tag>高数</tag>
      </tags>
  </entry>
  <entry>
    <title>数列</title>
    <url>/2020/10/15/%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<p>题目大意：有一个长度为𝑛的数列，数列中每个数都是[0, 𝑝 −
1]之间的整数。<span id="more"></span>小A不知道数列中每个数的值，所以向小B做了𝑚次询问。
每次小A会向小B询问一个区间[𝑙,
𝑟]中所有数的和对𝑝取模的结果。问完所有问题后，小A发现小B的回答中似乎存在矛盾。现在小A想找到最大的𝑋，满足小B的前𝑋次回答中不存在矛盾(𝑋有可能等于𝑚)。</p>
<p>通过<a
href="https://blog.csdn.net/Dextrad_ihacker/article/%20details/51016017">这篇题解</a>学会了</p>
<p>具体请移步:How Many Answers Are Wrong的题解</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, mod;</span><br><span class="line"><span class="type">int</span> a[N], fa[N], sum[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">yhm_find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == fa[x]) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">yhm_find</span>(fa[x]);</span><br><span class="line">    sum[x] = (sum[x] + sum[fa[x]]) % mod;</span><br><span class="line">    <span class="keyword">return</span> fa[x] = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, l, r, k, x, y;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>(), mod = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) fa[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        l = <span class="built_in">read</span>(), r = <span class="built_in">read</span>(), k = <span class="built_in">read</span>();</span><br><span class="line">        x = <span class="built_in">yhm_find</span>(l - <span class="number">1</span>), y = <span class="built_in">yhm_find</span>(r);</span><br><span class="line">        <span class="keyword">if</span> (x != y)</span><br><span class="line">        &#123;</span><br><span class="line">            fa[x] = y;</span><br><span class="line">            sum[x] = (sum[r] - sum[l - <span class="number">1</span>] + k + mod) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((sum[l - <span class="number">1</span>] - sum[r] + mod) % mod != k) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">put</span>(i - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：今天考试第一题挂掉了，第三题的题面隐藏的信息没有挖掘出来</p>
<p>期望得分：80+30+60pts，实际得分：50+30+0pts</p>
<p>第三题我真傻逼，没看出来或者说没看懂题面</p>
<p>我的排名在进步，我要继续努力，一天一个专题，一天五道题，冲鸭！</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>普通快乐</title>
    <url>/2020/10/01/%E6%99%AE%E9%80%9A%E5%BF%AB%E4%B9%90/</url>
    <content><![CDATA[<p>题目大意：这是一张 n 个点 m 条边的连通图。这张图上面有 k
个奇葩点。保证没有重边和自环。
现在要求你<strong>从其中任意一个奇葩点开始走，走到除了这个奇葩点以外的最近奇葩点</strong>。
问选择哪一个奇葩点开始走，路程最小。 <span id="more"></span></p>
<p>暴力做法，对每一个奇葩点都跑一边dij或者spfa</p>
<p>考虑优化：（来自<a
href="https://www.cnblogs.com/Aswert/">Aswert大佬</a>做法)</p>
<p>你考虑对每一个点dij的时候，如果发现我们遇到的这个点就是奇葩点，就停止</p>
<p>因为我们第一次搜到他，无论是哪个点，距离一定是最小的</p>
<p>再加上快读优化，就过了，暴力碾标算</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pr;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">666</span>, inf = <span class="number">214748364</span>;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;pr, vector&lt;pr&gt;, greater&lt;pr&gt; &gt;q;</span><br><span class="line"><span class="type">int</span> n, m, k, <span class="built_in">yhm</span>(inf);</span><br><span class="line"><span class="type">int</span> c[N], dis[N], vis[N], tag[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dij</span><span class="params">(<span class="type">int</span> now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, x, y, fuck;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) dis[i] = inf, vis[i] = <span class="number">0</span>;</span><br><span class="line">    dis[now] = <span class="number">0</span>, vis[now] = <span class="number">1</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">pr</span>(<span class="number">0</span>, now));</span><br><span class="line">    <span class="keyword">while</span> (! q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        x = q.<span class="built_in">top</span>().second; q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[x] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (tag[x] &amp;&amp; x != now) <span class="keyword">return</span> (<span class="type">void</span>)(yhm = <span class="built_in">min</span>(yhm, dis[x]));</span><br><span class="line">        <span class="keyword">for</span> (i = head[x]; i; i = nex[i])</span><br><span class="line">        &#123;</span><br><span class="line">            y = ver[i];</span><br><span class="line">            <span class="keyword">if</span> (dis[y] &gt; dis[x] + len[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[y] = dis[x] + len[i];</span><br><span class="line">                <span class="keyword">if</span> (! vis[y])</span><br><span class="line">                &#123;</span><br><span class="line">                    vis[y] = <span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(<span class="built_in">pr</span>(dis[y], y));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, x, y, z;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>(), k = <span class="built_in">read</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>(), z = <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">add_edge</span>(x, y, z);</span><br><span class="line">        <span class="built_in">add_edge</span>(y, x, z);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= k; ++ i) c[i] = <span class="built_in">read</span>(), tag[c[i]] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (x = <span class="number">1</span>; x &lt;= k; ++ x) <span class="built_in">dij</span>(c[x]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">put</span>(yhm);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正解：二进制拆分</p>
<p>考虑两个点集S1和S2之间的最短路，我们可以跑一次最短路求出来。</p>
<p>具体可以新建虚拟源点s和虚拟汇点t，s和S1的每个点之间连一条零边，t同理。</p>
<p>那么这一次最短路就相当与求出了|S1|×|S2|对关系之间的最短路最小值。</p>
<p>还可以继续优化</p>
<p>通过二进制分组，我们完全可以使复杂度优化到<span
class="math inline">\(O(m\times logm\times logn)\)</span></p>
<p>枚举顶点标号的二进制的每一位，如果这一位为1，那么把这个点分到S1，否则分到S2。</p>
<p>为什么不能是只跑一位？因为只跑一位可能会少一些情况，在二进制下，很神奇的就不会漏下情况</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pr;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;pr, vector&lt;pr&gt;, greater&lt;pr&gt; &gt;q;</span><br><span class="line"><span class="type">int</span> n, m, k, res = <span class="number">123456789</span>;</span><br><span class="line"><span class="type">int</span> g[N];</span><br><span class="line"><span class="type">int</span> dis[N], vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fuck</span><span class="params">(<span class="type">int</span> now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, x, y;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) dis[i] = <span class="number">1e9</span>, vis[i] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= k; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((g[i] &gt;&gt; now) &amp; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(<span class="built_in">pr</span>(<span class="number">0</span>, g[i]));</span><br><span class="line">            dis[g[i]] = <span class="number">0</span>;</span><br><span class="line">            vis[g[i]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (! q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        x = q.<span class="built_in">top</span>().second; q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[x] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = head[x]; i; i = nex[i])</span><br><span class="line">        &#123;</span><br><span class="line">            y = to[i];</span><br><span class="line">            <span class="keyword">if</span> (dis[y] &gt; dis[x] + len[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[y] = dis[x] + len[i];</span><br><span class="line">                <span class="keyword">if</span> (! vis[y])</span><br><span class="line">                &#123; </span><br><span class="line">                    vis[y] = <span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(<span class="built_in">pr</span>(dis[y], y));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= k; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (! ((g[i] &gt;&gt; now) &amp; <span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            res = <span class="built_in">min</span>(res, dis[g[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, x, y, z;</span><br><span class="line">    </span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>(), k = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>(), z = <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">add_edge</span>(x, y, z);</span><br><span class="line">        <span class="built_in">add_edge</span>(y, x, z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= k; ++ i) g[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">16</span>; ++ i) <span class="built_in">fuck</span>(i);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">put</span>(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>最优包含</title>
    <url>/2020/11/13/%E6%9C%80%E4%BC%98%E5%8C%85%E5%90%AB/</url>
    <content><![CDATA[<p>题目大意：S串最少修改多少次可以匹配T串（子序列）<span id="more"></span></p>
<p>如果是匹配子串，那就是个贪心了，但是匹配子序列，肯定是dp</p>
<p>类似匹配dp</p>
<p>状态：<strong>设<span
class="math inline">\(f_{ij}\)</span>表示S串中前i个字符修改j次最长可以匹配的序列（第二维即时答案）</strong></p>
<p>初始：都是0</p>
<p>转移：<span
class="math inline">\(f_{i,j}=max(f_{i-1,j}+(s_i==t_{f_{i-1,j}+1}),f_{i-1,j-1}+1)\)</span></p>
<p>简单来说，就是对于第i位，考虑当前是否替换</p>
<p><span
class="math inline">\(f_{i-1,j}+(s_i==t_{f_{i-1,j}+1})\)</span>即为不替换当前</p>
<p><span
class="math inline">\(f_{i-1,j-1}+1\)</span>即为替换当前（不考虑当前的情况，直接暴力从原来的基础上加1）</p>
<p>时空复杂度都为：<span class="math inline">\(O(n^2)\)</span></p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, res = <span class="number">123456789</span>;</span><br><span class="line"><span class="type">char</span> s[N], t[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%s%s&quot;</span>, s + <span class="number">1</span>, t + <span class="number">1</span>);</span><br><span class="line">    n = <span class="built_in">strlen</span>(s + <span class="number">1</span>), m = <span class="built_in">strlen</span>(t + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= i; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j] + (s[i] == t[f[i - <span class="number">1</span>][j] + <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (j) f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            f[i][j] == m ? res = <span class="built_in">min</span>(res, j) : res = res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%d&quot;</span>, res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>咦？我们观察发现第一维度好想可以滚掉</p>
<p>虽然此题没卡空间，但是如果卡的话….</p>
<p>滚动数组：开个变量now记录当前是0还是1</p>
<p>然后来回倒腾，在0的时候用1来转移，在1的时候用0来转移</p>
<p>空间复杂度：<span class="math inline">\(O(N)\)</span></p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, res = <span class="number">123456789</span>;</span><br><span class="line"><span class="type">char</span> s[N], t[N];</span><br><span class="line"><span class="type">int</span> f[<span class="number">2</span>][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, <span class="built_in">now</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%s%s&quot;</span>, s + <span class="number">1</span>, t + <span class="number">1</span>);</span><br><span class="line">    n = <span class="built_in">strlen</span>(s + <span class="number">1</span>), m = <span class="built_in">strlen</span>(t + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= i; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            f[now][j] = f[now ^ <span class="number">1</span>][j] + (s[i] == t[f[now ^ <span class="number">1</span>][j] + <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (j) f[now][j] = <span class="built_in">max</span>(f[now][j], f[now ^ <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            f[now][j] == m ? res = <span class="built_in">min</span>(res, j) : res = res;</span><br><span class="line">        &#125;</span><br><span class="line">        now ^= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%d&quot;</span>, res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后记：</p>
<p>此题不难，状态很多种</p>
<p>A了之后去看题解，发现状态跟我设的都不一样</p>
<p>我觉得我的状态貌似难理解一点，我要是设一个主流的状态，或许会更快的做出来这道题</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动规</tag>
      </tags>
  </entry>
  <entry>
    <title>最优排名</title>
    <url>/2020/10/23/%E6%9C%80%E4%BC%98%E6%8E%92%E5%90%8D/</url>
    <content><![CDATA[<p>题目大意：<span class="math inline">\(A\)</span>君和<span
class="math inline">\(B\)</span>君准备参加<span
class="math inline">\(C\)</span>国举办的<span
class="math inline">\(WGP\)</span>。比赛规则为若赢得一场游戏的胜利则会获得一点马力值，但每个队伍有一个马力值上限<span
class="math inline">\(w_i\)</span>，若超过上限则会变为<span
class="math inline">\(0\)</span>。马力从高到低进行排名，马力一样则视为排名一样。<span id="more"></span>比赛已经结束，参赛队伍通过比赛获得的马力为<span
class="math inline">\(v_i\)</span>。<span
class="math inline">\(A\)</span>君是一个马力爆棚的人因此他喜欢把自己多余的马力给别人来奶死对面。现在<span
class="math inline">\(B\)</span>君想知道<span
class="math inline">\(A\)</span>君在将马力合理卖完马之后自己队伍的最高排名是多少。（来自Ame__的题目<strong>翻译</strong>）</p>
<p>贪心就完事了，做法实现很多，这里介绍一种</p>
<p>排个序，然后拎出原来那个，每次把比他大的里边<span
class="math inline">\(w_i-v_i\)</span>最小的那个干掉，然后自己往后战略性撤退，把比自己大的再押进去</p>
<p>考试时候傻逼了，写完之后看到数据范围，嫌麻烦，没开ll，准备最后再开</p>
<p>然后最后的时候忘了，挂掉五十分</p>
<p>注意一个小细节：能减就一直减，当我们要减为0的时候，一定不会使得答案变得更差（想一想，为什么？）</p>
<p>讨论两种情况，当前答案后面有数字，和后面没有数字</p>
<ul>
<li>后面没有数字，也就是干掉他之后，大家都是0，而题目告诉我们，马力一样的排名一样，我前边的人少了一个，我的排名一定会更优</li>
<li>后面有数字，我变成0一定不能再减少了，所以我不干掉他一定是最优的，咦，这个答案不是在上次就已经取到了吗？所以即使这次不优，对上次的ans没有丝毫影响</li>
</ul>
<p>代码如下（外加一组调试数据和痕迹）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yhzhyhm</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> v, w, id;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> yhzhyhm &amp;x) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (v &gt; x.v) || ((v == x.v) &amp;&amp; (id &lt; x.id));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;yh[N];</span><br><span class="line"></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt; &gt;q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, x, n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) yh[i].v = <span class="built_in">read</span>(), yh[i].w = <span class="built_in">read</span>(), yh[i].id = i;</span><br><span class="line">    x = yh[<span class="number">1</span>].v;</span><br><span class="line">    <span class="built_in">sort</span>(yh + <span class="number">1</span>, yh + <span class="number">1</span> + n);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;------------------------\n&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) cout &lt;&lt; yh[i].v &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; yh[i].w &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (yh[i].id == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(yh[i].w - yh[i].v + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = i, rnk = i, pos = i, ret = x, pd = <span class="number">1</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">res is answer</span></span><br><span class="line"><span class="comment">rnk is now_pai_ming</span></span><br><span class="line"><span class="comment">pos is now_wei_zhi</span></span><br><span class="line"><span class="comment">ret is now_shengyu</span></span><br><span class="line"><span class="comment">pd is now_tag</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;rnk---&gt;&quot;</span> &lt;&lt; rnk &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span> (! q.<span class="built_in">empty</span>() &amp;&amp; pd == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pd = <span class="number">0</span>, x = q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;x--&gt;&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (ret &gt;= x) ret -= x, pd = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (! pd) <span class="keyword">break</span>;</span><br><span class="line">        <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = pos + <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (yh[i].v &lt;= ret) <span class="keyword">break</span>;</span><br><span class="line">            ++ num;</span><br><span class="line">            q.<span class="built_in">push</span>(yh[i].w - yh[i].v + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pos = i - <span class="number">1</span>, rnk = rnk - <span class="number">1</span> + num;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;now_rnk-&gt;&quot;</span> &lt;&lt; rnk &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;now_pos---&gt;&quot;</span> &lt;&lt; pos &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        res = <span class="built_in">min</span>(res, rnk);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">put</span>(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">25 38</span></span><br><span class="line"><span class="comment">45 48</span></span><br><span class="line"><span class="comment">9 13</span></span><br><span class="line"><span class="comment">49 50</span></span><br><span class="line"><span class="comment">12 14</span></span><br><span class="line"><span class="comment">41 42</span></span><br><span class="line"><span class="comment">34 37</span></span><br><span class="line"><span class="comment">46 49</span></span><br><span class="line"><span class="comment">14 15</span></span><br><span class="line"><span class="comment">23 26</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>最长不下降子序列</title>
    <url>/2020/11/25/%E6%9C%80%E9%95%BF%E4%B8%8D%E4%B8%8B%E9%99%8D%E5%BA%8F%E5%88%97%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p>题目大意:给定<strong>生成序列</strong>的方式,求这个序列最长不下降子序列.<span id="more"></span></p>
<p>我们定义的f[i]表示当lis长度为i的lis最小末尾是i,如果发现当前的a[i]比f[i]大,就直接压入,否则二分查找一个第一个比a[i]大的数字,覆盖掉,然后继续走</p>
<p>例子:</p>
<p>对于2 1 5 3 6 4 8 9 7这个序列</p>
<p>当我们搞完这些的时候,lis长度是5:{1,3,4,7,9}</p>
<p>注意,他只是存储对应长度lis的最小末尾,有了这个末尾我们就可以一个一个插入数据,虽然最后一个a[9]=7压入进去无贡献,假如后面再出现两个数组8和9,那么就可以把8更新掉9,9更新f[6]</p>
<p>lis最长长度为6</p>
<p>代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, t_0, A, B, C, D, len;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">res</span><span class="params">(<span class="number">1</span>)</span>, a[N], b[N], f[N]</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i; n = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    t_0 = <span class="built_in">read</span>(), A = <span class="built_in">read</span>(), B = <span class="built_in">read</span>(), C = <span class="built_in">read</span>(), D = <span class="built_in">read</span>();</span><br><span class="line">    b[<span class="number">1</span>] = a[<span class="number">1</span>] = t_0;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; ++ i) b[i] = a[i] = (A * a[i - <span class="number">1</span>] * a[i - <span class="number">1</span>] + B * a[i - <span class="number">1</span>] + C) % D;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + n), <span class="built_in">unique</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + n) - b - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) a[i] = <span class="built_in">lower_bound</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + n, a[i]) - b;</span><br><span class="line"></span><br><span class="line">    f[len = <span class="number">1</span>] = a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt;= f[len]) res = <span class="built_in">max</span>(res, len + <span class="number">1</span>), f[++ len] = a[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> pos = <span class="built_in">upper_bound</span>(f + <span class="number">1</span>, f + <span class="number">1</span> + len, a[i]) - f;</span><br><span class="line">            f[pos] = a[i];</span><br><span class="line">            res = <span class="built_in">max</span>(res, pos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">put</span>(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后记:</p>
<p>正解:因为是生成序列,所以有循环节,然后自己去找找憋一会就能憋出来.</p>
<p>上文中我说的是正统的nlogn的做法.</p>
<p>以前学过,最近忘了,忘得还不少...</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动规</tag>
        <tag>一般dp</tag>
      </tags>
  </entry>
  <entry>
    <title>最小公倍数</title>
    <url>/2020/10/07/%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/</url>
    <content><![CDATA[<p>题目大意：给定 𝑛 ，你需要找到三个 [1,𝑛]
中的正整数，使得它们的最小公倍数最大</p>
<span id="more"></span>
<p>考虑n的奇偶情况</p>
<p>n如果为奇数，那么显然当前<span
class="math inline">\(n,(n-1),(n-2)\)</span>互质，我们直接乘起来他们三个就好</p>
<p>n如果为偶数，那么显然<span
class="math inline">\(n,(n-2)\)</span>存在公约数2，我们就考虑往后面挪一个，换成<span
class="math inline">\(n-3\)</span></p>
<p>但是如果n本身就是三的倍数怎么办？</p>
<p>那么我们就把n变成<span
class="math inline">\(n-1\)</span>(奇数)这样<span
class="math inline">\((n-1)\times (n-2)\times
(n-3)\)</span>就是最优解了</p>
<p>那就不如</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ! y ? x : <span class="built_in">gcd</span>(y, x % y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lcm</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * y / <span class="built_in">gcd</span>(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">maxs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i, x;</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &amp; <span class="number">1</span>) <span class="built_in">put</span>(n * (n - <span class="number">1</span>) * (n - <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (! (n % <span class="number">3</span>)) <span class="built_in">put</span>((n - <span class="number">1</span>) * (n - <span class="number">2</span>) * (n - <span class="number">3</span>));</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">put</span>(n * (n - <span class="number">1</span>) * (n - <span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fclose</span>(stdin), <span class="built_in">fclose</span>(stdout);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维题</tag>
      </tags>
  </entry>
  <entry>
    <title>最近公共祖先</title>
    <url>/2020/11/26/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    <content><![CDATA[<p>题目大意:给出一棵树,根为1,每个节点为白/黑,初始时候全都是白色,现在有两种操作,一种是将某个点修改为黑色,一种是查询操作,找到某一个黑色节点y,使得与当前节点x的最近公共祖先的权值最大,输出权值.<span id="more"></span></p>
<p>考虑每次修改点的时候,点对其子树的贡献,所以我们可以遍历求一下</p>
<p>然后这个点子树内的点显然是可能和别的黑点结合的,所以我们再层层递归,随便维护一个最大值就好了.</p>
<p>有两个细节:</p>
<ul>
<li><p>vis数组维护的是当前这个路径是走过.防止出现多次重复走</p></li>
<li><p>work函数巧妙的跳过了当前子树</p></li>
</ul>
<p>其实线段树建立在dfn序上就可以,不必非要与重链长链结合的.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ver[N &lt;&lt; <span class="number">1</span>], nex[N &lt;&lt; <span class="number">1</span>], head[N], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++ cnt] = y;</span><br><span class="line">    nex[cnt] = head[x];</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(head[x] = cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, tot, a[N];</span><br><span class="line"><span class="type">int</span> dfn[N], siz[N], fa[N], vis[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SEGMENTTREE</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> maxv, tag;</span><br><span class="line">&#125;tree[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> yhm_fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x] = ++ tot, siz[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> i, y;</span><br><span class="line">    <span class="keyword">for</span> (i = head[x]; i; i = nex[i])</span><br><span class="line">    &#123;</span><br><span class="line">        y = ver[i];</span><br><span class="line">        <span class="keyword">if</span> (y == yhm_fa) <span class="keyword">continue</span>;</span><br><span class="line">        fa[y] = x;</span><br><span class="line">        <span class="built_in">dfs</span>(y, x);</span><br><span class="line">        siz[x] += siz[y];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = p &lt;&lt; <span class="number">1</span>, r = (p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(tree[p].maxv = <span class="built_in">max</span>(tree[l].maxv, tree[r].maxv));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (! tree[p].tag) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> l = p &lt;&lt; <span class="number">1</span>, r = (p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>, c = tree[p].tag;</span><br><span class="line">    tree[l].maxv = <span class="built_in">max</span>(tree[l].maxv, c), tree[l].tag = <span class="built_in">max</span>(tree[l].tag, c),</span><br><span class="line">    tree[r].maxv = <span class="built_in">max</span>(tree[r].maxv, c), tree[r].tag = <span class="built_in">max</span>(tree[r].tag, c);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(tree[p].tag = <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[p].maxv = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>((p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(<span class="built_in">up</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">updata</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> nl, <span class="type">int</span> nr, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nl &lt;= l &amp;&amp; nr &gt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[p].maxv = <span class="built_in">max</span>(tree[p].maxv, c);</span><br><span class="line">        tree[p].tag = <span class="built_in">max</span>(tree[p].tag, c);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">down</span>(p);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (nl &lt;= mid) <span class="built_in">updata</span>(p &lt;&lt; <span class="number">1</span>, l, mid, nl, nr, c);</span><br><span class="line">    <span class="keyword">if</span> (nr &gt; mid) <span class="built_in">updata</span>((p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>, mid + <span class="number">1</span>, r, nl, nr, c);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(<span class="built_in">up</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> tree[p].maxv;</span><br><span class="line">    <span class="built_in">down</span>(p);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) <span class="keyword">return</span> <span class="built_in">query</span>(p &lt;&lt; <span class="number">1</span>, l, mid, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>((p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>, mid + <span class="number">1</span>, r, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">work</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> son)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[son]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">updata</span>(<span class="number">1</span>, <span class="number">1</span>, n, dfn[x], dfn[x], a[x]);</span><br><span class="line">    <span class="built_in">updata</span>(<span class="number">1</span>, <span class="number">1</span>, n, dfn[x], dfn[son] - <span class="number">1</span>, a[x]);</span><br><span class="line">    <span class="built_in">updata</span>(<span class="number">1</span>, <span class="number">1</span>, n, dfn[son] + siz[son], dfn[x] + siz[x] - <span class="number">1</span>, a[x]);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(<span class="built_in">work</span>(fa[x], x), vis[x] = <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, x, y;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) a[i] = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">add_edge</span>(x, y), <span class="built_in">add_edge</span>(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>), <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> sb[<span class="number">66</span>];</span><br><span class="line">        cin &gt;&gt; (sb + <span class="number">1</span>); x = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span> (sb[<span class="number">1</span>] == <span class="string">&#x27;Q&#x27;</span>) <span class="built_in">put</span>(<span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, dfn[x]));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">work</span>(fa[x], x); vis[x] = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">updata</span>(<span class="number">1</span>, <span class="number">1</span>, n, dfn[x], dfn[x] + siz[x] - <span class="number">1</span>, a[x]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后记:</p>
<p><strong>是一道数据结构与图论结合的好题</strong></p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维题</tag>
        <tag>线段树</tag>
        <tag>树上问题</tag>
      </tags>
  </entry>
  <entry>
    <title>最小差异矩阵</title>
    <url>/2020/10/14/%E6%9C%80%E5%B0%8F%E5%B7%AE%E5%BC%82%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<p>题目大意：有一个<span class="math inline">\(n \times
m\)</span>的矩阵，矩阵的每个位置上可以放置一个数。<span id="more"></span>对于第 i
行，第 i
行的差异定义为该行的最大数和最小数的差。一个矩阵的差异，定义为矩阵中每一行差异的最大值。现在给定
k 个数 v[1..k]，问：从这 k 个数中选 <span class="math inline">\(n\times
m\)</span>个数放入矩阵，能够得到的矩阵的差异最小值是多少。</p>
<p><strong>看到最小值最大，最大值最小，就考虑二分答案</strong></p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> k, n, m, a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">judge</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, pd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i + m - <span class="number">1</span> &lt;= k; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i + m - <span class="number">1</span>] - a[i] &lt;= x)</span><br><span class="line">        &#123;</span><br><span class="line">            ++ pd, i = i + m - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pd &gt;= n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    k = <span class="built_in">read</span>(), n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= k; ++ i) a[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + k + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">1e9</span> + <span class="number">66</span>, mid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">judge</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">put</span>(l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：这次考试期望得分30+30pts，第一题挂了10分</p>
<p>如果说按照期望得分的话，我<strong>貌似</strong>还可以，但是这个期望得分太低</p>
<p>别人都可以切掉第一题，但是我考试时候脑子不知道怎么想的，就是没想到二分答案，我真是个**</p>
<p>这次考试的收获：</p>
<ul>
<li>1.最大值最小，最小之最大，一定一定与二分答案有关</li>
<li>2.会写对拍了，再也不用复制原来的了</li>
</ul>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>树</title>
    <url>/2020/10/22/%E6%A0%91/</url>
    <content><![CDATA[<p>题目大意：现在有一棵树，共 N 个节点。规定: 根节点为 1
号节点，且每个节点有一个点权。<span id="more"></span>现在，有 M
个操作需要在树上完成，每次操作为下列三种之一：1 x a：操作 1，将节点 x
点权增加 a。2 x a：操作 2，将以节点 x 为根的子树中所有点的权值增加 a。3
x：操作 3，查询节点 x 到根节点的路径中所有点的点权和</p>
<p>树剖板子题</p>
<p>细节：开ll，但是尽量不要define int long
long容易超时，空间也可能爆炸</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">66</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line">ll a[N], v[N];</span><br><span class="line"><span class="type">int</span> fa[N], siz[N], son[N], dep[N];</span><br><span class="line"><span class="type">int</span> dfn[N], top[N], tot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SEGMENTTREE</span></span><br><span class="line">&#123;</span><br><span class="line">    ll len, tag, dat;</span><br><span class="line">&#125;tree[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> yhm_fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, y;</span><br><span class="line">    siz[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = head[x]; i; i = nex[i])</span><br><span class="line">    &#123;</span><br><span class="line">        y = ver[i];</span><br><span class="line">        <span class="keyword">if</span> (y == yhm_fa) <span class="keyword">continue</span>;</span><br><span class="line">        fa[y] = x;</span><br><span class="line">        dep[y] = dep[x] + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(y, x);</span><br><span class="line">        siz[x] += siz[y];</span><br><span class="line">        <span class="keyword">if</span> (siz[y] &gt; siz[son[x]]) son[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> yhm_top)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x] = ++ tot, a[tot] = v[x];</span><br><span class="line">    top[x] = yhm_top;</span><br><span class="line">    <span class="keyword">if</span> (! son[x]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(son[x], yhm_top);</span><br><span class="line">    <span class="type">int</span> i, y;</span><br><span class="line">    <span class="keyword">for</span> (i = head[x]; i; i = nex[i])</span><br><span class="line">    &#123;</span><br><span class="line">        y = ver[i];</span><br><span class="line">        <span class="keyword">if</span> (y == fa[x] || y == son[x]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(y, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = p &lt;&lt; <span class="number">1</span>, r = (p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(tree[p].dat = tree[l].dat + tree[r].dat);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = p &lt;&lt; <span class="number">1</span>, r = (p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>; ll c = tree[p].tag;</span><br><span class="line">    <span class="keyword">if</span> (! c) <span class="keyword">return</span>;</span><br><span class="line">    tree[l].tag += c, tree[l].dat += tree[l].len * c;</span><br><span class="line">    tree[r].tag += c, tree[r].dat += tree[r].len * c;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(tree[p].tag = <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[p].len = (r - l + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> (<span class="type">void</span>)(tree[p].dat = a[l]);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>((p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(<span class="built_in">up</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">updata</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> nl, <span class="type">int</span> nr, ll c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nl &lt;= l &amp;&amp; nr &gt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[p].tag += c;</span><br><span class="line">        tree[p].dat += tree[p].len * c;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">down</span>(p);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (nl &lt;= mid) <span class="built_in">updata</span>(p &lt;&lt; <span class="number">1</span>, l, mid, nl, nr, c);</span><br><span class="line">    <span class="keyword">if</span> (nr &gt; mid) <span class="built_in">updata</span>((p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>, mid + <span class="number">1</span>, r, nl, nr, c);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(<span class="built_in">up</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">query</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> nl, <span class="type">int</span> nr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nl &lt;= l &amp;&amp; nr &gt;= r) <span class="keyword">return</span> tree[p].dat;</span><br><span class="line">    <span class="built_in">down</span>(p);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>; ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (nl &lt;= mid) res = <span class="built_in">query</span>(p &lt;&lt; <span class="number">1</span>, l, mid, nl, nr);</span><br><span class="line">    <span class="keyword">if</span> (nr &gt; mid) res += <span class="built_in">query</span>((p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>, mid + <span class="number">1</span>, r, nl, nr);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">query_path</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (top[x] != top[y])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[top[x]] &lt; dep[top[y]]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">        res += <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, dfn[top[x]], dfn[x]);</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dep[x] &lt; dep[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">    res += <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, dfn[y], dfn[x]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;t1.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin), <span class="built_in">freopen</span>(<span class="string">&quot;t1.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    <span class="type">int</span> i, x, y, opt;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) v[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">add_edge</span>(x, y), <span class="built_in">add_edge</span>(y, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>), <span class="built_in">dfs2</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    for (i = 1; i &lt;= n; ++ i) cout &lt;&lt; dfn[i] &lt;&lt; &#x27; &#x27;;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="comment">    for (i = 1; i &lt;= n; ++ i) cout &lt;&lt; son[i] &lt;&lt; &#x27; &#x27;;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="comment">    for (i = 1; i &lt;= n; ++ i) cout &lt;&lt; top[i] &lt;&lt; &#x27; &#x27;;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; &quot;--------------------------------\n&quot;;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        opt = <span class="built_in">read</span>(), x = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>) y = <span class="built_in">read</span>(), <span class="built_in">updata</span>(<span class="number">1</span>, <span class="number">1</span>, n, dfn[x], dfn[x], y);</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">2</span>) y = <span class="built_in">read</span>(), <span class="built_in">updata</span>(<span class="number">1</span>, <span class="number">1</span>, n, dfn[x], dfn[x] + siz[x] - <span class="number">1</span>, y);</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">3</span>) <span class="built_in">put</span>(<span class="built_in">query_path</span>(<span class="number">1</span>, x));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>有趣的家庭菜园</title>
    <url>/2020/11/30/%E6%9C%89%E8%B6%A3%E7%9A%84%E5%AE%B6%E5%BA%AD%E8%8F%9C%E5%9B%AD/</url>
    <content><![CDATA[<p>题目大意:给定一个序列,每次可以交换相邻的两个数字,问交换多少次之后使得序列满足:先递增至最大值再递减.<span id="more"></span></p>
<p>一个结论:交换后形成的以原来位置为元素的序列的逆序对数为最小交换数.</p>
<p>然后贪心:放入一个数字的时候,考虑放在目前最大值的左侧还是右侧.</p>
<p>对于相同的数字,判断一下就行了.</p>
<p>代码没有.<a
href="https://www.luogu.com.cn/problem/AT1218">AT1218</a></p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>树状数组</tag>
        <tag>逆序对</tag>
      </tags>
  </entry>
  <entry>
    <title>树状数组</title>
    <url>/2020/07/08/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p><strong>Single point modification, interval query</strong>
<span id="more"></span> the code is follow <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) x&amp;-x</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N], tree[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">chenge</span> <span class="params">(<span class="type">int</span> x, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt;= n; i += <span class="built_in">lowbit</span>(i))</span><br><span class="line">      tree[i] += val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">ask</span> <span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">   <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> (x) &#123;</span><br><span class="line">      res += tree[x];</span><br><span class="line">      x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">scanf</span> (<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">      <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">      <span class="built_in">chenge</span> (i, a[i]);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">      <span class="type">int</span> opt, x, k;</span><br><span class="line">      <span class="built_in">scanf</span> (<span class="string">&quot;%d%d%d&quot;</span>, &amp;opt, &amp;x, &amp;k);</span><br><span class="line">      <span class="keyword">if</span> (opt == <span class="number">1</span>) <span class="built_in">chenge</span> (x, k);</span><br><span class="line">      <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">ask</span>(k)-<span class="built_in">ask</span>(x<span class="number">-1</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>and the <strong>Interval modification, single point
query</strong></p>
<p>the code is follow:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) x&amp;-x</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, s;</span><br><span class="line"><span class="type">int</span> a[N], tree[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">chenge</span> <span class="params">(<span class="type">int</span> x, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt;= n; i += <span class="built_in">lowbit</span>(i))</span><br><span class="line">      tree[i] += val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">ask</span> <span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">   <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> (x) &#123;</span><br><span class="line">      res += tree[x];</span><br><span class="line">      x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">main</span> () &#123;</span><br><span class="line">   cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">      <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">      <span class="built_in">chenge</span> (i, a[i]-s);</span><br><span class="line">      s = a[i];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">      <span class="type">int</span> opt, x, y, k;</span><br><span class="line">      <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;opt);</span><br><span class="line">      <span class="keyword">if</span> (opt == <span class="number">1</span>) &#123;</span><br><span class="line">         <span class="built_in">scanf</span> (<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;k);</span><br><span class="line">         <span class="built_in">chenge</span> (x, k);</span><br><span class="line">         <span class="built_in">chenge</span> (y+<span class="number">1</span>, -k);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;x), cout &lt;&lt; <span class="built_in">ask</span>(x) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="ps">PS</h4>
<p>1.s must from zero</p>
<p>2.the tree array is so easy!</p>
]]></content>
      <categories>
        <category>学后感</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>校门外的树</title>
    <url>/2020/10/28/%E6%A0%A1%E9%97%A8%E5%A4%96%E7%9A%84%E6%A0%91/</url>
    <content><![CDATA[<p>题目大意：要求给出一个 N 个数的数列，数列中每个数字的范围为 1 到
N，且数列要满足一系列诸如给定区间[Li,Ri]中没有重复数字的要求，问字典序最小的合法方案是什么<span id="more"></span></p>
<p>考虑如何合理的给区间排序，显然是按照左端点升序，左端点一样的情况下右端点降序</p>
<p>如果区间有交集，那么重复的肯定不考虑，然后重新得到一个新的区间</p>
<p>暴力的搞一下就可以了</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> T, n, m, cnt;</span><br><span class="line"><span class="type">int</span> vis[N], res[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yhzhyhm</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> yhzhyhm &amp;x) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (l &lt; x.l) || ((l == x.l) &amp;&amp; r &gt; x.r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;yh[N], num[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">yhm_clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;yh, <span class="number">0</span>, <span class="keyword">sizeof</span> yh);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;num, <span class="number">0</span>, <span class="keyword">sizeof</span> num);</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">    <span class="built_in">memset</span>(res, <span class="number">0</span>, <span class="keyword">sizeof</span> res);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">yhm_func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, tmp;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        yh[i].l = <span class="built_in">read</span>(), yh[i].r = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span> (yh[i].l &gt; yh[i].r) <span class="built_in">swap</span>(yh[i].l, yh[i].r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(yh + <span class="number">1</span>, yh + <span class="number">1</span> + m);</span><br><span class="line">    <span class="type">int</span> maxr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (yh[i].r &lt;= maxr) <span class="keyword">continue</span>;</span><br><span class="line">        num[++ cnt] = yh[i];</span><br><span class="line">        maxr = yh[i].r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= cnt; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (num[i].l &gt; num[i - <span class="number">1</span>].r) <span class="keyword">for</span> (j = num[i].l; j &lt;= num[i].r; ++ j) res[j] = tmp ++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = num[i].l; j &lt;= num[i - <span class="number">1</span>].r; ++ j) vis[res[j]] = i;</span><br><span class="line">            <span class="keyword">for</span> (j = num[i - <span class="number">1</span>].r + <span class="number">1</span>; j &lt;= num[i].r; ++ j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (vis[tmp] == i) tmp ++;</span><br><span class="line">                res[j] = tmp; vis[tmp] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">put</span>(res[i] ? res[i] : <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(<span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (T --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">yhm_clear</span>();</span><br><span class="line">        <span class="built_in">yhm_func</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>武器分配</title>
    <url>/2020/10/01/%E6%AD%A6%E5%99%A8%E5%88%86%E9%85%8D/</url>
    <content><![CDATA[<p>题目大意：有 n 个堡垒排成一排构成了一条防御线。现在需要将 n
个武器放入这 n 个堡垒中，每个
堡垒放一个，每个武器有攻击力和战场贡献值两个属性。 由于这 n
个武器都不是人为操控的，所以会对其某半径内所有单位进行攻击，而这就导
致某些堡垒的互相攻击。现在发现第 i 个堡垒会和第 j
个堡垒互相攻击当且仅当|i-j|&lt;=r，
且攻击力较低的武器和他所在的堡垒会破损。
现在你需要给出一种武器分配方案使得未破损武器的战场贡献值总和最大。为了方便你
只需输出战场贡献值总和的最大值即可。 多组数据(T≤10)，n是5000 <span id="more"></span>
首先不难发现，我们可以给他们按照攻击力的大小排序，会更方便我们后边的状态转移</p>
<p>且，我们还发现，对于一个被钦定的武器，如果发现ta在被钦定的武器里面是第i小的，在所有武器里面是第j小的，那么显然有<span
class="math inline">\(i\times (r+1)\leq
j​\)</span>（最后一个武器除外，因为它<del>最大最透彻</del>所以他一定会被钦定）</p>
<p>然后就可以dp</p>
<p>状态：设<span
class="math inline">\(f[i][j]\)</span>表示决策了前j个武器，其中钦定了i个武器，且第j个武器<strong>必须</strong>被钦定，此时的最大价值</p>
<p>边界：<span class="math inline">\(i\times (r+1)\leq
j||j==n\)</span></p>
<p>转移：</p>
<p>对于不合法的直接<span class="math inline">\(-\infty\)</span>。</p>
<p>合法的：<span
class="math inline">\(f[i][j]=max(f[i-1][k])+val[j](k&lt;j)\)</span></p>
<p>这里的最大值可以用前缀最大值来优化，每次都更新一个或者说是统计一个<span
class="math inline">\(sum[i][j]=max(sum[i][j-1],f[i][j])\)</span></p>
<p>其含义类比f数组</p>
<p>核心代码：来自<a
href="https://www.cnblogs.com/oier/p/9666857.html">ghj1222dalao</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a));</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;r);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i].attack);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i].contribution);</span><br><span class="line"><span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n, cmp);</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0xc0</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line"><span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="built_in">sizeof</span>(sum));</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="comment">//选定了多少武器</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) <span class="comment">//所有武器</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= i * (r + <span class="number">1</span>) || j == n)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = sum[i - <span class="number">1</span>][j - <span class="number">1</span>] + a[j].contribution;</span><br><span class="line">            sum[i][j] = <span class="built_in">max</span>(sum[i][j - <span class="number">1</span>], f[i][j]);</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, f[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动规</tag>
      </tags>
  </entry>
  <entry>
    <title>火花</title>
    <url>/2020/11/24/%E7%81%AB%E8%8A%B1/</url>
    <content><![CDATA[<p>题目大意:给定一棵树,有一些操作.<span id="more"></span>每次操作都是指定一个节点,然后有一个权值k,如果k大于指定节点连的出边,则继续延伸,依次类推,每延伸一条边就加上其贡献.多次在线询问.</p>
<p>暴力.</p>
<p>对每个节点都预处理一下,然后就可以搞出自己以及自己子树内的最大的边权值.顺便求一下权值和就可以了.</p>
<p>对于fa[i] = 1的情况,用前缀和数组和二分查找可做</p>
<p>对于fa[i] = i-1的情况,前缀和后缀和后缀最大值维护一下可做</p>
<p>详见代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span> + <span class="number">66</span>, mod = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ver[N &lt;&lt; <span class="number">1</span>], nex[N &lt;&lt; <span class="number">1</span>], len[N &lt;&lt; <span class="number">1</span>], head[N], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++ cnt] = y;</span><br><span class="line">    nex[cnt] = head[x];</span><br><span class="line">    len[cnt] = z;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(head[x] = cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> T, n, q, res;</span><br><span class="line"><span class="type">int</span> val[N], maxv[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, y;</span><br><span class="line">    <span class="keyword">for</span> (i = head[x]; i; i = nex[i])</span><br><span class="line">    &#123;</span><br><span class="line">        y = ver[i];</span><br><span class="line">        <span class="built_in">dfs</span>(y);</span><br><span class="line">        maxv[x] = <span class="built_in">max</span>(maxv[x], <span class="built_in">max</span>(len[i], maxv[y]));</span><br><span class="line">        val[x] += len[i] + val[y];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v &gt;= maxv[x]) <span class="keyword">return</span> (<span class="type">void</span>)(res += val[x]);</span><br><span class="line">    <span class="type">int</span> i, y;</span><br><span class="line">    <span class="keyword">for</span> (i = head[x]; i; i = nex[i])</span><br><span class="line">    &#123;</span><br><span class="line">        y = ver[i];</span><br><span class="line">        <span class="keyword">if</span> (len[i] &gt; v) <span class="keyword">continue</span>;</span><br><span class="line">        res += len[i];</span><br><span class="line">        <span class="built_in">func</span>(y, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num, cnm[N], sum[N], sam[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, x, z, pos; q = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">sort</span>(cnm + <span class="number">1</span>, cnm + <span class="number">1</span> + num);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= num; ++ i) sum[i] = sum[i - <span class="number">1</span>] + cnm[i];</span><br><span class="line">    <span class="keyword">while</span> (q --)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="built_in">read</span>(), z = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span> (T) x = x ^ (res % mod), z = z ^ (res % mod);</span><br><span class="line">        <span class="keyword">if</span> (x != <span class="number">1</span>) <span class="built_in">put</span>(<span class="number">0</span>), res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pos = <span class="built_in">upper_bound</span>(cnm + <span class="number">1</span>, cnm + <span class="number">1</span> + num, z) - cnm;</span><br><span class="line">            res = sum[pos - <span class="number">1</span>] - sum[<span class="number">1</span> - <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">put</span>(res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, x, z, pos; q = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = num; i &gt;= <span class="number">1</span>; -- i) maxv[i] = <span class="built_in">max</span>(maxv[i + <span class="number">1</span>], cnm[i]), sam[i] = sam[i + <span class="number">1</span>] + cnm[i]; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= num; ++ i) sum[i] = sum[i - <span class="number">1</span>] + cnm[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q --)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="built_in">read</span>(), z = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span> (T) x = x ^ (res % mod), z = z ^ (res % mod);</span><br><span class="line">        <span class="keyword">if</span> (x == n) <span class="built_in">put</span>(<span class="number">0</span>), res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (z &gt;= maxv[x]) <span class="built_in">put</span>(sam[x]), res = sam[x];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                pos = x;</span><br><span class="line">                <span class="keyword">while</span> (z &gt;= cnm[pos]) ++ pos; -- pos;</span><br><span class="line"><span class="comment">//				cout &lt;&lt; &quot;pos---&gt;&quot; &lt;&lt; pos &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">                res = sum[pos] - sum[x - <span class="number">1</span>];</span><br><span class="line">                <span class="built_in">put</span>(res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="built_in">read</span>(), x, y, z, <span class="built_in">pd</span>(<span class="number">0</span>), <span class="built_in">sb</span>(<span class="number">0</span>);</span><br><span class="line">    n = <span class="built_in">read</span>(), T = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        y = <span class="built_in">read</span>(), z = <span class="built_in">read</span>();</span><br><span class="line">        cnm[++ num] = z;</span><br><span class="line">        <span class="built_in">add_edge</span>(y, i, z);</span><br><span class="line">        <span class="keyword">if</span> (y != <span class="number">1</span>) pd = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (y != i - <span class="number">1</span>) sb = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">if</span> (! pd)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">func1</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (! sb)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">func2</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    q = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span> (q --)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="built_in">read</span>(), z = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span> (T) x = x ^ (res % mod), z = z ^ (res % mod);</span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">func</span>(x, z);</span><br><span class="line">        <span class="built_in">put</span>(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后记:</p>
<p>第一次暴力压正解</p>
<p>跑的比正解都快,开心!</p>
<p>运气吧</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>乱搞</tag>
      </tags>
  </entry>
  <entry>
    <title>炸弹</title>
    <url>/2020/10/16/%E7%82%B8%E5%BC%B9/</url>
    <content><![CDATA[<p>题目大意：有𝑛个炸弹分布在一条数轴上。现在需要玩家以一定的能量引爆某一个炸弹，而炸弹爆炸会引起连锁
反应导致更多的炸弹爆炸。<span id="more"></span>炸弹爆炸时会携带能量𝑋，可以引爆和他距离≤
𝑋的所有炸弹。当一个炸弹被能量𝑋的爆炸引爆时，该炸弹会带<span
class="math inline">\(⌊\dfrac {2x}
3⌋\)</span>(下取整)的能量。玩家可以设置第一个引爆的炸弹的能量，现在请问，如果想引爆所有炸弹，第一个引爆的炸弹的能量最少是多少呢？数据量1e6，开两秒</p>
<p>一眼看上去就像是二分</p>
<p>考场上的二分写爆炸了，sb样例，太水了</p>
<p>正解是单调队列优化dp</p>
<p><span class="math display">\[f_i = min(max(\dfrac {2f_j}
3,a[i]-a[j])),(j&lt;i)\]</span></p>
<p>可得60分（裸的二分也可以60分）</p>
<p>裸的二分是来二分这个能量，然后放回原数组中<span
class="math inline">\(O(n^2)\)</span>判断（每一个位置都作为引爆的起点）</p>
<p>观察发现，我们使得起点在中间的某一段选取，显然要比在两端点选取要更优</p>
<p>并且还得到一个显然的结论，对于一个选定的端点，在其两侧是具有单调性的</p>
<p>有单调性就意味着二分是合理的</p>
<p>然后就可以在二分里面套一个二分</p>
<p>复杂度<span class="math inline">\(O(log^2n)\)</span></p>
<p>至此，一个暴力的做法，成功把一个单调队列优化dp的题目卡了过去</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = n;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> s = mid, now = p, res1 = <span class="number">1</span>, res2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = s - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i --)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[s] - a[i] &gt; now)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (s == i + <span class="number">1</span>) &#123;res1 = <span class="number">0</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;s = i + <span class="number">1</span>, now = <span class="number">2</span> * now / <span class="number">3</span>, ++ i;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s = mid, now = p;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = s + <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] - a[s] &gt; now)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (s == i - <span class="number">1</span>) &#123;res2 = <span class="number">0</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;s = i - <span class="number">1</span>, now = <span class="number">2</span> * now / <span class="number">3</span>, -- i;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (res1 &amp;&amp; res2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (! res1 &amp;&amp;! res2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (! res1) r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) a[i] = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = a[n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>物理题</title>
    <url>/2020/10/24/%E7%89%A9%E7%90%86%E9%A2%98/</url>
    <content><![CDATA[<p>题目大意：现在，在理想的光滑平面上放置着一个物块。给定了
个加速阶段，每种式包含两个属性，分别为加速度与
能够维持这个加速度的时间。<span id="more"></span>只有阶段结束后才能切换到下个阶段，切换的过程并不会消耗时间。数据保证加速度和时间都是正数。众所周知，物理⽼师⼀定不会轻易放过我们。他想知道，假定能任意安排阶段之间的顺序，这个物块的可能最大位移与按输入顺序进入加速的位移之差值是多少。也就是说，你需要先找到种加速的顺序使得物块位移最大，再用这个最大值减去输入顺序加速的位移，并输出这个差值</p>
<p>这个题目太简单了，贪心推推式子就出来了</p>
<p>显然得到加速度从大到小排序是最优的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, v_0;</span><br><span class="line"><span class="type">double</span> st, ed;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yhzhyhm</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, t;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> yhzhyhm &amp;x) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; x.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;yh[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i; n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) yh[i].a = <span class="built_in">read</span>(), yh[i].t = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        st += v_0 * yh[i].t + <span class="number">0.5</span> * yh[i].a * yh[i].t * yh[i].t;</span><br><span class="line">        v_0 += yh[i].a * yh[i].t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(yh + <span class="number">1</span>, yh + <span class="number">1</span> + n);</span><br><span class="line">    </span><br><span class="line">    v_0 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        ed += v_0 * yh[i].t + <span class="number">0.5</span> * yh[i].a * yh[i].t * yh[i].t;</span><br><span class="line">        v_0 += yh[i].a * yh[i].t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.1lf\n&quot;</span>, ed - st);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>死亡鸽者</title>
    <url>/2020/10/14/%E6%AD%BB%E4%BA%A1%E9%B8%BD%E8%80%85/</url>
    <content><![CDATA[<p>题目大意：现在有<em>N</em>座城市排成一排，
死亡鸽者会从第一座城市一直走到最后一座城市。<span id="more"></span>
每个城市都有一个数<span class="math inline">\(a_i\)</span>，
每次死亡鸽者可以选择取走或者不取走这个数，
但想要取走这个数的话要求这个数必须是所有已经取走的数的倍数或者约数。现在问死亡鸽者从第一座城市走到最后一座城市的过程中，
最多取走多少个数。</p>
<p>1e6的数据量，很容易的想到开个桶与筛法</p>
<p>我们设<span
class="math inline">\(f[i]\)</span>表示以i为结尾的序列最长有多长，显然，<span
class="math inline">\(f[i]\)</span>是有i的比i小的数转移过来的，</p>
<p>现在取出的是i，那么之后的都是i的倍数</p>
<p><span class="math inline">\(f[k\times i] = max(f[i]+cnt[k\times
i])\)</span></p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> f[N], cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">read</span>();</span><br><span class="line">        ++ cnt[x], ++ f[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">1000000</span>; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (f[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (f[i] &gt; res) res = f[i];</span><br><span class="line">            <span class="keyword">for</span> (j = i + i; j &lt;= <span class="number">1000000</span>; j += i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (cnt[j] &amp;&amp; f[i] + cnt[j] &gt; f[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    f[j] = f[i] + cnt[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">put</span>(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<p>这次考试期望得分是100+20+20pts，但实际得分10+20+20pts</p>
<p>正解写挂了，但是我暴力分数拿满了，我知道我有进步，暴力分数拿满意味着，至少我没有亏负两道题</p>
<p>但是第一题正解挂了九十分就很烦人</p>
<p>我要继续努力，在保证暴力分数拿满的基础上，签到题目必须切掉</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维题</tag>
      </tags>
  </entry>
  <entry>
    <title>玖月末反思</title>
    <url>/2020/09/30/%E7%8E%96%E6%9C%88%E6%9C%AB%E5%8F%8D%E6%80%9D/</url>
    <content><![CDATA[<p>玖月将尽， 写一份月末反思</p>
<span id="more"></span>
<p>今天考试了，三道搜索题目！！！三道！！！</p>
<p>反思自己，搜索题目必须捋清楚思路再动手，不要写一半想一会</p>
<p>如果有时候发现对某个变量无法记录，如果空间允许的话，把状态或者数组设成两维，或许会有新的思路</p>
<p>给自己做每一道题目规划好时间，对于任何题目（<del>如果不是傻逼题</del>），写暴力不要<strong>浪费</strong>太多时间，思路清楚之后再去写</p>
<p>并且写暴力的时候不要一直担心正解，暴力就是暴力，你管他T不T的，能有分数不久得了，不要患得患失</p>
<p>在此约定，上来先给十分钟想正解，正解无果，然后花最多三十分钟去写暴力，然后剩下二十分钟去想正解</p>
<p>一般代码撑死五分钟就可以写完，但是思路不好想，这样，一道题撑死一个1h，即使不会写也要放弃</p>
<p>对应到各个题目</p>
<ul>
<li>数学题与数据结构</li>
</ul>
<p>如果可以一下正解，就写，如果不会，写暴力，一般都很好写的，速度写！不要把时间耽误在不需要脑子的地方</p>
<p><strong>正解最后想</strong></p>
<ul>
<li>贪心与dp</li>
</ul>
<p>先画较多时间去想正解，如果不会，果断开始打暴力，一般贪心的暴力与正解都是渐进的，dp除外</p>
<p>如果发现是可以优化的dp，先不要去<strong>想</strong>优化！！！</p>
<p>写朴素dp，最后再去考虑优化</p>
<ul>
<li>字符串</li>
</ul>
<p>题型无外乎Trie，kmp，ac自动机，不可能会T，最多是wa</p>
<ul>
<li>图论</li>
</ul>
<p>如果可以一下正解，就写，如果不会，
<strong>不要企图去做满分！！！</strong></p>
<p>图论题目的特殊性质给的很足，什么菊花图，链，等等，就写暴力分</p>
<p>以后怎么办？</p>
<ul>
<li><strong>数据结构无用论</strong>！</li>
<li><strong>数据结构无用论</strong>！</li>
<li><strong>数据结构无用论</strong>！</li>
<li>概率与期望</li>
<li>贪心与dp永远是王道</li>
<li>字符串做思维题</li>
<li>图论做真题，所有的题目都逃不开noip出的题目的模型</li>
<li>心态要稳，规定时间到了，就换下一个题</li>
</ul>
<p>冲冲冲！</p>
<p><strong>尽人事，听天命</strong></p>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>反思</tag>
      </tags>
  </entry>
  <entry>
    <title>玩游戏</title>
    <url>/2020/10/05/%E7%8E%A9%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<p>题目大意：Alice 和 Bob 在玩游戏。</p>
<span id="more"></span>
<p>数轴上有 𝑛 枚石子（ 𝑛 为偶数），每个位置上至多只有一枚石子。Alice 和
Bob 轮流把某个石子取走，Alice 先手，直至数轴上只剩下两枚石子。Alice
想要让这两枚石子的距离尽量小，而 Bob
则想让它们之间的距离尽量大。在双方都进行完美操作的情况下，最终剩下的两枚石子之间的距离会是多少呢？n属于1e5</p>
<p>最后一定只会剩下两个石头，其中女孩为了确保两个石头之间的距离最小，所以一定只会拿掉除了这两个石头之外的石头，而男孩为了确保两个石头之间的距离尽可能大，一定会拿掉这两个石头中间的石头</p>
<p>其中n为偶数，所以男孩拿的时候，一定会是中位数，就这样，我们只需要枚举最后剩下哪两个石头就好了，并且由上面的推理可以发现，这两个石头一定差着n/2，O(n)扫一遍就出结果了</p>
<p>我原来的思路：女孩一定是从两边拿石头，男孩一定是从拿中间距离最小的两个石头（错误）</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pr;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">66</span>, inf = <span class="number">214748364</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) a[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n/<span class="number">2</span>; ++ i) res = <span class="built_in">min</span>(res, a[i + n/<span class="number">2</span>] - a[i]);</span><br><span class="line">    <span class="built_in">put</span>(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维题</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈2048</title>
    <url>/2020/08/20/%E6%B5%85%E8%B0%882048/</url>
    <content><![CDATA[<p><strong>PS</strong>：还没有更新完，日后会陆续更新，并配上彩图，方便理解！</p>
<p>关于2048的一些心得 <span id="more"></span>
本人比较菜（其实是没有太多时间去玩了），只玩到了4096分，现在把自己的一些技巧分享给大家</p>
<p>（本文需要前置知识：分治，贪心，递归）</p>
<h1 id="整体思路">整体思路</h1>
<p>首先观察这个图，是一个16个格子的矩阵，失败的终点是无法再合并</p>
<p>考虑合并的规则<span
class="math inline">\(2\;to\;4,4\;to\;8,8\;to\;16\)</span>,依次类推，可以发现，可以用<span
class="math inline">\(2^{x-1}\)</span>可以得到<span
class="math inline">\(2^x\)</span>其中<span class="math inline">\((1
\leq x)\)</span></p>
<p>而游戏所能获得的分值也随着合并之后所得到的数的大小而递增</p>
<p>我们考虑如何最优化合并，以得到2048为例子，想要得到2048(<span
class="math inline">\(2^{11}\)</span>)，就要通过两个1024(<span
class="math inline">\(2^{10}\)</span>)来合并得到</p>
<p>而每一个1024(<span
class="math inline">\(2^{10}\)</span>)需要两个512(<span
class="math inline">\(2^9\)</span>)来合并，以此类推，我们发现，必须是<span
class="math inline">\(2^{max-1}\)</span>与<span
class="math inline">\(2^{max-2}\)</span>挨在一起</p>
<p>这样我们只需要得到一个<span
class="math inline">\(2^{max-2}\)</span>就可以合并得到<span
class="math inline">\(2^{max}\)</span></p>
<p>在此我规定把当前最大值<span
class="math inline">\(2^{max-1}\)</span>堆在矩阵的右下方，把当前次大值<span
class="math inline">\(2^{max-2}\)</span>紧挨着最大值放（也就是矩阵的最后一行从右往左数，第二个位置，因为第一个位置被<span
class="math inline">\(2^{max-1}\)</span>放了）</p>
<p>我们考虑在<strong>除了右下方的地方</strong>进行乱搞，得到<span
class="math inline">\(2^{max-2}\)</span>，然后就可以进行合并<span
class="math inline">\(2^{max-2}\times2\;to\;2^{max-1},2^{max-1}\times2\;to\;2^{max}\)</span></p>
<p>至此，整体思路分析完毕。</p>
<p>上图：</p>
<p><img
src="https://pic.downk.cc/item/5f8124ca1cd1bbb86b96e0ba.png" /></p>
<h1 id="具体细节">具体细节</h1>
<h3 id="首先明白移位的意义是什么">首先明白移位的意义是什么</h3>
<p>移位并不是瞎动，每一步都有每一步的作用，每一步都要顾全大局，每一步都是为了合并出更大的max而做基础。</p>
<h3 id="考虑具体每一步怎么走">考虑具体每一步怎么走</h3>
<p>开局随便玩，尽量把最大值往右下方堆积起来，闭着眼睛几乎都可以完成的事情。</p>
<p>我们希望的是当前的最大值永远在最下最右的地方，所以每一步都要保证最大值没有移位</p>
<p>也就是说，<strong>慎用或者可以的话，不要用左移和上移，考虑左移的影响，极其有可能是你当前的最大值，到了属于当前次大值的位置，然后在本属于最大值的位置，冒出了一个2；考虑上移的影响，极其有可能是在你最大值的下方新冒出来的2占据了当前最大值的位置，如果出现以上两种情况，基本上是GG了，对于前者有一种补救办法叫做“围魏救赵”，文章末尾会提到</strong></p>
<p>为什么要上移？</p>
<p>假如说你把最下层的8个格子刚好占满，且刚好无法合并，并且没有多余的格子，这时候你无论左移还是右移都是无效的，你只能上移（有一次我最底下依次是<span
class="math inline">\({4096\;2048\;1024\;512\;256\;128\;64\;32}\)</span>，但是没有办法，不得不上移，于是我就GG了）</p>
<p>为什么要左移？</p>
<ul>
<li>1.最后一行没有补齐(也就是有空位)，并且当前你再怎么右移也无法进行合并，因此就需要左移（这就是上文提到的风险情况）</li>
<li>2.如果最后一行是补齐的，并且左移之后，<strong>你会合并某些项数，意味着你在合并之后，会出现空位，也就有可能成为上文提到的风险情况，有个技巧叫“延迟合并”在大多数情况下会避免这种合并之后出现空位乃至GG的尴尬，文章的末尾会提到这些的</strong></li>
</ul>
<p>每次移动，尽量下移，这样大多数情况下可以保证你不需要上移，尽量右移，保证你不需要左移</p>
<p>如果在你可以下移可以右移的情况下，大多数选择尽量下移，因为上移可能带来的风险更大，且补救成功的概率为零</p>
<p>相比左移带来的影响，就要小一些，大多数情况可以补救成功（在最大值小于等于1024的时候概率最大）.</p>
<p>“围魏救赵”：</p>
<p>设当前的右下方的的数为<span class="math inline">\(x\)</span></p>
<p>考虑把当前的<span
class="math inline">\(x\)</span>培养成当前最大值，就可以和<span
class="math inline">\(x\)</span>右边的最大值进行合并</p>
<p>于是我们只能在靠右的一两列作为<span
class="math inline">\(x\)</span>的“移位储备资源库”，每一次都必须使得<span
class="math inline">\(x\)</span>上面的数和当前右下方<span
class="math inline">\(x\)</span>一样，然后可以合并</p>
<p>合并时保持如此原则：能向右合并，尽量不向左；能向下合并，尽量不向上</p>
<p>当能向右和向下的时候，我们选择向右，因为向下有概率和底层<span
class="math inline">\(x\)</span>旁边的数进行合并，而不是<span
class="math inline">\(x\)</span>（注意区分与上文的区别）</p>
<p>“延迟合并”：</p>
<p>在当前这一行可以合并的时候，我们先不去左移或者右移，先尽量下移，使我们有足够多的储备合并块（就是一些零散的2,4,8之类的），然后再左右移合并，可以大大降低自己出锅的概率，具体原理读者自证不难</p>
<p>关于配图，日后会补上的</p>
<h1 id="结语">结语</h1>
<p>因为2048每次移位后出现的2与4都是随机化的，因此无法设计出一种完美无缺的算法，达到<span
class="math inline">\(2^{16}\)</span></p>
<p>只能通过一些技巧来规避，但是无法避免失误，难免会在你成功前的一瞬间，出现一个不速之客“2”，使你顿时GG。</p>
<p>于是你就很抓狂，恼怒，生气！</p>
<p>而游戏所吸引我们的，不正是如此吗？</p>
]]></content>
      <categories>
        <category>mess</category>
      </categories>
      <tags>
        <tag>game</tag>
      </tags>
  </entry>
  <entry>
    <title>生日</title>
    <url>/2020/10/29/%E7%94%9F%E6%97%A5/</url>
    <content><![CDATA[<p>题目大意：今天是牛牛的生日，牛牛请了他的好朋友们一起过生日，生日必不可少的环节当然就是吃蛋糕啦。<span id="more"></span>由于有n个人来参加牛牛的生日，牛牛需要给n个人分蛋糕，牛牛有2种操作C
l r x 将[l,r]的人的蛋糕数改成x(1 &lt;= x &lt;= k)P l r
查询[l,r]中有多少种不同的蛋糕数牛牛总共执行了m次这样的操作，请输出所有的询问操作</p>
<p>线段树裸体</p>
<p>对每一个位置维护三十个颜色，重点在查询的时候，不要重复了</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">33</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SEGMENTTREE</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r, dat, tag; <span class="type">bool</span> col[<span class="number">33</span>];</span><br><span class="line"><span class="comment">//dat:有多少个不同的颜色</span></span><br><span class="line"><span class="comment">//tag:我这个区间应该是几</span></span><br><span class="line"><span class="comment">//col:我的区间内都有哪些颜色出现过</span></span><br><span class="line">&#125;tree[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = p &lt;&lt; <span class="number">1</span>, r = (p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>, i, <span class="built_in">c</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= k; ++ i) tree[p].col[i] = (tree[l].col[i] || tree[r].col[i]) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= k; ++ i) c += tree[p].col[i] ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;c--&gt;&quot; &lt;&lt; c &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(tree[p].dat = c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = p &lt;&lt; <span class="number">1</span>, r = (p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>, c = tree[p].tag, i;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= k; ++ i) tree[l].col[i] = tree[r].col[i] = <span class="literal">false</span>;</span><br><span class="line">    tree[l].col[c] = tree[r].col[c] = <span class="literal">true</span>;</span><br><span class="line">    tree[l].tag = tree[r].tag = c;</span><br><span class="line">    tree[l].dat = tree[r].dat = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(tree[p].tag = <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[p].l = r, tree[p].r = r, tree[p].tag = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> (<span class="type">void</span>)(tree[p].dat = <span class="number">1</span>, tree[p].col[<span class="number">0</span>] = <span class="literal">true</span>);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>((p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(<span class="built_in">up</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">updata</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> nl, <span class="type">int</span> nr, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nl &lt;= l &amp;&amp; nr &gt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[p].tag = c, tree[p].dat = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">30</span>; ++ i) tree[p].col[i] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">void</span>)(tree[p].col[c] = <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">down</span>(p);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (nl &lt;= mid) <span class="built_in">updata</span>(p &lt;&lt; <span class="number">1</span>, l, mid, nl, nr, c);</span><br><span class="line">    <span class="keyword">if</span> (nr &gt; mid) <span class="built_in">updata</span>((p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>, mid + <span class="number">1</span>, r, nl, nr, c);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(<span class="built_in">up</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> nl, <span class="type">int</span> nr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nl &lt;= l &amp;&amp; nr &gt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= k; ++ i) (! vis[i] &amp;&amp; tree[p].col[i]) ? ++ c, vis[i] = <span class="literal">true</span> : c += <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">down</span>(p);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (nl &lt;= mid) res = <span class="built_in">query</span>(p &lt;&lt; <span class="number">1</span>, l, mid, nl, nr);</span><br><span class="line">    <span class="keyword">if</span> (nr &gt; mid) res += <span class="built_in">query</span>((p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>, mid + <span class="number">1</span>, r, nl, nr);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, x, y, z; <span class="type">char</span> opt;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>(), k = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; opt;</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span></span><br><span class="line">            x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>(), z = <span class="built_in">read</span>();</span><br><span class="line">            <span class="keyword">if</span> (x &gt; y) <span class="built_in">swap</span>(x, y);</span><br><span class="line">            <span class="built_in">updata</span>(<span class="number">1</span>, <span class="number">1</span>, n, x, y, z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//cin &gt;&gt; x &gt;&gt; y;</span></span><br><span class="line">            x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>();</span><br><span class="line">            <span class="keyword">if</span> (x &gt; y) <span class="built_in">swap</span>(x, y);</span><br><span class="line">            <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">            <span class="built_in">put</span>(<span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, x, y));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>游走</title>
    <url>/2020/11/18/%E6%B8%B8%E8%B5%B0/</url>
    <content><![CDATA[<p>大致题意:给你一个有向无环图,有重边,每次可以选择任何一个点作为起点和重点,路径长度记为经过路径条数求路径长度的期望<span id="more"></span></p>
<p>显然是一道期望题目,根据期望定义,我们知道期望等于总价值除以概率也就是次数</p>
<p>然后就是在DAG上随便dp一下就出来了,我们设<span
class="math inline">\(f_i\)</span>和<span
class="math inline">\(num_i\)</span>分别表示到i为止的长度和路径条数</p>
<p>代码如下: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">66</span>, mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ver[N], nex[N], head[N], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++ cnt] = y;</span><br><span class="line">    nex[cnt] = head[x];</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(head[x] = cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, len, sum;</span><br><span class="line"><span class="type">int</span> deg[N], f[N], num[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">ksm</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ret</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, x, y; queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; num[i] = <span class="number">1</span>, ++ i) <span class="keyword">if</span> (! deg[i]) q.<span class="built_in">push</span>(i);</span><br><span class="line">    <span class="keyword">while</span> (! q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        x = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (i = head[x]; i; i = nex[i])</span><br><span class="line">        &#123;</span><br><span class="line">            y = ver[i];</span><br><span class="line">            num[y] = (num[x] + num[y]) % mod, f[y] = (f[y] + f[x] + num[x]) % mod;</span><br><span class="line">            <span class="keyword">if</span> (! -- deg[y]) q.<span class="built_in">push</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) len = (len + f[i] % mod) % mod, sum = (sum + num[i] % mod) % mod;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, x, y;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">add_edge</span>(x, y);</span><br><span class="line">        ++ deg[y];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">topsort</span>();</span><br><span class="line">    <span class="built_in">put</span>(len * <span class="built_in">ksm</span>(sum, mod - <span class="number">2</span>) % mod);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>期望</tag>
      </tags>
  </entry>
  <entry>
    <title>生日礼物</title>
    <url>/2020/12/01/%E7%94%9F%E6%97%A5%E7%A4%BC%E7%89%A9/</url>
    <content><![CDATA[<p>题目大意:将彩带考虑为x轴，每一个彩珠有一个对应的坐标(即位置)。某些坐标上可以没有彩珠，但多个彩珠也可以出现在同一个位置上.为了让礼物彩带足够漂亮，希望这一段彩带中能包含所有种类的彩珠,彩带尽可能短(彩带的长度即为彩带开始位置到结束位置的位置差)求最短彩带长度.<span id="more"></span></p>
<p>用队列来维护.</p>
<p>几乎是一眼题目.实在没有什么思维量,碰到新的就压入,判断是否已经齐全了,然后就不断弹弹弹.</p>
<p>小细节:统计答案的时候,不是r-l,而是q[r].id - q[l].id</p>
<p>比如只有两个珠子1,2,但是他们分别在下标10,100处,如果统计r-l则是1,但是若统计下标的话则为90.天壤之别!</p>
<p>代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k, col, cnt, l, r;</span><br><span class="line"><span class="type">int</span> mp[<span class="number">66</span>], <span class="built_in">res</span>(<span class="number">12345678910</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yhzhyhm</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> id, val;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> yhzhyhm &amp;x) <span class="type">const</span> &#123;<span class="keyword">return</span> id &lt; x.id;&#125;</span><br><span class="line">&#125;yh[N], q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, x, y;</span><br><span class="line">    n = <span class="built_in">read</span>(), k = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= k; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">while</span> (x --) y = <span class="built_in">read</span>(), yh[++ cnt].id = y, yh[cnt].val = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(yh + <span class="number">1</span>, yh + <span class="number">1</span> + n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        q[++ r] = yh[i], ++ mp[yh[i].val];</span><br><span class="line">        <span class="keyword">if</span> (mp[yh[i].val] == <span class="number">1</span>) ++ col;</span><br><span class="line">        <span class="keyword">while</span> (col == k)</span><br><span class="line">        &#123;</span><br><span class="line">            res = <span class="built_in">min</span>(res, q[r].id - q[l].id);</span><br><span class="line">            -- mp[yh[l].val];</span><br><span class="line">            <span class="keyword">if</span> (! mp[yh[l].val]) -- col;</span><br><span class="line">            ++ l;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">put</span>(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后记:</p>
<p>细节决定成败</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>思维题</tag>
      </tags>
  </entry>
  <entry>
    <title>画家</title>
    <url>/2020/10/16/%E7%94%BB%E5%AE%B6/</url>
    <content><![CDATA[<p>题目大意：一个 <span class="math inline">\(n\times
m\)</span>大小的矩形，
k种颜色，每种用且只用一次一种颜色给一个连续的子矩阵上色，给出最后的形态，求有多少种颜色可能是第一次使用的。<span id="more"></span></p>
<p>考虑问题反面，求有多少种不可能第一次使用的，显然就是在一个矩形里面，出现了别的颜色，然后我们可以记录出每一种颜色的上限下限，左右边界，<span
class="math inline">\(n^3​\)</span>的暴力查找</p>
<p>貌似还可以用差分来优化，但是我不会</p>
<p>注意特判一种情况：n = 1, m = 1</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, k, res;</span><br><span class="line"><span class="type">int</span> a[<span class="number">320</span>][N];</span><br><span class="line"><span class="type">int</span> u[N], d[N], l[N], r[N];</span><br><span class="line"><span class="type">int</span> has[N], cnt[N], used[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, col;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>(), res = k = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= m) <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= m; ++ j) a[i][j] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= m; ++ j) a[j][i] = <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">swap</span>(n, m);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> &amp;&amp; m == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">1</span>][<span class="number">1</span>] == <span class="number">0</span>) <span class="built_in">put</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="built_in">put</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">put</span>(k - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(u, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> u), <span class="built_in">memset</span>(l, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> l);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = m; j &gt;= <span class="number">1</span>; j --)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = a[i][j];</span><br><span class="line">            has[x] = <span class="number">1</span>;</span><br><span class="line">            u[x] = <span class="built_in">min</span>(u[x], i);</span><br><span class="line">            d[x] = <span class="built_in">max</span>(d[x], i);</span><br><span class="line">            l[x] = <span class="built_in">min</span>(l[x], j);</span><br><span class="line">            r[x] = <span class="built_in">max</span>(r[x], j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cnt[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (col = <span class="number">1</span>; col &lt;= k; col ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (! has[col]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = u[col]; i &lt;= d[col]; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = l[col]; j &lt;= r[col]; j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i][j] != col &amp;&amp; ! cnt[a[i][j]])</span><br><span class="line">                    cnt[a[i][j]] = <span class="number">1</span>, --res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">put</span>(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>理想的正方形</title>
    <url>/2020/11/27/%E7%90%86%E6%83%B3%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2/</url>
    <content><![CDATA[<p>题目大意:有一个<span class="math inline">\(a \times
b\)</span>的整数组成的矩阵，现请你从中找出一个<span
class="math inline">\(n \times
n\)</span>的正方形区域，使得该区域所有数中的最大值和最小值的差最小。<span id="more"></span></p>
<p>数据结构</p>
<p>单调队列首先对每一行维护一个最大值与最小值.然后再对最大值和最小值,维护一个列的最大值最小值.</p>
<p>相当于把原来的一块<span class="math inline">\(n \times
n\)</span>的矩阵缩成了一个最大/小值</p>
<p>代码如下: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">66</span>, inf = <span class="number">1234567891011</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, lim, lin, ron, res = inf, a[N][N];</span><br><span class="line"><span class="type">int</span> q[N], Q[N];</span><br><span class="line"><span class="type">int</span> rmax[N][N], rmin[N][N], cmax[N][N], cmin[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, l, r, L, R;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>(), lim = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= m; ++ j) a[i][j] = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        l = <span class="number">1</span>, r = <span class="number">0</span>, <span class="built_in">memset</span>(q, <span class="number">0</span>, <span class="keyword">sizeof</span> q);</span><br><span class="line">        L = <span class="number">1</span>, R = <span class="number">0</span>, <span class="built_in">memset</span>(Q, <span class="number">0</span>, <span class="keyword">sizeof</span> Q);</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r &amp;&amp; q[l] + lim &lt;= j) ++ l;</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r &amp;&amp; a[i][q[r]] &lt; a[i][j]) -- r;</span><br><span class="line">            q[++ r] = j;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= lim) rmax[i][++ rmax[i][<span class="number">0</span>]] = a[i][q[l]];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (L &lt;= R &amp;&amp; Q[L] + lim &lt;= j) ++ L;</span><br><span class="line">            <span class="keyword">while</span> (L &lt;= R &amp;&amp; a[i][Q[R]] &gt; a[i][j]) -- R;</span><br><span class="line">            Q[++ R] = j;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= lim) rmin[i][++ rmin[i][<span class="number">0</span>]] = a[i][Q[L]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    lin = m - lim + <span class="number">1</span>, ron = n - lim + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= lin; ++ j)</span><br><span class="line">    &#123;</span><br><span class="line">        l = <span class="number">1</span>, r = <span class="number">0</span>, <span class="built_in">memset</span>(q, <span class="number">0</span>, <span class="keyword">sizeof</span> q);</span><br><span class="line">        L = <span class="number">1</span>, R = <span class="number">0</span>, <span class="built_in">memset</span>(Q, <span class="number">0</span>, <span class="keyword">sizeof</span> Q);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r &amp;&amp; q[l] + lim &lt;= i) ++ l;</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r &amp;&amp; rmax[q[r]][j] &lt; rmax[i][j]) -- r;</span><br><span class="line">            q[++ r] = i;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= lim) cmax[++ cmax[<span class="number">0</span>][j]][j] = rmax[q[l]][j];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (L &lt;= R &amp;&amp; Q[L] + lim &lt;= i) ++ L;</span><br><span class="line">            <span class="keyword">while</span> (L &lt;= R &amp;&amp; rmin[Q[R]][j] &gt; rmin[i][j]) -- R;</span><br><span class="line">            Q[++ R] = i;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= lim) cmin[++ cmin[<span class="number">0</span>][j]][j] = rmin[Q[L]][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= ron; ++ i) <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= lin; ++ j) res = <span class="built_in">min</span>(res, cmax[i][j] - cmin[i][j]);</span><br><span class="line">    <span class="built_in">put</span>(res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>后记:</p>
<p>单调队列神仙题!</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵</title>
    <url>/2020/10/07/%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<p>题目大意：小凯最近得到了一个数字矩阵。就如他喜欢一个序列的上升子序列一样，他对于上升子矩阵也很感兴趣。上升矩阵是指每行每列都严格上升的矩阵。现在他想要知道，他手里的矩阵有多少个满足条件的子矩阵。</p>
<span id="more"></span>
<p>坑</p>
<p>用类似单调栈的东西来维护，本质我也不太明白</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e3</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, res;</span><br><span class="line"><span class="type">int</span> a[N][N], up[N], ul[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> w, h;</span><br><span class="line"><span class="comment">//constructot</span></span><br><span class="line">    <span class="built_in">S</span> (<span class="type">int</span> W = <span class="number">0</span>, <span class="type">int</span> H = <span class="number">0</span>) : <span class="built_in">w</span>(W), <span class="built_in">h</span>(H) &#123;&#125;</span><br><span class="line">&#125;sta[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>, top = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i][j] = <span class="built_in">read</span>();</span><br><span class="line">            ++ up[j], ++ ul[j];</span><br><span class="line">            <span class="keyword">if</span> (a[i][j] &lt;= a[i - <span class="number">1</span>][j]) up[j] = <span class="number">1</span>, ul[j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (a[i][j] &lt;= a[i][j - <span class="number">1</span>]) ul[j] = cnt = top = <span class="number">0</span>;</span><br><span class="line">            S tmp = <span class="built_in">S</span>(up[j] == ul[j], ul[j]);</span><br><span class="line">            <span class="keyword">while</span> (top &amp;&amp; sta[top].h &gt;= tmp.h)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp.w += sta[top].w;</span><br><span class="line">                cnt -= sta[top].w * sta[top].h;</span><br><span class="line">                -- top;</span><br><span class="line">            &#125;</span><br><span class="line">            sta[++ top] = tmp, cnt += tmp.w * tmp.h;</span><br><span class="line">            <span class="keyword">if</span> (up[j] &gt; ul[j])</span><br><span class="line">            &#123;</span><br><span class="line">                sta[++ top] = <span class="built_in">S</span>(<span class="number">1</span>, up[j]);</span><br><span class="line">                cnt += up[j];</span><br><span class="line">            &#125;</span><br><span class="line">            res += cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">put</span>(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵(差分)</title>
    <url>/2020/11/26/%E7%9F%A9%E9%98%B5(%E5%B7%AE%E5%88%86)/</url>
    <content><![CDATA[<p>题目大意:考虑一个<span class="math inline">\(n \times
n\)</span>的矩阵A,初始所有元素均为0.执行q次如下形式的操作:给定4个整数r,c,l,s,对于每个满足<span
class="math inline">\(x∈[r,r+l),y∈[c,x−r+c]\)</span>的元素(x,y),将权值增加s.<span id="more"></span>也就是给一个左上顶点为(r,c)直角边长为l的下三角区域加上s.输出最终矩阵的元素异或和.</p>
<p>二维前缀和</p>
<p>考虑这么一个三角形:(假装有图.)</p>
<p>我们如果差分做的话,是对每一行的开头都加s对每一行的结尾的后一个数字都减去s</p>
<p>所以我们对查分数组再维护一个差分数组</p>
<p>对这个区域的(r,c)位置加上s,对竖着的(r+l,c)位置(结尾的下一行)减去s</p>
<p>对这个区域的(r,c+1)位置减去s,对他右下角再往右往下一个格子(r+l,c+l+1)加上s(因为本来是要对他们这种吊车尾减去s的嘛)</p>
<p>然后累加然后统计就好了</p>
<p>代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, q, res;</span><br><span class="line"><span class="type">int</span> cnm[N][N], fuck[N][N], a[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, r, c, l, s;</span><br><span class="line">    n = <span class="built_in">read</span>(), q = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span> (q --)</span><br><span class="line">    &#123;</span><br><span class="line">        r = <span class="built_in">read</span>(), c = <span class="built_in">read</span>(), l = <span class="built_in">read</span>(), s = <span class="built_in">read</span>();</span><br><span class="line">        cnm[r][c] += s;</span><br><span class="line">        cnm[<span class="built_in">min</span>(r + l, n + <span class="number">1</span>)][c] -= s;</span><br><span class="line">        fuck[r][c + <span class="number">1</span>] -= s;</span><br><span class="line">        fuck[<span class="built_in">min</span>(r + l, n + <span class="number">1</span>)][<span class="built_in">min</span>(c + l + <span class="number">1</span>, n + <span class="number">1</span>)] += s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">    &#123;</span><br><span class="line">        cnm[i][j] += cnm[i - <span class="number">1</span>][j];</span><br><span class="line">        fuck[i][j] += fuck[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i][j] = cnm[i][j] + a[i][j - <span class="number">1</span>] + fuck[i][j];</span><br><span class="line">        res ^= a[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">put</span>(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后记:</p>
<p>从没有见过此种类型题</p>
<p>第一次见,长见识了!</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维题</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title>社交网络</title>
    <url>/2020/11/27/%E7%A4%BE%E4%BA%A4%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<p>题目大意: <a
href="https://www.luogu.com.cn/problem/P2047">社交网络</a><span id="more"></span></p>
<p>看到数据范围果断想到弗洛伊德</p>
<p>但是有如下坑点:</p>
<ul>
<li><p>统计答案的时候一定要判断当前点是不是两断点对最短路...</p></li>
<li><p>一个数组记录最短路,一个数组记录方案数目.</p></li>
</ul>
<p>其中<span
class="math inline">\(f_{i,j}\)</span>表示从i到j的最短路对方案数目,<span
class="math inline">\(g_{i,j}\)</span>表示i到j对最短距离.</p>
<p>然后依题跑一趟就可以了.</p>
<p>代码如下: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e2</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> g[N][N], f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pres_dou</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j; <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) g[i][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; ++ j) f[i][j] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, k, x, y, z;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>(), <span class="built_in">pres_dou</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>(), z = <span class="built_in">read</span>();</span><br><span class="line">        g[x][y] = g[y][x] = z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= n; ++ k) <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != k &amp;&amp; i != j &amp;&amp; k != j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (g[i][j] &gt;= g[i][k] + g[k][j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (g[i][j] == g[i][k] + g[k][j]) f[i][j] += f[i][k] * f[k][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    g[i][j] = g[i][k] + g[k][j];</span><br><span class="line">                    f[i][j] = f[i][k] * f[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= n; ++ k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="type">double</span> <span class="title">res</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == k || j == k || ! f[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (g[i][k] + g[k][j] == g[i][j]) res += <span class="number">1.0</span> * f[i][k] * f[k][j] / f[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;%.3lf\n&quot;</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>后记:</p>
<p>考场代码(30pts)距离AC只差两句话对距离.</p>
<p>弗洛伊德不需要用到inf,少用inf</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>秋1周记第6周</title>
    <url>/2022/10/23/%E7%A7%8B1%E5%91%A8%E8%AE%B0%E7%AC%AC6%E5%91%A8/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="51e874a7162c3c1e0331ee997dbbbcec37183040b306a13fce900256d27a3401">ba4a00b9ff25459fb52bec3d65fe39cfb3833966262c16dedd667304d9fc804f4eb1f7d3aebcaebf96fa43a9fd1d8fbb455ef59d35e384005149b830b97f7d5234aa2b80f1714539f0f6d264634989b87eebe373fc6f55d7b681ec7b9fb384e801d5465060dc45386d78779b981ce6ea90c3e0d1e0d4368fcc927c3f0ee040b47b613ce2683c21eb402ed0d85364d860909b58a3bc4176fb20942dd90964080a9c745400cf6c489a2f5ba41073a024de49b10d1d636923f7c64b9b165abcd167e2e05d14d6b5f3a599fc28b97ed18a1f4bd4a2a2aa98d17c2ba2d6c94a92d577a289c27e75c89d40347db3c3b180223e6bb5c73d3a924b639790d8d5a887f402aa54ae5156ec28d01bbed8ca8eb703a1e0fdac747a0f89066f8f524de386b4603acb36a696c899db39df81464fad965bf06cf8cf84f1309d015a4bde9b4f9932c6726b4ce73ca17ea72bcf74b5cd1558167714da6363b101d4c8c28c1ad7f5c9d314cd34645c0eea19e65e7f86ae3f0c2427f46705dea4281e90e5dbdc8c5619d576c51e750ac24d99e07768577919ec6d878f9b36c37344d1110483360883945136fc66cd6de1843beebcb91f35a805e9dc565406176496efe68f282420188224deb691eab1d11e6908e873c71679e3</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Univ秋1</category>
      </categories>
      <tags>
        <tag>周记</tag>
      </tags>
  </entry>
  <entry>
    <title>Miners 矿工配餐</title>
    <url>/2020/11/27/%E7%9F%BF%E5%B7%A5%E9%85%8D%E9%A4%90/</url>
    <content><![CDATA[<p>题目大意:<a
href="https://www.luogu.com.cn/problem/P4401">矿工配餐</a><span id="more"></span></p>
<p>状态显然,<span
class="math inline">\(f[p][i][j][k][z]\)</span>当前送第i辆车,第一个矿前两次送i和j，第二个前两次送k和z</p>
<p>转移很容易啊,不动脑子也知道...</p>
<p>就是个滚动数组</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[N]; <span class="type">int</span> n, res, cur;</span><br><span class="line"><span class="type">int</span> vis[<span class="number">4</span>], f[<span class="number">2</span>][<span class="number">4</span>][<span class="number">4</span>][<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">yhm_turn</span><span class="params">(<span class="type">char</span> ch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;M&#x27;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;B&#x27;</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">yhm_func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[<span class="number">1</span>] = vis[<span class="number">2</span>] = vis[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">    vis[a] = vis[b] = vis[c] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> vis[<span class="number">1</span>] + vis[<span class="number">2</span>] + vis[<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">yhm_max</span><span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) a = b;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, k, z, p;</span><br><span class="line">    n = <span class="built_in">read</span>(), <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (p = <span class="number">0</span>; p &lt; n; ++ p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">3</span>; ++ i) <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= <span class="number">3</span>; ++ j)</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt;= <span class="number">3</span>; ++ k) <span class="keyword">for</span> (z = <span class="number">0</span>; z &lt;= <span class="number">3</span>; ++ z)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = cur, y = cur ^ <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (f[x][i][k][j][z] == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> now, val;</span><br><span class="line">            now = <span class="built_in">yhm_turn</span>(s[p]);</span><br><span class="line">            val = <span class="built_in">yhm_func</span>(i, k, now);</span><br><span class="line">            <span class="built_in">yhm_max</span>(f[y][now][i][j][z], f[x][i][k][j][z] + val);</span><br><span class="line">            val = <span class="built_in">yhm_func</span>(j, z, now);</span><br><span class="line">            <span class="built_in">yhm_max</span>(f[y][i][k][now][j], f[x][i][k][j][z] + val);</span><br><span class="line">        &#125;</span><br><span class="line">        cur ^= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">3</span>; ++ i) <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= <span class="number">3</span>; ++ j)</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt;= <span class="number">3</span>; ++ k) <span class="keyword">for</span> (z = <span class="number">0</span>; z &lt;= <span class="number">3</span>; ++ z)</span><br><span class="line">            <span class="built_in">yhm_max</span>(res, f[cur][i][k][j][z]);</span><br><span class="line">    <span class="built_in">put</span>(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后记:</p>
<p>细节真jb多</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动规</tag>
        <tag>滚动数组</tag>
      </tags>
  </entry>
  <entry>
    <title>秋1周记第7周</title>
    <url>/2022/10/30/%E7%A7%8B1%E5%91%A8%E8%AE%B0%E7%AC%AC7%E5%91%A8/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="055bb7d7b6bbe8c2cc20198680d989209212cf01454c2065db968eef81864847">85efff6743410ceee6a518f729d36b2a875d909dc4c648909153db8584a4c7afccab48f5f044256bc7ab62f70011325cf65039df80bc18386791ebb288c9b527be146f4eb38671b6da33132c905dcd6703d95fa933547aa3e019bedf6699acac018f542c03a341756e6d0a0b21d7b2701bf6d6ad7b75402295e630d044ed7f441ee26f3d4e20ad2b31fd88f39ebeb45abc8151f6462d55137a7804272292ec85be214e7bad439377f8d6c0052327a2499178a36947caeb8e9476d929bcdaf5683665e83ec5db1a1640343c1f2c6e21409d5a32c6a03f5c777d97b903ed08b27b5699243717cb32246b28d2a63eb00c2fa82f1ae8c0f5472cac0d01b41489dff2527b6de3256cd693fb6c6c60363dcecaae3139d90f9d8e912e8c9b3122d87c987bf0a09e22f073c8e405f5d4e12bcf0dbcfd85907aa50b40a0161e1eef372df7a601288cb5972d3ab656ca9661fdc0267a6a9f0c98ba122c53cba380a929fae9a9352df328fbe6cba72135aed39294c09f7fd08629d491133a395e7d7b0c2302844517b3f40575490ca17da2e9744a56969f004b27fb2665abb71c9fd19c97be9f149387bf66b63b94b3abf95b0318a345d46a0f7731ad459e7d28afba7b03de659471832b9a3668ff61c6933b755c12ee90cfa506a4473caaa395b88f3e5088a7d8cd97cf651d37bc979f23f287140c8aa842dc07ca62ee48012bcd597321073cca6e520372679f42e0ac954264e765046f254cb24dec66d01a7d830968273644dc5e0cfa48ee1eae949cbfcdc870390a4d722ed5de0f406eaa2843b3730f25a52754849d11ced73a935c27f616e69a314880c614326f964cdf0eb81db278dec221f3b3348f67125905c11271026a03bcb71af4bdf9e4a132c23ec07477028a2f2d3940c707b5ddf9841c0c271e7b6aede5c7e3c9954e19d405b8a611e6fb81105943d4d85a5d271e14ad27f0a98b6484f7d41e41c76dc06f05f6bfd17ce17549b2cc0042380f4f3235fc689f87bad9eb66ae7a9ea0769c85206050b72c213e5230f0e1c8a613506af30ace0d227718e74a077814645c6572d91f48036e52f893e3b13b9a3de6c2b8350c3414bb1d8c0a3c9ecb8e3aa52e1ee56c2116a295506a4187d044aee5c7db3b3b03748c5409f7225ffae4011814a6769ccba913c6e4ac02aaaa14bc2ad587702e457a0c53a77d6d64d6a0ae696b2277fe8e894ca08681fc07a3251ffe42852ab60b452c72191a9e4e508b5bf1c42b83d00efe436d5b920aeae9549970d8c58ae95b05cc613710d9fe2453d33acc7bdd0f8909a134b4f0f964775ae1c8c6c0a5bff5bbef52cd03771856d9c0839259c12fa17b1dc2773cf3fe9cbcc475d40813467acc3e3c3e33566834e3c21a3fc5bb992227c507636b4cc863138952fd92e0ad3d9aed1306acefec235d185dff86258b715e7f5c989625baaf62ac0831cf3062dafc2890860ec8056e42894ec47f25e08ec674e0456b41f0c673f4d59e0f6566e742c3ad355a0a36fcf2b57fbf5601be41aa1c1d4cff3a3f8ec71be8ff0020ac98e421e05b9cef777c9a1f1b16c6c78a0b438550e0b1e98b6fee6aa58354cc712b37bc0ed3d17a313320c8b19be706e478705bcdf15ffc5e3295fffa1034e024a6397355422b2ad046834e2257de6d6ba59263f882</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Univ秋1</category>
      </categories>
      <tags>
        <tag>周记</tag>
      </tags>
  </entry>
  <entry>
    <title>秋1周记第一周</title>
    <url>/2022/09/18/%E7%A7%8B1%E5%91%A8%E8%AE%B0%E7%AC%AC%E4%B8%80%E5%91%A8/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="ab5c2b8872667b296affd6635c8ab1274163ccdbae6bf567f731f0fa393244ca">4774c5ab53f1f7600809f52d59b92508dcc7a362e786436be9805dc65545ac93ca1ccc5f0df50573d4510c681c2d64d7453317d61c9c1250966f4898b8cf5bc61c90cfeb17b28fc3946434a675ff2dba72537fee1b6096f7bbd09d3f2a21cb9994c4417875564f632171995b55b6ec27d69dfc35a76125e7ae8747b3aeb9220cdb6b8427e75c460288e029c04671cdccde475d4d8af2fb150eb5194f47efd6304c8a28ef3ae687e88f9f44f4075b6cd89704946517808cce9086074caedb676fd7a8a99faae27663259b3eebba511ac39d4f2803f2e694d3c9d0b0fd792e8c9e8c2616acdc0969fd43acfc7a00aa5ad5597d6cfaa591e66823fcbe9e9f975c113dbd7eb6f35a40b7c1c01eb62fd673b5c089628747cc9e6739acb65f4d90e05e512c304d13d9196d11ba53482e7d43e888d635ae6b0daec74cb9b92a34bcb411e5a9e911572f0a5c417ff222f2fb41a66e9b4dcb725fb2b9224d4ada788992e84854de1133f393755ee789cd2baee033dfee08f335b2b8da5f281215673cca347432e631c61fcbddab8bd0bfc0631202da9bd1d4af9155b58cc0a0bfdd1cda4f4fa492c3bb7c468381230519b5bfe43b32ce4a927e79731a617765416a2e7428d8ee2173f87635ab366a23c0b22b4613cec1d540bc90f227bb44dfad2bb67322b943564a8b05a16f4b3a820c9a2dd8aca5ff620295a095e70de5f1482310e8e7d099d9e62456239e1832222d1768d0be8db0f6802f601ed09f59781bfdaef27a5a10cbfcedfe5fc4746aa6660ab3b28aa9002a900d778cf83369a873bf31e3964405ada03850d069ee27c55e8c4c1527f68be4f91508d4ec4bedecfdfe7bb70bb960cda21f48ef33829c601d3ab064915361701cb0d5327382233588b8550c1daa39dd08bf419a1bb6c959e255594f5a09aac2d948ccf814bf55e133d3e52f4e574146869d22093b48b77da7b273264e4a7310c990454e8ec53f870864217fbceea4d5e27bf802ddfc4d00bc640d70faae6d38d7839dd41631b4b4ecca16265609cdf1ad2632988ccd343f08537e9a6361d37732d04c3f6910172bfe008b16006da00ac2ed815ce3efacda750db02ecff3ea1e0f6558a8549f7217905d8aebb9a2ac26a3c80e2b3d4c3ac4c9442ae1fa86b8a3620fa6d9b17f73445b4309c9eaba0c8355e4e9b98024c34331825760dd0eb03409b0ccf3e8ea71255bde42651463be4a50fc10ac13e2dd7fca56b0918137c779c32eaea37d5a5430d27aa13ff56e6079c2f6d72b1214cf1ac3b5e05bedbed43e17ce39f0a8fa7281766fa3f4947e5afc8ae786a4523f60ac1d8a9a2e02fab8873e39545743d6733059c9186e5a9194a60859b6ab4f49689ece0fc8cf2fb3e545dddf3918031aefd16b5a4db3fb529a5f672e4514f115e2009821ddb62dd55678325f39137c7f56776d968f0f6d2498807507b3b2fc6ee93de334cb2370a39f87b1a361511d9483eeb1b91a687d44d82a09c5f9b26d6452c9c4e9e3cade82d78f255eaab9da4959f05aed95061743c73ac0b34b79fa2c437defa327e68e569c4899481eb6de2e0082b7bbde5cb9e2d166ac6be005c05742e7a563b48fdb646d6161015a5d18d7d81625b01106cd6584063658c3a8d1dff36fc79f53a841766af4a9a0ea3d670a11d18e4a9d8c65530f129a00ce36247c3af1ee28cef69cb95a5beb689ebaeddb83e4bc515316ee93bb82b661f308925ac793edb0f97791e69410fd132b4315955dc8f38e68f765ea7c8db8b5627ea93b79098d8e3cc2251fbcb74e7ee020b2936034d5fdf9a81e63548018b1d170411b249155b1014e8dd2760378c8cf4efc01d70064f7ea68fee252c4d6490c7a2e28b028d587baa877e1ce723bd746f0d92bc8756b306734f2f11355cc278f4597372099fe76f327eee06be9ce078dc4b23f02ca59e2fb26a7b31019adde65f47b2ee45924d16b441d1d6c61647cfe84aa3f07a7a61a66a162037e4b2a03ea9ad8d15fc02ab80ca1ca66b5fb05a3273ef880e446dc0834317d2c77a48c91ec82a3493beb59b3baa83e046556276541db290206ab186b7c84a862c2376eada63b74967fb66643fe6f3c3e39013819d540d0029099ed614f0c082587b636454fb1d5c02cb4e0ab10d3a7de6898b956805bdeb9a9e71a24eae74074916c3f9830db8b2d939f9be070d9efd78e7c34d2de9d71c4bab809e35d7c30572e5ea498448e176e13ad9d02eb3ca5a368e5808918967acebe2478e852d80a3f76cc93f7fd635bcfc42d8d260fc29618cc6c3ba9ae982d8fe68fb0c4a39f1e8016feb17fb9e206c0d1735522dd723d425e91774d392a3803c7dcc3291762b8ee9cd7300102efb18ca469023346c97b3c17918a02ce329afd894065741110ecf2f0f5ceefffe826445797cd0bc62e5445be598413af08feab96d7985fd475f2b984ec37f8ee77d1a1207ec404eddd9bd88596d95f32122ff4f5934f03b8aa674f465131e7b151c79aa5f9b56d46131ac55da6d9ae5059301b19060b61d8431a98dadb90dfe9463f647f1273c4dfcb47e082faeb95822e1546129c21dc98a82982c9245854f3eb4436d20bee941fd944e268f09660a525f427fbaf3a14bf95c44fe69ac887a862fdb29dd17f587be2a2e24fbb15c2fa5845ea21254a0ee9fddec11b9513eed93a903f5a06dbb847163e67bc4330cb0fe3cc5a06ee3c5a5286d24015696e62a91cc1fe5cdcb7a053e410c1512dc4189378dd57bd014a7d73ef2f4e1a3a50f17af2f8263edadfa6f7ea0fc4b59373d1f352d6bdd745cdfd8d93470dda829e13ebde8442ea7cec6e1d0c7b79cb4f2fe62f5b066932b21fcb05a51eedf00632604112109b858e082aaa3af67be828aeb1790f6fa1409edadff4815df922a30d07f04337c777b61227a0c0b7c71f4867deb01132f88ba2ab1c4f3ca20eb1dfe2845eb5fa02cc4d0703ec964e9a637c77b4f8018cbad5d6de4584bdc6cb73e3dedc8e458f8fc89abc96a7a760a92c8781c5b126bc7c5af1eb9730097b322962068028fbb73eb939ae2377cc87d2549a02c4c9f5a8a515ea7d86dd283a31b454028f3515a15899ac7d8202042b047e2499b23cecd453f3a39c4dce53f9775dff7268e23f1501a733ef083cc118e176543c4a4acdc5b72ae8f6cf20241201bf08d14c1f9de35415cc28be6332a9445ceb62d74e568e2783b389cbb48e8ec54cabe52c5e7d48c0087e881a5ee2951877ba4ffeb48212431b81a34fb3b25937adb2bfc7e150e7985bf77be7b6eacb07610e6bacb0e981feb06699700dab7ae0dc2334a4282a788a05df474546da33a8ea8209a956210a377aa5748a16c00b836c5181a731bccc6c9677847e2a176cccff7ffd3002bebbc88e66cf8d8bd9210c0c1f047867d16223add7347f542930f8e71ecb5a2f42097f2c9a4e0075adb9b32dbc18d526c232a2edb3d89c33a6fb503ddb3fe8a1cf137f50d4280a4cab9f3637d05e7569449338a19a76014ae0d3878d9c1da29d8ff32625dcb7a3c3ddb2f947aed6d6f266da155e422f8ff4d498a9827028319ac96b323647c2364922475c8aabddfcb4a10bde17923ed6c353c867ae2681dcea9a31640ade098701926b36e3fe2c9e7a296cae0a72fafab0c4027b8b1548389408e8c711b16ac779b6cc3ca7e8b0be772aba247bdc2fd871b72b</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Univ秋1</category>
      </categories>
      <tags>
        <tag>周记</tag>
      </tags>
  </entry>
  <entry>
    <title>秋1周记第二周</title>
    <url>/2022/09/25/%E7%A7%8B1%E5%91%A8%E8%AE%B0%E7%AC%AC%E4%BA%8C%E5%91%A8/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="996a4ef79fa2d46c58eb5c5da1c2d104a617b31a15f5fce2e2ba0dca08616877">703bc69c515aa534575a8a67cccfb78df642018a9ab353a4aa2b5d427365f4c624f3a4deed538f485bf872ed0194a2e76170e21f95270d35d53a957ee579a512eb150301b80b9e5f344a05f5cbe9d7625d8fdc1448adf0847abfd02c0ed2210bf786cf8635ba7f22c894bdb1de7844c65b5326321ccb9c015f32bfdd7f05eb92140422adbd7f7725fef0ffddaebfb7e167cba1dcfecca06f5f455eaabc5b8bc928716d2c7da7392c8c2c5f6715b4a8008b9d9debdbf9117460a1c4024f918144cc9771da90fc5352368b6a43a3f50f6e5a3d30b47da5de7dc3bdd121d501ce3c9d07c900c35d9b3eb206c0b026a9124d7f408e5902ff52e0f62f9df68e0ad4e27de7653e54d5cb5fcf93ac70f3e5231e313b1c0084740bd25d07178496257ed4871912c8a1da66ac7eedf3d5d59bca32315df768296a96cb0f62080f3fd43c3ae4a62b8a21a260eb2b777a966766aac5f4cbea4dc22ca4696a2b7944d3b4457947fe4816bd0646fe7067dea215dcbabea391a73ea2e0b3084918ec2c634ce781ebdfdf76c107a754af05f0cc752c7b0c9f73c90c26157f8c0da43ff15bc603c4a93b55a0f5b0cc5479b3013fd35615fd57f5f93ba20de8438ff20129ec920d7e66b4c5d55a0a3e83c3990592f1eebf2c228916dd113b9a198084cce0dab6fe292cdc808fe277220e82b2c6e9a35e0bff5677e7dbf67d40404798b2338d1cce0022d986facb93f3c27aef4533478e22eb631490fd2daa23b1fbad0606ba4de26b88726db96de4bc105d41f27f21c208b24becaba1003b569e637f69d51708271f16f4b4846cdff4639fce0aa7c883e7992420d5ac04afc322dd7c36ca369180d24e9b9bdc6d09b90a7841cba0f8cf963f28119d54f94fb2401b116283e6d61f40b07a8226f259cfd8a99c8de9a16205ba4550b95bbc5fd0530ff79006705042bc5dddfae5bbab14a86206ed5bbf24b2668e6287f31ee98f106d20bb023c3cf42103011b2e7700d664f46b6991acce6ce7b07165b17eddf91a5d9fa2724bfe7ba8a7c18d1a684389808addd0458dd7c094c11f71ef986728e80703aa4c359ec426</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Univ秋1</category>
      </categories>
      <tags>
        <tag>周记</tag>
      </tags>
  </entry>
  <entry>
    <title>秋1周记第三周</title>
    <url>/2022/10/02/%E7%A7%8B1%E5%91%A8%E8%AE%B0%E7%AC%AC%E4%B8%89%E5%91%A8/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="1803f61cdbdefda07595889a218cdc13cae23b29273442ec9d90a7a812f3b337">cc15f672e99d74689602a2be1f42bdfdef039daf29750aeab3685ab31296b57aa37542b53cd1769e639c20091c587ba341c980c11f46e6adfe382c5585d66f1a414c77b93f890980d7cb6e819895fea47a97a020c02418604f02e1020376f8324c94f7f2e0624d9bd72a2d14a5cfef5dddd3ff6d8134b59043b795b936ab45071aa44946e95ee835dcb1c113c55f4d3be961bbed0e7d3d226d2ed2cccab699d798cd2f2782324312136940f418b93e3daff9b3f35a487dfe8a55177d08e9c930c50c35e3a796c85f3f37148ca26ec02b2c75621f81c304a1924591b02efe92fdaafff4f6c8917f5961d10e133336708a6336749db2905c98b7f8774d42da8c4c9fdee3090cece940d66123d701fd08ffa4b33fd71fa819819c858cf5438b9970c03304f1ced5f9fa03595be99a9e7c290c786d5ed5f43ed1b43dd611c868eee3bf164a33d546a2ea926976f3fb673ef7e8e1fc3dd7deb10fec661b300cc61698ddc652bad309b22cc3cde2f8bc60ac5f</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Univ秋1</category>
      </categories>
      <tags>
        <tag>周记</tag>
      </tags>
  </entry>
  <entry>
    <title>秋1周记第五周</title>
    <url>/2022/10/16/%E7%A7%8B1%E5%91%A8%E8%AE%B0%E7%AC%AC%E4%BA%94%E5%91%A8/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="af3dc11ee88ccd3b5c5520d96a5cbceeaec9e37990d5d41179190ecc3a316431">b86c9cd0a5aebcf7619fd6b4a5eb115d0d567703780ebafac6ee5a07d31e0d6e10bfbab6e05268d55795a22367094f0fcf3c200426011eb1cc39d1d0823c2d44801de96c7309e8a155fe324f011cb8bd37ceee8b8e019e137f9d92b3d2cb03366bc92de7afa1084c0b168e73b551d66cbf44f946e8d71f1eb7be6ec14f47f63746d1ba51bb8f842f37a41edef3dd50f28b52d803f322badd595e6d9bb86f0c345b4e3ea1141874a58bcdc79cec46cb8880416f5f48238faac200c9efdc179d5e6ffc5a0551d4fd2ad73f5a38fd411f7b8cc6b17d595f01edbf85936fe326e3eeb2b2e468ae29e8cf646a4ed9cec040d32343b4f8b3983e8cf047b591e3d7e5348a9374f19a69336a55d0ba38967c862578cdbb33a5c1af35b3dc28f203c7a430c5223eb018dd116795f6e4a84b0576f251e5a7d5a532fa1cdaaeac98bb1287d97d8b7633dcee47b6f8bdc7231917b2ced9d3605114d27cd3381852705152260350d8f7b556fa39858e7abd247b1be9769bf09e6d6a30ea235f0721b4bf84bfe71518cf3722cc34ba26e78eb2ab09bb332e974cf2b6df85aa55eed4bfe384d4223d4db7c91359be466ba61be406838c652c1afaca41e53b5e728d0f737cb45d614475417802e932c3ade0e8aeb88792e80289ca6787e1c887671c18277c27661824bd2a96bbcd5c2879910697784737392b7acc024cddb4eaa840689a141e886227a696ccca6306ccb1d69ffdf44106d958fd3e03e13d59a201c456c80d2fc9fe06d59db2de53a60fb7a0cc88b111abe4004646c495313a55883f9fe630a8579e5706bbeef3400dbe4a93f8c10e52dc84e2905ba6a9c90722e476a9e610a2229ca2fe9bfe2ff96e463210c4f125fa51e84dc59cbd28c4a8bc06ad4161c24e7b27f268becd2a07ed1836b55dd8c6550be34b4c636d4ea2e74e97f4ad84104d4a1fb8f3b2c133f495b7591a673df5d11253236c46e9e62b849b8a1c998e907bae6bac2c879ee879ac713f36fc36ae3272be71722abfb1d58e9a7928293b70cd70d6e082f37cb051729ea940d550ae4e20bff9c970b73e58033e71766616921dd724</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Univ秋1</category>
      </categories>
      <tags>
        <tag>周记</tag>
      </tags>
  </entry>
  <entry>
    <title>秋1周记第四周</title>
    <url>/2022/10/06/%E7%A7%8B1%E5%91%A8%E8%AE%B0%E7%AC%AC%E5%9B%9B%E5%91%A8/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="ffeea2cb30bf6e9d4268771c867ed85e116b972af61ae8aa7af520b1757d7f9b">ad70019449e98d4c809f44847c521b61afbe71da1a12a316c7a998a61f772b9a59386e8746cd009e609e355ecb42e65c960983bb21e43bdc560769ad6b30ace033c52fc5044800a985a64adcdc2f82be90e100170bfeaaf53ec60b4292f9834a0daf12ec12fcf026db85a75672db176bee8b3af7941b5deb4309e27317a0477e174eeb27d269106bfe3892d1e486361a252c4c62e09c7cff0ebb2aa647c137c430b5a0bbaf257009316a97e787755cc112e611d9b248c8728cb9f5726401e7f8caba1f6630de035e978ed26db2a4c93555b3e3d225e9d6cf5caf5412da76c0d74123707e8d3be52909f5ce115867f8f5bf40dfdb35aa9c9b0c1d359ce3c14ade63aa6df4915d547d2c64b448ceb26d2063f25a77730b6fe0d2bf1149ec8f1caf3158678e75191373bb41023ea6e0a08dde935141b344cf84073c25888701cde1baf69429fdfa2a939c36e588acdcfb1af68872415bcd9024e150a9b307847e579902d5704d2eac49c7e10d8c6bb3cce46c0ee416db424f529d692e964ac2b5b8b145d25be3c1d46db27ce3395d282df4ae8397e5b16bf353618a6591c4cefd6c48a6d426322abaccd0c43021a8dabd8041cc73b98310943fada0bf582ffbc2cc2bc59b79afbc94703417e79e358a600fb90998459a873d5022f7de815add3da809f0aab9bd24ebbebb8ede06062c5d8946a51bfd4601cd3270b75bfdbc6253ce48e00c90299c989b2767e13cda81c05f40024bb010c37a321c5a974ca0dd7d3e520f4d624c84c35ab415d95e0e823ee37041e65bc1852b49d9c9b66cd5744f9e4d87d5b09f819f505f8c3f12cfb2f525c69a1a62c0bdc34bd1d784ed754cb821e23c6fb098024202742a472202dd5150f3d06d672ce1816284796222bf5c509a63e8801a0a41e78274a0ab07f2f54ba2593009e197fc2386f7508ff0652d3b9a1b0d84a0a5d4a564ed1db0966937e0ff71c24028a32570a78e3a41e7e6cbd8da5e4529d8a0fccc6109d9b35f85bfebe495a4c37007194dc8d863ee5cb4146c086268130d06c85398c0b8ab5dde5947fb7cea5f7247762ef7b0fc98bf90574bcbbaf5daba44f8ef5425bca06e86e2016bccf28156dd395f1885b82f6f42a5bac23aaa664a8fe00899eb8acee8e54b9ab7240d43c1bb0929a00769c5bd57d7fd7d25c14b12258b48fef1cf7386f30f1fff044160e4e72c372942de2089966c52ddaf8ca454258c5822af25f61b6608e701b7892ecd2ffcfdd078c1a97dc30eef89ee738ef471324a2d37d5944dfdb6b994bae0f255d36aa0a8a6cb1af46a3517f052da4f01348b69dc2974caf58ae3ba6e9e81174d45328fe075403d88cdf9c1d1be3c1bbb0dc42a4e1827a4c633feecf62e289b26f4c5cb1af639dfcbd5437cdcbafe7eff12835ebb616daa50753deb1ff3382c0035161f8590b9c2effb48768edcedbabca6f66ce2d5dc267b832b3917f3773759d78c9eeddd34dfcbf1526d201e461dbfd578f41064fe555b929a43de17796030882148b138b2715df5f3bb17871cc6e6b1a2aa8cb55510d78918897bae5df5d4bdf171a0473e7e3ebbd67eba1719b14ee4aaa4d22fad8962e1498d85296e634ccc427412a1480b9bf9672e8abf908f9f19169b446cd349da63b8cbabe5cb86037e7786530cf5469e6b270ca6d4b74ab3b0ae8dfbbffaaf1c5aa5b695e3ac17f8fab76338155a3d7007f883e074afc14954feea0e9ea13887f688d0acecbb62ea3e1c15e5602430fc65cc41f68b0b2b4451d8a66d41109f01642d3ec8256087d18f2613032b2ce6f46685e6d06c1eb6a94f72c0d9338a96f2d6e77b86261c32c4a1f8511bf4d24463fab2dc6bae25af1ced09d9b972d038e89b7d3376364a7bab6c797dff6df1bc9d6376f71eb2163b9a0bf3f367ba1ab847c673b8ae5fba01a679b2f1dca96a477154fb248846ef6de8e53c4622ca235d99558e061ebcb2c5a56de7856851d0f5a1fab0f7e186547a9928356a238e88355b94668174b74705c95b29e6bab76916a2d36c1896aed3aae1bffe76c76568ba5f7faf958088a8d81efcde1c865abaf83b01d9d5fc109c8fe1f1041908d3b932faed41968f145af698e8db7290e17176962c7187309dbfc7ab5f9f3ad32e507f1c10bf864f24cede7d16b2b415b0971ffc37ba6727bd758db9049f00faa15ff2e140104d8a6cf538d8cdae7971d3ed985b0ed2ff1f30838e63561d9f8ceda8e9b75203913dcd7212584f9320d1ac180a3f9365c7f08168d260ba6afbefbaa79e8325c229b28a6369ecc8980fc42a042e189815def8c30de6b22d8eaae2d9807d7f5e44ded1fe58a85fe98aa30d02dbc13757e50cc8e11675f05b66999c1efbdcd9f04df1680eee00c0f4a922d5918b0b336e0194543a21f4162e6e0a77d73db49d1e179d027f29ca061d6904b03b4f96fc5d364df9e4694c3c1dab22fcf1719baf31056fc626094d31828c9a709ccb601235b66a6d90be77a256d3c733de5b7d5065f56f31f04c7ce86784f80493008ab360587bb5333f61a531d52f50ad86b74adc8b44aea720c73c3d811e6e8a64650bbd268704243c73a90e911a476a2ea26b31d02f399309d18c7062f7007999da6ec1c82694acb6afd882306f5cbc40a7976ce3be17d8a6c5925db9a0f5bcf339c79f25d7b0c1e30e9b0fc0cae40fdc530166048439ee79e0d934e4db3fcad14d9fe41b2d443bfba85122552b4ea7cb0dc16150e7c055782162790af2392638eb88746020431dc9a127739669e3905c7f3995c73dc511809e848374c8c0141cdb65c46274372ebdab522077c873767a7b1debb63c0ddc583af50e8ac8eed5af940d02e7db440dba09c3f1a80171c1e58a299fdb0b6b1b8d2c60b582fd7b554dc16f211706b5f975141dbd87916c8daa77a9bf0b45732ac52383ddcda9f39fb2657240af206a178f589824524cf453fda6e3afde5c1ef994494bc69a7794ed87df0754114554377a079cfba8acaa79a41b8575a89cdce81a3d33c12b61dd8897f600ce24ce860b328b2047e2833dabde012c9ad5298e2d15f808e47390d66db1f58c31ecb240d66c8a01349f5cd5414c81c0bb20a38494b56647ce88e1a35dc92e082d2155973ca2a9e1a1b11f7f45ed0a60a2579a3669f545b62a513d6e529e742b441a0604862a2eddf37341a48fd4f0729334313d700a423c5350530b212b0a6c1c74da22c7da9702ef0b7f29624414fd66769d32d8cd6d99d4d027b1922f6ccd868746c364fec08fb4da354082f2893b555204d355f4345667cb83d755fb7da90f770fe9985eab09a8433b66023e760f5d4f4ea6d382500aa2a13644ecc83953ce138e385831fb2445b89be97dcc6f272764a048c51102d9653d9625173deb6a8869dd11506ab5e669ce92f5948a9796085af1989405e8ccbac0252c8b43b0dd370274b26281d829a4270fe66c0698c79d3f6f7dd1d1fa756460ea4fecbfa6c32b214e94e41a16fdd51e2e56762433abb0f4fa6e6e94c8847f0977bff61bb1b9d9951aedff995e40abdaed0649fc68654c53be6db7d13be75f0de7edaa39d5b9f5d4b3395028a48e3680e1cd42fd8c63185261def7efe3fe02e7266e663fafac80bc59b4946cec28b4fa6351d437a013074c12fa0403754173f8998abdc78c2d5e9dee04dba8ee626ebe63ee3f6f78bce3f4efb6a726bc5cdb9ab7deed98b9c310d962e6c7822b6a6438f7b996ef6e3f47eb9d9776ac56746d36c9789592b30c292da0a4623800a687ebb1e47c0b261ffd69337394b540591086b3dde2dae2d932db7de4b6b02c29fa67b74f0fafee2eaa326b9e051198444f7079768c48a6cf1e1935b35c199aeb4f024c8ffced1270817e1c50e1e390b702d85ca5d59ed41ac61f703b3b629ebf063edcec511f077e1c1626101133bf4469e1638b00c3de9d7db92964146afc99d47bacc4804c4c2ec737dda5ed7c39fed41d862fbd05d2dde9358ae37cd440c5281ce828a6521cd25f0cfc4bbb8f7c64c55b3aa2831ef71ccdd17efb60206e6cfc93879e2a06475aa9ad96e24e543d3a260a7c6589f04c95c653ed27e80a43aa957ea411f7f356a59eb60821e805c329e4d817b889ad8c0582bc0ac3c66e339c0bf1e665021746eb7d63a0ac07178d5237b93d36d054acb18b24252d1b371e28b15e99ae8e433d8d624069ae1514ad461f1ef1e4ef1a2eb2130f85d443fcb4baa1c02cb8bee786e1f3e9ef5f21c08ef27ea3cc800512d9ab133292fec070cfa3edc317eb07d8682c9dfa3e5fa606049ac781e4f20b568db9de1f26badbddc98aa2d0872d6eeb7fe683fefe23f43802e3592164ef6d3a887e01174aed43951dca8d7f16683770149ee20deb7ce333a2bc19c2ae9497ab8a7dc6a45a4450ece7b79d2785ec4998ccaf235037cb4c5d85798c893bb00e54151eb37c8f2aa1770a4ae892ab18f8e123a3621efa6124a6a3e727b6f02516f5e68c82729a9eae8cd8bb3ec09ca9234df7befb37a1c94c9f4baccbae65d6dfb208b9c0441f800dbcd7ec7a4a6f16810e73f33902a5b3317f5acf701736a88c3996835037eb5c255778d9375b2a3981ea87892a287aafd84108e4fb40bf83cb79171a8d25583b3e72f78847b974b8115bb302e75ecd171a57c43224db10fdc0995373a3bccc9c7f062441681a0ab2e9dfe7b7774acb26b40a2423617acf70fd470ab1cde8e118bd5ee1ddbe71d2ec432b2d521ebac2aeb334146e5c01679acfd170ea3b1d8b71c18ebcc59bf1f2447c28d1209cff3249ab1996d1e9187af1d98f981309cd84ec2a8687f2f187db49e32cd9123e1f1634d04049c65360a7f26387cc7364a2cabc1d717a72658c682e33074926127939579e30f861795ea17baeff03657376bda9456acf446ef6479489b1a34a55c6b9b931fbfc6dc753fa74ff9e9571c49fdabf9ed1c53f695ad28c6f5b25fd45e605c97cae324fca5c48f257a49c0416b100604653688cfaa0d87f44d3d49a82538f6b55fe0c1d8d497f21f6eea9215f0c6d2bad800d93a7c94bc56f2c274a5872d113985600e89d3ff8ec67c11ee20e960ba49d58e9f99e8a062fc19d5cee47a15a5875e5d31365bf7f7421dc96ad55a7f006655c84659eece7d7a0644d11059ab1a8cf87c21d43bae3c3658a052ca5f42998dcec2bc0beea45bd4b741e97bdc3b9f2ef302ab32bf451c3c378f9c53553bcc3a94f95391a67744851800738f23f1720fb903291e0e8598f7ee480fe2da1a598bb5ab4f2ef672799e9e48828a0821683c10d22537ec6e38f44b0499cfd3994bce71bef5bebb840be52de8c5e8b39430ac48710f26f7dd77d312ec8fdebe7226e7664df30d02e07817258508f6baacd85d92c670e06a2c079578a1d95a79d68cf8ace95c5b659217600859e68a46a56ded66a8628275f14986bbc30c4a7fdb3a8b467bcf84d1427de3a7441e6961715a1348b0419c257563207ce2b3015d899a80c6a07fb6c44d1d097c35697214cd83f72ac139bbfb73e024660eb47add12d8c14c549766ebaa20178da0400a7985abfc1fca1879f21d24ccc52d23353a684b4e5ae93ffcb29a48fc737376bb8b34dc710e795f32fb3d32b726a589afd8ed8f90e0bb2b8f5749de915f93eb61909f8bde134b48e87139ed07201f1360246aae496da76adfff00800f2b529040e1b03807f91eb58c09cb700470e660554fa311e792661c9c43e5fd8fdedea8e91253f8a226710fc49c77d004d06a483e2f4c9841d558d1f34e163354d7d09970f7590bf5a9d3935032f8529a2447ed81ea9841429c709247b9606179dc397599e8f3f1cea124a2774e047f05d4fa9be4c1daf422c19e6fee66e924966226e89dad34381964f49d16d0564ac4f70544c29584b36d9b6c43f14f0900c5b62d6c41fbc1452cf37914df121c4370653398b4529b7f15a0b8a88efbfc8c9014831e6f1643e8de4d1631fd875f7ff67046d788cd7f1330a0e53aedad1bf7ad86687b6fc151c2fbbe66636ebb65a9b303438aec2a8a077c1542e6afdc22e589404041e6d379daa2ed72cbff0f88f5cdf5b966352899d5c52602e367ebc238610cf3a1c45620205125e89c8a6046f5c6a738ab9aed2cf08f1cbc519e75681b7fe0927d7f7c085625658ecb7d7d1b573bf55f3801603d5264ffb10d2594e470a1ec764a836a39107227b15689d4a8903e0bd13e33e5f5fbb97bba320c9fd3a006fb518cfc0b0aad846d4a5b2d43db67ac903a2b8bbb5ffbca503f0cb6e6d04f0fb4fa0b381e3034d45c007ad748fd241f6473fb7926ba2ef78db7d1211dace75277f696a6cf21649426b72c01cea087b16bafafd979b305656be24b76bc76d0f38c581a6b6b2ee2ca6a5c8e940cc53367c121f61ec7721340c515a0bd9abb3a379b162628493738bc8566c754861b740499578bc38ec2816d1db68f42f3e59a28841f57d64d4da92aa2f2a1529f5881bb61932764fad5c9f6c8ab7777ae7c05f743810ab76fd29756a061a7c859ea6596d512e0f2666e7803a032626c088b77458e20380f53a2874f14b5ad18dd579379f279341ec59bd8df0ab205ff0caf3a6eae742480a5727f842f633eb1df0fb2aea97a5d49f806a1245f69f1c14795329895f47eca31d09ed035f41a28524d9123e7a50f2cb262e6a6a8506727c1d092f008b3b080782b4cbdf3e074c9ae1054002eebb78a4aeb404f8d442ce780eb18d02068bd051ae33bdf47d70ff21136f031ba21e7555a26b93695de33e0a992bf696753c6ddc03f0568e19bd55f07b36500332aa2fc238a9c2d69ca786181d6d1b53142c301dae7bc2f18e72d709a5bfb7b013e202231089f1af950b4e28db2474e75304480638efb17658d99aeac65a70dba9eaa5b20d587f1ed8f9da9b90f3572e373faf3d1c5cafbb511ce0ec2a50cfa4eeaf9597d5130cffc7bb20b662ba5d3b4365e00955a14bd617b4e929ce2780090edbe2725f180917f09b62079014558f93e34f1880935f3b02f56e71b9bb7a91db782890f39938b8f5231f42e1c6506cc3eaaec33c63dc721f99dd89fa1bbcf875fa99931d730b0c8d7b3b0abf94670e551c4be18f1fbc39fcddbd11c98507cc19efef5fd5c91d6936f4a9f259cf1b6a3159c552f9b72d</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>Univ秋1</category>
      </categories>
      <tags>
        <tag>周记</tag>
      </tags>
  </entry>
  <entry>
    <title>简单的打击（众数）</title>
    <url>/2020/10/01/%E7%AE%80%E5%8D%95%E7%9A%84%E6%89%93%E5%87%BB%EF%BC%88%E4%BC%97%E6%95%B0%EF%BC%89/</url>
    <content><![CDATA[<p>题目大意：你什么方面都强，所以你可以分别重新锻造这两把剑，锻造就相当于重新排列这两个序列。合并这两把剑，让它变成一把新剑（对应序列c），合并相当于把对应位置上的数加起来c[i]=a[i]+b[i]。最后你准备拿着这把新剑去找大Boss，造成的伤害是众数出现的次数。问怎么排列才能使得伤害最大化，输出最大伤害
<span id="more"></span></p>
<p>考虑正解是ntt什么玩意的</p>
<p>考虑可以拿满分的dp暴力</p>
<p>我们发现权值都特别小，才一万，所以我们可以开一个桶来记录</p>
<p><strong>然后我们对所有数取一个最大值</strong></p>
<p>然后dp枚举<span class="math inline">\(\sum
min(a[j],b[i-j])\)</span></p>
<p>其中i为我们枚举的众数，j即为考虑有没有这个数字</p>
<p>正常的话，我们枚举的上限是<span
class="math inline">\(10000+10000\)</span></p>
<p>所以时间复杂度是<span
class="math inline">\(O(20000*20000)\)</span></p>
<p>但是我们忙猜概率不会那么大，我们只去枚举到最大值加上一个随机数字（小于五百）</p>
<p>然后就可以过了….</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= maxv + <span class="number">100</span>; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= i - <span class="number">1</span>; ++ j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// res += min(a[j], b[i - j]);</span></span><br><span class="line">        res += <span class="built_in">min</span>(b[j], a[i - j]);</span><br><span class="line">    &#125;</span><br><span class="line">    yhm = <span class="built_in">max</span>(yhm, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>动规</tag>
      </tags>
  </entry>
  <entry>
    <title>红心大战</title>
    <url>/2020/10/04/%E7%BA%A2%E5%BF%83%E5%A4%A7%E6%88%98/</url>
    <content><![CDATA[<p>问题描述：相信大家都有玩过“红心大战”这款游戏。现在有 4
个玩家来进行操作，我们会介绍本题中的游戏规则和玩家的出牌策略，你的任务是根据初始局面来计算最后的得分情况。</p>
<span id="more"></span>
<p>游戏开始时， 4 名玩家平分一副扑克牌除去双王后的 52 张牌，即每名玩家13
张牌。点数从小到大为 2,3,4,5,6,7,8,9,10,𝐽, 𝑄,𝐾,𝐴 ，输入中会用 11,12,13,1
来表示 𝐽, 𝑄, 𝐾, 𝐴 。我们另用 1,2,3,4
分别表示梅花、方片、黑桃、红桃四种花色。这样可以用一个二元组来表示一张扑克牌。比如
(2,7) 来表示方片 7
。由于本题中手牌的位置直接影响了玩家的出牌，因此玩家会将手牌排序，规则为先比较花色，再比较点数。如
(1,3), (1,1), (3,10), (4,2), (4,6) 就是排好序的手牌。4
名玩家坐成一圈，一轮出牌定义为从某名玩家开始按顺时针顺序每人各出一张牌。第一轮，从持有梅花
2 的玩家开始出牌，他需要打出梅花 2
。以后每轮，第一个出牌的玩家都会打出手中最左边的一张牌。对于某轮并非第一个出牌的玩家，他会考虑本轮中已经打出的、花色与第一个出牌的玩家打出牌相同的、点数
最大的牌。若该玩家没有与之相同花色的牌，他会将手中最右边的一张牌打出，否则有两种情况：</p>
<ol type="1">
<li>若其手中存在与之相同花色且点数更小的牌，他会选择相同花色、点数
更小的牌中点数最大的打出。</li>
<li>若其手中与之花色相同的牌的点数都更大，他会选择相同花色、点数最
大的牌打出</li>
</ol>
<p>一轮游戏完成后，打出了与第一个出牌的玩家打出牌花色相同且点数最大的玩家收走这一轮打出的
4
张牌，并由他作为下一轮第一个出牌的玩家开始下一轮。所有牌打完后，统计每名玩家收走的牌。其中每有一张红桃牌，该玩家获得1
分。收走黑桃 𝑄 的玩家得到 13 分。需要注意的是，若一名玩家得到了全部的26
分，则改为他不得分，其他 3 名玩家各得 26
分。可以发现，本题中的规则与实际规则会有出入。本题中 4
名玩家按顺时针的编号为 1,2,3,4
。为了方便选手得到部分分，本题中玩家的牌可能是不完整的，即总量不足
52张，但仍保证每人手牌数量相同、没有相同的牌且梅花 2
在其中一人手中。</p>
<p>大模拟题目，别人写了三个多小时，或者写了两个多小时，我算了算，我差不多也是吧</p>
<p>以下是几个坑点：</p>
<ul>
<li>A最大</li>
<li>Q是12不是13</li>
<li>我们所要打出的牌的标准是不断更换的</li>
</ul>
<p>细节：</p>
<ul>
<li>结构体可以再套一个结构体</li>
<li>结构体初始化的时候，要带上&amp;</li>
</ul>
<p>代码如下：（为了纪念我做出的第一道大模拟题，所有的代码痕迹都没有删除）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;pr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">s</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">w</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) w = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) s = s * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s * w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (! x) <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">num</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="type">char</span> c[<span class="number">66</span>];</span><br><span class="line">    <span class="keyword">while</span> (x) c[++ num] = x % <span class="number">10</span> + <span class="number">48</span>, x /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (num) <span class="built_in">putchar</span>(c[num --]);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yhm</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> tot, val;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">fuck</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> col, big;</span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> fuck &amp;x) <span class="type">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (col &lt; x.col) || ((col == x.col) &amp;&amp; (big &lt; x.big));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;id[<span class="number">66</span>];</span><br><span class="line">&#125;a[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">vector&lt;pr&gt;v[<span class="number">66</span>], lin;</span><br><span class="line"><span class="type">int</span> now_val[<span class="number">66</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fanzhuan</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == x) <span class="keyword">continue</span>;</span><br><span class="line">        a[i].val += <span class="number">26</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add_val</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(now_val, <span class="number">0</span>, <span class="keyword">sizeof</span> now_val);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (<span class="type">int</span>)v[i].<span class="built_in">size</span>(); ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (v[i][j].first == <span class="number">4</span>) ++ now_val[i];</span><br><span class="line">            <span class="keyword">if</span> (v[i][j].first == <span class="number">3</span> &amp;&amp; v[i][j].second == <span class="number">12</span>) now_val[i] += <span class="number">13</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> pd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (now_val[i] == <span class="number">26</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fanzhuan</span>(i);</span><br><span class="line">            pd = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pd == <span class="number">0</span>) <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; ++ i) a[i].val += now_val[i];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">End_print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; ++ i) cout &lt;&lt; a[i].val &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen(&quot;hearts.in&quot;, &quot;r&quot;, stdin), freopen(&quot;hearts.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    <span class="type">int</span> T = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span> (T --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">6</span>; ++ i) v[i].<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">memset</span>(now_val, <span class="number">0</span>, <span class="keyword">sizeof</span> now_val);</span><br><span class="line">        <span class="built_in">memset</span>(&amp;a, <span class="number">0</span>, <span class="keyword">sizeof</span> a);</span><br><span class="line">	</span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">read</span>(), start;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">1</span>; t &lt;= <span class="number">4</span>; ++ t)</span><br><span class="line">        &#123;</span><br><span class="line">            a[t].tot = n;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>();</span><br><span class="line">                <span class="keyword">if</span> (y == <span class="number">1</span>) y = <span class="number">14</span>;</span><br><span class="line">                a[t].id[i].col = x;</span><br><span class="line">                a[t].id[i].big = y;</span><br><span class="line">                <span class="keyword">if</span> (x == <span class="number">1</span> &amp;&amp; y == <span class="number">2</span>) start = t;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">sort</span>(a[t].id + <span class="number">1</span>, a[t].id + n + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">	<span class="keyword">while</span> (n --)</span><br><span class="line">	&#123;</span><br><span class="line">	    lin.<span class="built_in">clear</span>();</span><br><span class="line">	    <span class="type">int</span> x = a[start].id[<span class="number">1</span>].col, y = a[start].id[<span class="number">1</span>].big;</span><br><span class="line">	    lin.<span class="built_in">push_back</span>(<span class="built_in">pr</span>(x, y));</span><br><span class="line">	    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; a[start].tot; ++ i) a[start].id[i] = a[start].id[i + <span class="number">1</span>];</span><br><span class="line">	    -- a[start].tot;</span><br><span class="line">	</span><br><span class="line">	    <span class="type">int</span> tibu = start, start_fuck = <span class="number">666666</span>, start_val = y;</span><br><span class="line">	    <span class="keyword">for</span> (<span class="type">int</span> cnm = tibu; cnm &lt;= <span class="number">4</span> + tibu - <span class="number">1</span>; ++ cnm)</span><br><span class="line">	    &#123;</span><br><span class="line">		<span class="type">int</span> t = cnm % <span class="number">4</span>;</span><br><span class="line">		<span class="keyword">if</span> (t == <span class="number">0</span>) t = <span class="number">4</span>;</span><br><span class="line">		<span class="keyword">if</span> (t == tibu) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="type">int</span> pd = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= a[t].tot; ++ i) <span class="keyword">if</span> (a[t].id[i].col == x) pd = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (pd == <span class="number">0</span>) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> len = a[t].tot;</span><br><span class="line">			lin.<span class="built_in">push_back</span>(<span class="built_in">pr</span>(a[t].id[len].col, a[t].id[len].big));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">		&#123;</span><br><span class="line">		    <span class="type">int</span> pd_min = <span class="number">0</span>;</span><br><span class="line">		    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= a[t].tot; ++ i)</span><br><span class="line">		    <span class="keyword">if</span> (a[t].id[i].col == x)<span class="keyword">if</span> (a[t].id[i].big &lt; start_val) pd_min = <span class="number">1</span>;</span><br><span class="line">		    <span class="keyword">if</span> (pd_min)</span><br><span class="line">		    &#123;</span><br><span class="line">			<span class="type">int</span> mabi;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= a[t].tot; ++ i)</span><br><span class="line">			&#123;</span><br><span class="line">			    <span class="keyword">if</span> (a[t].id[i].col == x)</span><br><span class="line">			    &#123;</span><br><span class="line">				<span class="keyword">if</span> (a[t].id[i].big &lt; start_val)</span><br><span class="line">				&#123;</span><br><span class="line">				    mabi = i;</span><br><span class="line">				&#125;</span><br><span class="line">			    &#125;</span><br><span class="line">			&#125;</span><br><span class="line">			lin.<span class="built_in">push_back</span>(<span class="built_in">pr</span>(a[t].id[mabi].col, a[t].id[mabi].big));</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = mabi; i &lt; a[t].tot; ++ i)</span><br><span class="line">			a[t].id[i] = a[t].id[i + <span class="number">1</span>];</span><br><span class="line">		    &#125;</span><br><span class="line">		    <span class="keyword">else</span></span><br><span class="line">		    &#123;</span><br><span class="line">			<span class="type">int</span> mabi;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= a[t].tot; ++ i)</span><br><span class="line">			&#123;</span><br><span class="line">			    <span class="keyword">if</span> (a[t].id[i].col == x)</span><br><span class="line">			    &#123;</span><br><span class="line">				<span class="keyword">if</span> (a[t].id[i].big &gt; y)</span><br><span class="line">				&#123;</span><br><span class="line">				    mabi = i;</span><br><span class="line">				    <span class="keyword">if</span> (a[t].id[i].big &gt; start_val)</span><br><span class="line">				    &#123;</span><br><span class="line">					start_fuck = t;</span><br><span class="line">					start_val = a[t].id[i].big;</span><br><span class="line">				    &#125;</span><br><span class="line">				&#125;</span><br><span class="line">			    &#125;</span><br><span class="line">			&#125;</span><br><span class="line">			lin.<span class="built_in">push_back</span>(<span class="built_in">pr</span>(a[t].id[mabi].col, a[t].id[mabi].big));</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = mabi; i &lt; a[t].tot; ++ i) a[t].id[i] = a[t].id[i + <span class="number">1</span>];</span><br><span class="line">		    &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		-- a[t].tot;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	    <span class="keyword">if</span> (start_fuck != <span class="number">666666</span>) start = start_fuck;</span><br><span class="line">	    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (<span class="type">int</span>)lin.<span class="built_in">size</span>(); ++ j)</span><br><span class="line">	    v[start].<span class="built_in">push_back</span>(<span class="built_in">pr</span>(lin[j].first, lin[j].second));</span><br><span class="line">	&#125;</span><br><span class="line">        <span class="built_in">add_val</span>();</span><br><span class="line">        <span class="built_in">End_print</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>大模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>8.17集训</title>
    <url>/2020/08/17/%E7%BB%93%E8%AF%AD-%E4%BA%8C%E5%8D%81%E5%A4%9A%E5%A4%A9%E7%9A%84%E9%9B%86%E8%AE%AD/</url>
    <content><![CDATA[<p>至此，历时二十多天的集训结束了 <span id="more"></span>
感谢cjh学长，lrt学长，rqj学长莅临到此，为我们拔高，解惑</p>
<p>又接着做了将近六七天的习题</p>
<p>无论效果如何，或多或少或许都有提高（至少不再对暴力发憷了，不会做怎么办？就拿暴力怼正解）</p>
<p>接下来是清北某堂的讲课以及训练</p>
<p>距离NOIP2020两个多月的时间，以后就好好干吧，初步计划，在九月3号前把蓝皮书搞完，搞透彻</p>
]]></content>
      <categories>
        <category>暑假日常</category>
      </categories>
      <tags>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树</title>
    <url>/2020/06/03/%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    <content><![CDATA[<p>the easy xds code is follow: <span id="more"></span> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N], b[N&lt;&lt;<span class="number">2</span>], d[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span> <span class="params">(<span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (s == t) &#123;d[p] = a[s]; <span class="keyword">return</span>;&#125;</span><br><span class="line">   <span class="type">int</span> m = (s+t)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">   <span class="built_in">build</span> (s, m, p&lt;&lt;<span class="number">1</span>), <span class="built_in">build</span> (m+<span class="number">1</span>, t, (p&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>);</span><br><span class="line">   d[p] = d[p&lt;&lt;<span class="number">1</span>] + d[(p&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">update</span> <span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> c, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (l &lt;= s &amp;&amp; t &lt;= r) &#123;</span><br><span class="line">      d[p] += (t-s+<span class="number">1</span>)*c;</span><br><span class="line">      b[p] += c;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">int</span> m = (s+t)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">if</span> (b[p]) &#123;</span><br><span class="line">      d[p&lt;&lt;<span class="number">1</span>] += (m-s+<span class="number">1</span>)*b[p], d[(p&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>] += (t-m)*b[p];</span><br><span class="line">      b[p&lt;&lt;<span class="number">1</span>] += b[p], b[(p&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>] += b[p];</span><br><span class="line">      b[p] = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (l &lt;= m) <span class="built_in">update</span> (l, r, c, s, m, p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">if</span> (r &gt; m) <span class="built_in">update</span> (l, r, c, m+<span class="number">1</span>, t, (p&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>);</span><br><span class="line">   d[p] = d[p&lt;&lt;<span class="number">1</span>] + d[(p&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>];</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getsum</span> <span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (l &lt;= s &amp;&amp; t &lt;= r) <span class="keyword">return</span> d[p];</span><br><span class="line">   <span class="type">int</span> m = (s+t)&gt;&gt;<span class="number">1</span>, sum = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">if</span> (b[p]) &#123;</span><br><span class="line">      d[p&lt;&lt;<span class="number">1</span>] += (m-s+<span class="number">1</span>)*b[p], d[(p&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>] += (t-m)*b[p];</span><br><span class="line">      b[p&lt;&lt;<span class="number">1</span>] += b[p], b[(p&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>] += b[p];</span><br><span class="line">      b[p] = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (l &lt;= m) sum += <span class="built_in">getsum</span> (l, r, s, m, p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">if</span> (r &gt; m) sum += <span class="built_in">getsum</span> (l, r, m+<span class="number">1</span>, t, (p&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">main</span> () &#123;</span><br><span class="line">   cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i =<span class="number">1</span> ; i &lt;= n; ++i) cin &gt;&gt; a[i];</span><br><span class="line">   <span class="built_in">build</span> (<span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">      <span class="type">int</span> opt, x, y, k;</span><br><span class="line">      cin &gt;&gt; opt &gt;&gt; x &gt;&gt; y;</span><br><span class="line">      <span class="keyword">if</span> (opt == <span class="number">1</span>) cin &gt;&gt; k, <span class="built_in">update</span> (x, y, k, <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">getsum</span> (x, y, <span class="number">1</span>, n, <span class="number">1</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>and the code with the 'mul' is follow: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, mod;</span><br><span class="line"><span class="type">int</span> a[N], b[N&lt;&lt;<span class="number">2</span>], d[N&lt;&lt;<span class="number">2</span>], y[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pd</span> <span class="params">(<span class="type">int</span> p, <span class="type">int</span> s, <span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">   <span class="type">int</span> l = p&lt;&lt;<span class="number">1</span>, r = (p&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>, m = (s+t)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">if</span> (y[p] != <span class="number">1</span>) &#123;</span><br><span class="line">      y[l] *= y[p], y[r] *= y[p];</span><br><span class="line">      b[l] *= y[p], b[r] *= y[p];</span><br><span class="line">      d[l] *= y[p], d[r] *= y[p];</span><br><span class="line">      y[l] %= mod, y[r] %= mod;</span><br><span class="line">      b[l] %= mod, b[r] %= mod;</span><br><span class="line">      d[l] %= mod, d[r] %= mod;</span><br><span class="line">      y[p] = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (b[p] != <span class="number">0</span>) &#123;</span><br><span class="line">      d[l] += (m-s+<span class="number">1</span>)*b[p], d[r] += (t-m)*b[p];</span><br><span class="line">      b[l] += b[p], b[r] += b[p];</span><br><span class="line">      d[l] %= mod, d[r] %= mod;</span><br><span class="line">      b[l] %= mod, b[r] %= mod;</span><br><span class="line">      b[p] = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span> <span class="params">(<span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">   y[p] = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">if</span> (s == t) &#123;d[p] = a[s]%mod; <span class="keyword">return</span>;&#125;</span><br><span class="line">   <span class="type">int</span> m = (s+t)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">   <span class="built_in">build</span> (s, m, p&lt;&lt;<span class="number">1</span>), <span class="built_in">build</span> (m+<span class="number">1</span>, t, (p&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>);</span><br><span class="line">   d[p] = (d[p&lt;&lt;<span class="number">1</span>] + d[(p&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>])%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">chenge</span> <span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> c, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (l &lt;= s &amp;&amp; t &lt;= r) &#123;</span><br><span class="line">      d[p] *= c, d[p] %= mod; </span><br><span class="line">      b[p] *= c, b[p] %= mod;</span><br><span class="line">      y[p] *= c, y[p] %= mod;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">int</span> m = (s+t)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">   <span class="built_in">pd</span> (p, s, t);</span><br><span class="line">   <span class="keyword">if</span> (l &lt;= m) <span class="built_in">chenge</span> (l, r, c, s, m, p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">if</span> (r &gt; m) <span class="built_in">chenge</span> (l, r, c, m+<span class="number">1</span>, t, (p&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>);</span><br><span class="line">   d[p] = (d[p&lt;&lt;<span class="number">1</span>] + d[(p&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>])%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span> <span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> c, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (l &lt;= s &amp;&amp; t &lt;= r) &#123;</span><br><span class="line">      d[p] += (t-s+<span class="number">1</span>)*c, d[p] %= mod;</span><br><span class="line">      b[p] += c, b[p] %= mod;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">int</span> m = (s+t)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">   <span class="built_in">pd</span> (p, s, t);</span><br><span class="line">   <span class="keyword">if</span> (l &lt;= m) <span class="built_in">add</span> (l, r, c, s, m, p&lt;&lt;<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">if</span> (r &gt; m) <span class="built_in">add</span> (l, r, c, m+<span class="number">1</span>, t, (p&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>);</span><br><span class="line">   d[p] = (d[p&lt;&lt;<span class="number">1</span>] + d[(p&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>])%mod;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getsum</span> <span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (l &lt;= s &amp;&amp; t &lt;= r) <span class="keyword">return</span> d[p]%mod;</span><br><span class="line">   <span class="type">int</span> m = (s+t)&gt;&gt;<span class="number">1</span>, sum = <span class="number">0</span>;</span><br><span class="line">   <span class="built_in">pd</span> (p, s, t);</span><br><span class="line">   <span class="keyword">if</span> (l &lt;= m) sum += <span class="built_in">getsum</span> (l, r, s, m, p&lt;&lt;<span class="number">1</span>)%mod;</span><br><span class="line">   <span class="keyword">if</span> (r &gt; m) sum += <span class="built_in">getsum</span> (l, r, m+<span class="number">1</span>, t, (p&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>)%mod;</span><br><span class="line">   <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">main</span> () &#123;</span><br><span class="line">   cin &gt;&gt; n &gt;&gt; m &gt;&gt; mod;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) cin &gt;&gt; a[i];</span><br><span class="line">   <span class="built_in">build</span> (<span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">      <span class="type">int</span> opt, x, y, k;</span><br><span class="line">      cin &gt;&gt; opt &gt;&gt; x &gt;&gt; y;</span><br><span class="line">      <span class="keyword">if</span> (opt == <span class="number">1</span>) cin &gt;&gt; k, <span class="built_in">chenge</span> (x, y, k, <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (opt == <span class="number">2</span>) cin &gt;&gt; k, <span class="built_in">add</span> (x, y, k, <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (opt == <span class="number">3</span>) cout &lt;&lt; <span class="built_in">getsum</span> (x, y, <span class="number">1</span>, n, <span class="number">1</span>)%mod &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>the thought is easy</p>
<p>but there is some details</p>
<h4 id="ps">PS:</h4>
<p>1.if must with the '<span class="math inline">\(return\)</span>'</p>
<p>2.'&lt;&lt;' and '&gt;&gt;'</p>
<p>3.'update' and 'add' and 'chenge' need <span
class="math inline">\(d[p] = d[p&lt;&lt;1] +
d[(p&lt;&lt;1)|1]\)</span></p>
<p>4.<span class="math inline">\(y[p]\)</span> need put on the first of
the <span class="math inline">\(build\)</span></p>
<p>5.<span class="math inline">\(int\)</span> &amp;&amp; <span
class="math inline">\(long long\)</span></p>
]]></content>
      <categories>
        <category>学后感</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>网址压缩</title>
    <url>/2020/10/13/%E7%BD%91%E5%9D%80%E5%8E%8B%E7%BC%A9/</url>
    <content><![CDATA[<p>题目大意：我们现在的任务是给定𝑁个只包含小写字母的字符串，你需要输出对这𝑁个字符串进行压缩的结果。<span id="more"></span>你可以使用任意的压缩算法，但你需要保证满足如下的性质：1、压缩的结果字符串仍然只有小写字母。2、压缩的结果不能是空串，且长度必须要比原来的字符串短。3、相同的字符串压缩结果必须相同，不同的字符串压缩结果必须不同。任意满足上述条件的压缩方法都是正确的，所以你的目标就是对给定的𝑁个字符串进行压缩。数据保证有解。</p>
<p>按长度排个序，然后a,b,c,…z,aa,ab,ac….就可以了</p>
<p>关键是就是模拟</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">map&lt;string, <span class="type">bool</span>&gt; mp;</span><br><span class="line">map&lt;string, string&gt; Hash;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yhm</span></span><br><span class="line">&#123;</span><br><span class="line">    string s, res, id;</span><br><span class="line">&#125;q[<span class="number">1666</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp1</span><span class="params">(yhm a, yhm b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.s.<span class="built_in">length</span>() &lt; b.s.<span class="built_in">length</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp2</span><span class="params">(yhm a, yhm b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.id &lt; b.id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">getline</span>(cin, q[i].s), q[i].id = i;</span><br><span class="line">    <span class="built_in">sort</span>(q + <span class="number">1</span>, q + n + <span class="number">1</span>, cmp1);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> p1 = <span class="string">&#x27;a&#x27;</span>, p2 = <span class="string">&#x27;a&#x27;</span>, p3 = <span class="string">&#x27;a&#x27;</span>; <span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        string now = q[i].s;</span><br><span class="line">        <span class="keyword">if</span> (mp[now])</span><br><span class="line">        &#123;</span><br><span class="line">            q[i].res = Hash[now];</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        string x;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">1</span>) x = p1, Hash[now] = q[i].res = x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num == <span class="number">2</span>) x = p2, x += p1, Hash[now] = q[i].res = x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num == <span class="number">3</span>) x = p3, x += p2, x += p1, Hash[now] = q[i].res = x;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> num_now = num;</span><br><span class="line">        <span class="keyword">if</span> (num_now == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1 == <span class="string">&#x27;z&#x27;</span>) ++ num, p1 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> ++ p1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num_now == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1 == <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (p2 == <span class="string">&#x27;z&#x27;</span>) ++ num, p1 = p2 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">else</span> ++ p2, p1 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> ++ p1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num_now == <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1 == <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (p2 == <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (p3 == <span class="string">&#x27;z&#x27;</span>) ++ num, p1 = p2 = p3 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                    <span class="keyword">else</span> ++ p3, p1 = p2 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> ++ p2, p1 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> ++ p1;</span><br><span class="line">        &#125;</span><br><span class="line">        mp[now] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(q + <span class="number">1</span>, q + n + <span class="number">1</span>, cmp2);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) cout &lt;&lt; q[i].res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后记：</p>
<p>这次考试在评测的时候，第二题编译错误挂了40分，第一题没有SPJ挂了90分</p>
<p>我依旧是倒数</p>
<p>今天下午考试头疼别疼，一直低烧，很难受，但是硬撑着，期望得分是100+40+10pts，这个水平属于中游</p>
<p>我觉得我可以，我也有实力去搞第三题，但是在那种环境下，我实在没办法投入精力去想，我觉得我能做到150pts已经很棒了</p>
<p>而180就已经是前三名了</p>
<p>这个分数的变化非常大，也非常好得到，并不是不会，通常都是差一点点的小细节</p>
<p>我从来不知道别人怎么看我，我也从来不觉得自己比他们差，我不知道我比他们强在哪里，但是我自信比他们强</p>
<p>或许可以称为自负，wlj学长说，最终的CSP/NOIp都会见分晓的</p>
<p>虎瘦雄心在，人穷志不短</p>
<p>无论落魄到什么地步，都不要触碰做人的底线，心怀勇气的走下去，只有这样才能逐渐摆脱困境</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>给大佬递茶</title>
    <url>/2020/10/14/%E7%BB%99%E5%A4%A7%E4%BD%AC%E9%80%92%E8%8C%B6/</url>
    <content><![CDATA[<p>题目大意：Alice 和 Bob 开始了递茶操作。<span id="more"></span>一开始Alice 和 Bob
都有一个杯子里面装了𝑁吨的茶。现在每次 Alice 会等概率地随机向
垃圾桶里面倒入4𝐾, 3𝐾, 2𝐾或者𝐾吨的茶，并且如果 Alice 倒了𝑥吨的茶，Bob
就会向垃圾桶里面导入4𝐾 − 𝑥吨的茶。注意每次操作的时候 Alice 或者 Bob
的茶有可能不够多，这个时候就能倒多少到多少。现在问 Alice
在四种操作完全等概率的情况下，Alice 先把自己的茶倒光的概率加上 Alice 和
Bob 同时把茶倒光的概率的一半是多少。注意，Alice 和 Bob
每轮倒茶都是同时开始同时结束的</p>
<p><del>首先，我们发现k有没有是没什么区别的，因为</del></p>
<p>说实话，我不透彻，回头补上</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">201</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> f[N][N];</span><br><span class="line"><span class="type">bool</span> g[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span> &amp;&amp; m &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0.5</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">if</span> (m &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">if</span> (g[n][m]) <span class="keyword">return</span> f[n][m];</span><br><span class="line">    g[n][m] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; ++ i)</span><br><span class="line">        f[n][m] += <span class="number">0.25</span> * <span class="built_in">dfs</span>(n - i, m - <span class="number">4</span> + i);</span><br><span class="line">    <span class="keyword">return</span> f[n][m];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n/k &gt;= N) <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>((n / k) + (n % k ? <span class="number">1</span> : <span class="number">0</span>), (n / k) + (n % k ? <span class="number">1</span> : <span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%.6lf&quot;</span>, <span class="built_in">calc</span>(n, k));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>行列式</title>
    <url>/2022/09/17/%E8%A1%8C%E5%88%97%E5%BC%8F/</url>
    <content><![CDATA[<p>关于行列式的相关基本知识和定理</p>
<span id="more"></span>
<h1 id="二三阶行列式">二，三阶行列式</h1>
<h2 id="二阶行列式">二阶行列式</h2>
<p>有四个数，分别为第一排的<span
class="math inline">\(a_{11},a_{12}\)</span>,第二排的<span
class="math inline">\(a_{21},a_{22}\)</span></p>
<p>从左往右，从上往下，排成一个数表，表达式<span
class="math inline">\(a_{11}a_{22}-a_{12}a{21}\)</span>称为该数表所确定的二阶行列式</p>
<p>记作： <span class="math display">\[
\left | \begin{matrix}
a_{11} &amp; a_{12} \\
a_{21} &amp; a_{22} \\
\end{matrix} \right |
\]</span> 并且要注意，行列式呢，是一个具体的数值， <span
class="math display">\[
D =
\left | \begin{matrix}
a_{11} &amp; a_{12} \\
a_{21} &amp; a_{22} \\
\end{matrix} \right |
= a_{11} \cdot a_{22} - a_{12} \cdot a_{21}
\]</span></p>
<p>计算其数值，应用“对角线法则”，即<span class="math inline">\(a_{11}
a_{22}\)</span>是主对角线，<span
class="math inline">\(a_{12}a_{21}\)</span>是副对角线</p>
<h2 id="三阶行列式">三阶行列式</h2>
<p>example： <span class="math display">\[
\left | \begin{matrix}
a_{11} &amp; a_{12} &amp; a_{13}\\
a_{21} &amp; a_{22} &amp; a_{23}\\
a_{31} &amp; a_{32} &amp; a_{33}\\
\end{matrix} \right |
\]</span> 对于其中任意一个元素，分，行标与列标，稍后会用到此定义。</p>
<p>计算其数值，沙路法</p>
<p>考虑，在该数表的右边，再写两列，如图 <span class="math display">\[
\left | \begin{matrix}
a_{11} &amp; a_{12} &amp; a_{13} &amp;\\
a_{21} &amp; a_{22} &amp; a_{23}\\
a_{31} &amp; a_{32} &amp; a_{33}\\
\end{matrix}  \right |
\begin{matrix}
a_{11}&amp;a_{12} \\
a_{21} &amp; a_{22} \\
a_{31} &amp; a_{32} \\
\end{matrix}
\]</span></p>
<p><span class="math display">\[
D = a_{11}a_{22}a_{33} +a_{12}a_{23}a_{31}+a_{13}a_{21}a_{32} \\
- a_{12}a_{21}a_{33} - a_{11}a_{23}a_{32} - a_{13}a_{22}a_{31}
\]</span></p>
<h1 id="全排列">全排列</h1>
<p>把几个不同的元素排成一排，所有排列的种数，叫做该序列的全排列</p>
<p>有<span class="math inline">\(n!\)</span>个</p>
<h1 id="逆序数">逆序数</h1>
<p>用<span class="math inline">\(t[i]\)</span>表示在一个排列中，比<span
class="math inline">\(a[i]\)</span>大的且排在<span
class="math inline">\(a[i]\)</span>前面的数字有几个</p>
<p>也就是，编程里面俗称的逆序对</p>
<p>我更习惯另一种表示</p>
<p><span class="math inline">\(t[i]\)</span>表示在一个排列中，比<span
class="math inline">\(a[i]\)</span>小的且排在<span
class="math inline">\(a[i]\)</span>后面的数字有几个</p>
<p>但最终求出来的序列的逆序数是一样的</p>
<p>注意，排列具有奇偶性，逆序数为奇数的排列称为奇排列，反之则为偶排列</p>
<p>将逆序数，全排列的知识，代入三阶行列式中</p>
<p>发现对于一个计算项来说，其下标的列标组成的排列为奇排列的项对应符号为负，反之为正</p>
<p>也即 <span class="math display">\[
D = \sum (-1)^na_{1p_1}a_{2p_2}a_{3p_3}
\]</span> 其中<span
class="math inline">\(p_1,p_2,p_3\)</span>组成的排列为奇排列，<span
class="math inline">\((-1)^n\)</span>最终结果为负号</p>
<p><span
class="math inline">\(p_1,p_2,p_3\)</span>组成的排列为偶排列，<span
class="math inline">\((-1)^n\)</span>最终结果为正号</p>
<h1 id="n阶行列式">n阶行列式</h1>
<p>简记作<span class="math inline">\(det\)</span></p>
<p>在n阶行列式中，我们只需找到不为0的项即可</p>
<p>所以有一些小性质：</p>
<ul>
<li>主对角线有数字，别的都是0，D = 主对角线上数字相乘</li>
<li>副对角线同理</li>
<li>上半角有数，或者下半角有数，仍然只需算对角线上数字相乘</li>
</ul>
<h1 id="对换">对换</h1>
<p>顾名思义，在一个排列中，将任意两个元素调换，其余元素不动，显然发现，存在一种情况叫做“相邻对换”</p>
<p>有几个定理</p>
<ol type="1">
<li>经过一次对换后（无论是否相邻），排列的奇偶性发生改变</li>
<li><span class="math inline">\(D= \sum (-1)^na_{p_11}a_{p_22} \cdots
a_{p_nn}\)</span>其中n为行标逆序数之和</li>
<li><span class="math inline">\(D= \sum (-1)^na_{p_1q_1}a_{p_2q_2}
\cdots a_{p_nq_n}\)</span>其中n为行标逆序数与列标逆序数之和</li>
</ol>
]]></content>
      <categories>
        <category>Univ秋1</category>
      </categories>
      <tags>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>绩效等级</title>
    <url>/2020/10/20/%E7%BB%A9%E6%95%88%E7%AD%89%E7%BA%A7/</url>
    <content><![CDATA[<p>题目大意：在 CZYZ 每个老师都要算绩效，当然，绩效跟完成的任务数量 w
有关，可以表示为以下公式：s = 10000 - (100 -
w)^2。<span id="more"></span>现在呢，校长想算出所有人的绩效，看看其中的众数是多少，如果有多个众数则分别输出。如果不止一种数，所有数出现的频率都一样则不存在众数，输出“Bad
Mushroom”（不含引号）。众数：是一组数据中出现次数最多的数值</p>
<p>就一傻逼题，注意坑点：一个数字的时候就是众数</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">66</span>, inf = <span class="number">21474836444</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> s[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;yh;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">1</span>; t &lt;= T; ++ t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span> s); yh.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="type">int</span> i, x, <span class="built_in">ret</span>(<span class="number">0</span>), n = <span class="built_in">read</span>();</span><br><span class="line">        <span class="type">int</span> minv = inf, maxv = -inf;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            x = <span class="built_in">read</span>(); x = <span class="number">10000</span> - (<span class="number">100</span> - x) * (<span class="number">100</span> - x);</span><br><span class="line">            minv = <span class="built_in">min</span>(minv, x), maxv = <span class="built_in">max</span>(maxv, x);</span><br><span class="line">            <span class="keyword">if</span> (! s[x]) ++ ret;</span><br><span class="line">            ++ s[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>, pdbad = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = minv; i &lt;= maxv; ++ i) <span class="keyword">if</span> (s[i] &gt; cnt) cnt = s[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = minv; i &lt;= maxv; ++ i) <span class="keyword">if</span> (s[i] == cnt) ++ pdbad;</span><br><span class="line">        <span class="built_in">printf</span> (<span class="string">&quot;Case #%lld:\n&quot;</span>, t);</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = minv; i &lt;= maxv; ++ i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    cout &lt;&lt; i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pdbad == ret) &#123;<span class="built_in">puts</span>(<span class="string">&quot;Bad Mushroom&quot;</span>); <span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">for</span> (i = minv; i &lt;= maxv; ++ i) <span class="keyword">if</span> (s[i] == cnt) yh.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)yh.<span class="built_in">size</span>() - <span class="number">1</span>; ++ i) cout &lt;&lt; yh[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; yh[(<span class="type">int</span>)yh.<span class="built_in">size</span>() - <span class="number">1</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>考试</title>
    <url>/2020/10/05/%E8%80%83%E8%AF%95/</url>
    <content><![CDATA[<p>题目大意：共有 𝑛 名学生参加了一次考试，成绩被记为 𝑎𝑖
。老师不希望看到有两人取得相同的成绩，因此会调整分数，并且只会给学生加分。现在你想要知道，最终所有人分数总和最少是多少。</p>
<span id="more"></span>
<p>由题发现的性质：n个数，最后的序列一定是n个不同的数字</p>
<p>我们考虑开两个数组，一个来记录原数字，一个来记录应变成的数字</p>
<p>我们<strong>顺序</strong>的扫，把每个数字都变成自己应该变成的数字</p>
<p>因为1 1 2 3 4 4变成1 5 2 3 4 6</p>
<p>与变成1 2 3 4 5 6其实是一样的</p>
<p>考试的时候我担心1e9的map会出问题，很傻逼的还花了半个小时，把数字转成了字符串</p>
<p>其实不应该在T1花太多时间的</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N], b[N];</span><br><span class="line">map&lt;string, <span class="type">bool</span>&gt;mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) a[i] = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) b[i] = a[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> C[<span class="number">66</span>]; <span class="type">int</span> NUM = <span class="number">0</span>;</span><br><span class="line">		<span class="type">char</span> now[<span class="number">66</span>]; <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> tibu = a[i];</span><br><span class="line">        <span class="built_in">memset</span>(C, <span class="number">0</span>, <span class="keyword">sizeof</span> C), NUM = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (tibu)</span><br><span class="line">        &#123;</span><br><span class="line">            C[++ NUM] = tibu % <span class="number">10</span> + <span class="number">48</span>;</span><br><span class="line">            tibu /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(now, <span class="number">0</span>, <span class="keyword">sizeof</span> now), p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> len = NUM; len &gt;= <span class="number">1</span>; -- len) now[++ p] = C[len];</span><br><span class="line"></span><br><span class="line">        string s = (now+<span class="number">1</span>); </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a[i] == a[i - <span class="number">1</span>] || mp[s] == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            b[i] = b[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            tibu = b[i];</span><br><span class="line">            <span class="built_in">memset</span>(C, <span class="number">0</span>, <span class="keyword">sizeof</span> C), NUM = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (tibu)</span><br><span class="line">            &#123;</span><br><span class="line">                C[++ NUM] = tibu % <span class="number">10</span> + <span class="number">48</span>;</span><br><span class="line">                tibu /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(now, <span class="number">0</span>, <span class="keyword">sizeof</span> now), p = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> len = NUM; len &gt;= <span class="number">1</span>; -- len) now[++ p] = C[len];</span><br><span class="line"></span><br><span class="line">            string st = (now+<span class="number">1</span>);</span><br><span class="line">            mp[st] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">res</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) res += b[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">put</span>(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维题</tag>
      </tags>
  </entry>
  <entry>
    <title>计数(容斥)</title>
    <url>/2020/09/29/%E8%AE%A1%E6%95%B0-%E5%AE%B9%E6%96%A5/</url>
    <content><![CDATA[<p>题目大意：给出 m 个数 a[1],a[2],…,a[m]求 1~n 中有多少数不是
a[1],a[2],…,a[m]的倍数。</p>
<span id="more"></span>
<p><strong>Input:</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">10 2</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure>
<p><strong>Output:</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<p>题目分析：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">容斥，但是我们要把多减去的再加回来，复杂度2的m次方·log（gcd，lcm）</span><br><span class="line">比如2，3，5</span><br><span class="line">res + n - 2 - 3 + 2 * 3 - 5 + 2 * 5 + 3 * 5 + 2 * 3 * 5</span><br><span class="line">但是用for很麻烦也很难实现，所以我们选择大法师(dfs)</span><br></pre></td></tr></table></figure>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e6</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">s</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">w</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) w = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) s = s * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s * w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (! x) <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">num</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="type">char</span> c[<span class="number">66</span>];</span><br><span class="line">    <span class="keyword">while</span> (x) c[++ num] = x % <span class="number">10</span> + <span class="number">48</span>, x /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (num) <span class="built_in">putchar</span>(c[num --]);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N], v[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;<span class="keyword">return</span> ! b ? a : <span class="built_in">gcd</span>(b, a % b);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lcm</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;<span class="keyword">return</span> a * b / <span class="built_in">gcd</span>(a, b);&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">inline void dfs(int dep, int t, int flag)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    if (t &gt; n) return;</span></span><br><span class="line"><span class="comment">    if (dep == m + 1) return (void)(res += n / t * flag);</span></span><br><span class="line"><span class="comment">    dfs(dep + 1, t, flag);</span></span><br><span class="line"><span class="comment">    dfs(dep + 1, lcm(t, a[dep]), -flag);</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    return;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> t, <span class="type">int</span> dep, <span class="type">int</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t &gt; n) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (dep == m + <span class="number">1</span>) <span class="keyword">return</span> (<span class="type">void</span>)(res += n / t * flag);</span><br><span class="line">    <span class="built_in">dfs</span>(t, dep + <span class="number">1</span>, flag);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="built_in">lcm</span>(t, a[dep]), dep + <span class="number">1</span>, -flag);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, t, <span class="built_in">res</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++ i) a[i] = <span class="built_in">read</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">put</span>(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以m等于3，<span class="math inline">\(a[]=2,3,5​\)</span>为例</p>
<p>(1,1,1)-&gt;(1,2,1),(2,2,-1)</p>
<p>​ (1,2,1)-&gt;(1,3,1),(3,3,-1)</p>
<p>​ (1,3,1)-&gt;(1,4,1),(5,4,-1)此时<span
class="math inline">\(+n-5\)</span></p>
<p>​ (3,3,-1)-&gt;(3,4,-1),(15,4,1)此时<span
class="math inline">\(-3+15\)</span></p>
<p>​ (2,2,-1)-&gt;(2,3,-1),(6,3,+1)</p>
<p>​ (2,3,-1)-&gt;(2,4,-1),(10,4,1)此时<span
class="math inline">\(-2+10\)</span></p>
<p>​ (6,3,+1)-&gt;(6,5,1),(30,4,-1)此时<span
class="math inline">\(+6-30\)</span></p>
<p>综上，<span class="math display">\[+n-5-3+15-2+10+6-30\]</span></p>
<p>一切都井然有序，天衣无缝，这个程序写得实在是太巧妙了</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>裂变链接</title>
    <url>/2020/10/14/%E8%A3%82%E5%8F%98%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<p>题目大意：异构体们需要使得他们彼此之间的能量值一样。<span id="more"></span>记第𝑖个异构体当前𝑒𝑖的能量，每个时刻，每个异构体都可以做如下三种操作中的一种：1、传递1的能量给自己左边相邻的异构体（如果存在）。2、传递1的能量给自己右边相邻的异构体（如果存在）。3、传递1的能量给自己（摸鱼）。为了尽快的回到前线作战，异构体们希望在最短的时间内使得所有异构体的能量值一样，问最短时间。数据保证有解。操作过程中自己的能量可以变为负数</p>
<p>有点像均分纸牌，但是均分纸牌是每次只能移动一堆儿，这里是<strong>每个时刻，每个异构体</strong>，所以题意上就不一样</p>
<p>想到他们均分完成之后，一定能够全部都是ave，所以我们考虑直接判断这个数字变成ave需要多少，然后把自己的需要/多余往后一个人的哪里堆积</p>
<p>但是要特判断一种情况，就是当一个人比两边都要高的时候，这时候是加和，而不是取max了</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, res, ave;</span><br><span class="line"><span class="type">int</span> a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) a[i] = <span class="built_in">read</span>(), ave += a[i], b[i] = a[i];</span><br><span class="line">    </span><br><span class="line">    ave /= n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b[i] &gt; b[i - <span class="number">1</span>] &amp;&amp; b[i] &gt; b[i + <span class="number">1</span>]) res = <span class="built_in">max</span>(res, <span class="built_in">abs</span>(b[i] - ave));</span><br><span class="line">        res = <span class="built_in">max</span>(res, <span class="built_in">abs</span>(ave - a[i]));</span><br><span class="line">        a[i + <span class="number">1</span>] -= (ave - a[i]);	</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维题</tag>
      </tags>
  </entry>
  <entry>
    <title>计数</title>
    <url>/2020/09/28/%E8%AE%A1%E6%95%B0/</url>
    <content><![CDATA[<p>题目大意：给你一个随机生成的1~n的排列。</p>
<span id="more"></span>
<p>并定义区间[l,r]的价值为<span class="math inline">\(C_{l,r} =
max(a_i-a_j|l \leq i,j \leq j)\)</span></p>
<p>部分分很好拿，但是正解并不容易做，有很多种做法，单调栈，单调队列，ST表都可以做，几乎只要是可以维护最大值最小值的数据结构都可以做</p>
<p>这里只介绍ST表的做法，一个<span
class="math inline">\(O(nlogn)\)</span>预处理，<span
class="math inline">\(O(1)\)</span>查询的数据结构</p>
<p>先预处理ST表</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pres_dou</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) f[i][<span class="number">0</span>] = a[i], g[i][<span class="number">0</span>] = a[i];</span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">log</span>(n) / <span class="built_in">log</span>(<span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; t; ++ j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n - (<span class="number">1</span> &lt;&lt; j) + <span class="number">1</span>; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i][j - <span class="number">1</span>], f[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">            g[i][j] = <span class="built_in">min</span>(g[i][j - <span class="number">1</span>], g[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查询的时候，考虑求出一个最大的<span
class="math inline">\(k\)</span>，使得<span class="math inline">\(l \leq
2^k\leq r\)</span>， 有重叠也无妨</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query_maxv</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="built_in">log</span>(r - l + <span class="number">1</span>) / <span class="built_in">log</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(f[l][k], f[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>题目分析：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">回到这个题，我们求出每一个数的最小贡献，与最大贡献，并使之加和，答案就是最大贡献与最小贡献的差</span><br><span class="line">其中，在求答案的时候，考虑这个数左右两边的端点</span><br><span class="line">显然他左边的，他都可以贡献，他右边的，他也可以贡献，并且跨越他的区间，他也会贡献</span><br></pre></td></tr></table></figure>
<p><strong>代码如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, res_minv, res_maxv;</span><br><span class="line"><span class="type">int</span> a[N], pos[N];</span><br><span class="line"><span class="type">int</span> f[N][<span class="number">66</span>], g[N][<span class="number">66</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pres_dou</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) f[i][<span class="number">0</span>] = a[i], g[i][<span class="number">0</span>] = a[i];</span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">log</span>(n) / <span class="built_in">log</span>(<span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; t; ++ j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n - (<span class="number">1</span> &lt;&lt; j) + <span class="number">1</span>; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i][j - <span class="number">1</span>], f[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">            g[i][j] = <span class="built_in">min</span>(g[i][j - <span class="number">1</span>], g[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query_maxv</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="built_in">log</span>(r - l + <span class="number">1</span>) / <span class="built_in">log</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(f[l][k], f[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query_minv</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="built_in">log</span>(r - l + <span class="number">1</span>) / <span class="built_in">log</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(g[l][k], g[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fuck_maxv</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r || l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> maxv = <span class="built_in">query_maxv</span>(l ,r);</span><br><span class="line">    res_maxv += <span class="number">1ll</span> * (<span class="number">1ll</span> * (pos[maxv] - l) * (r - pos[maxv]) + (<span class="number">1ll</span> * pos[maxv] - l) + (r - pos[maxv])) * maxv;	</span><br><span class="line">    <span class="built_in">fuck_maxv</span>(l, pos[maxv] - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">fuck_maxv</span>(pos[maxv] + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">fuck_minv</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r || l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> minv = <span class="built_in">query_minv</span>(l ,r);</span><br><span class="line">    res_minv += <span class="number">1ll</span> * (<span class="number">1ll</span> * (pos[minv] - l) * (r - pos[minv]) + (<span class="number">1ll</span> * pos[minv] - l) + (r - pos[minv])) * minv;</span><br><span class="line">    <span class="built_in">fuck_minv</span>(l, pos[minv] - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">fuck_minv</span>(pos[minv] + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T = <span class="built_in">read</span>(), i;</span><br><span class="line">    <span class="keyword">while</span> (T --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f), <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">        res_maxv = res_minv = <span class="number">0</span>;</span><br><span class="line">        n = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) a[i] = <span class="built_in">read</span>(), pos[a[i]] = i;</span><br><span class="line">        <span class="built_in">pres_dou</span>();</span><br><span class="line">        <span class="built_in">fuck_maxv</span>(<span class="number">1</span>, n), <span class="built_in">fuck_minv</span>(<span class="number">1</span>, n);</span><br><span class="line">        <span class="built_in">put</span>(res_maxv - res_minv);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>舞会配对</title>
    <url>/2020/10/20/%E8%88%9E%E4%BC%9A%E9%85%8D%E5%AF%B9/</url>
    <content><![CDATA[<p>题目大意：在 NOI2015 闭幕式舞会上有 N 个男孩和 N
个女孩，每个人都量过了自己的身高。每个男孩只跟女孩跳舞，并且女孩也只跟男孩跳舞。<span id="more"></span>每个人最多只有一个舞伴。男孩或者想和比自己高的女孩跳舞，或者想和比自己低的女孩跳舞，同样的，女孩也是或者想和比自己高的男孩跳舞，或者想和自己低的男孩跳舞。你能决定最多有多少对能在一起跳舞么？</p>
<p>正解很简单，四类人两两搭配，一个显然正确且合理的贪心：对于一个人，如果有多种选择，选择最矮的那个一定更优，双指针维护一下就好</p>
<p><del>跟着豪哥学细节：c[cntc + 1] = inf</del></p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">66</span>, inf = <span class="number">2147483647</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N], b[N], c[N], d[N];</span><br><span class="line"><span class="type">int</span> cnta, cntb, cntc, cntd;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> x &gt; y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, x, y, <span class="built_in">res</span>(<span class="number">0</span>), n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="built_in">read</span>(), y = <span class="built_in">abs</span>(x);</span><br><span class="line">        <span class="keyword">if</span> (x == y) a[++ cnta] = y;</span><br><span class="line">        <span class="keyword">else</span> b[++ cntb] = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="built_in">read</span>(), y = <span class="built_in">abs</span>(x);</span><br><span class="line">        <span class="keyword">if</span> (x == y) c[++ cntc] = y;</span><br><span class="line">        <span class="keyword">else</span> d[++ cntd] = y;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + cnta), <span class="built_in">sort</span>(d + <span class="number">1</span>, d + <span class="number">1</span> + cntd);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= cnta; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; cntd) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= cntd &amp;&amp; d[l] &lt;= a[i]) ++ l;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; d[l]) ++ res, ++ l; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + cntb, cmp), <span class="built_in">sort</span>(c + <span class="number">1</span>, c + <span class="number">1</span> + cntc, cmp);</span><br><span class="line">    </span><br><span class="line">    l = <span class="number">1</span>;</span><br><span class="line">    c[cntc + <span class="number">1</span>] = inf;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= cntb; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; cntc) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= cntc &amp;&amp; c[l] &gt;= b[i]) ++ l;</span><br><span class="line">        <span class="keyword">if</span> (b[i] &gt; c[l]) ++ res, ++ l;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">put</span>(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<p>考试时候一开始就想写暴力，然后写了二分图，因为距离上一次写板子已经过去三个月了，所以这次写板子还调了一会，一开始还建了个双向边….导致写暴力就花了1h没时间想正解，或者说想到了，没时间也没赶写</p>
<p>本质上，还是对板子不够熟练，知识点有盲区，我假如可以半小时写完暴力，再搭配上最后的二十分钟，就总计可以有五十分钟的时间来写正解</p>
<p>可惜，那是<strong>假如</strong></p>
<p>期望得分：100+50+？pts</p>
<p>实际得分：90+40+30pts</p>
<p>在稳步提升，不是我变强了，也不是他们变菜了（他们一直都很菜），是我的做题策略改变了，终于不再傻逼兮兮的上来就猛干正解，最后正解没肝出来，暴力也没打上</p>
<p>以后在保证暴力正确性的前提下，缩短暴力时间，正解还是要写的</p>
<p><strong>我想AK</strong></p>
<p>虎瘦雄心在，人穷志不短，无论落魄到何种地步，都不要触碰做人的底线，心怀勇气的走下去，只有这样，一切才会好起来</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>评分</title>
    <url>/2020/10/03/%E8%AF%84%E5%88%86/</url>
    <content><![CDATA[<p>题目大意：你参加了一次比赛，共有 𝑛（奇数）个评委给你打分，
<span id="more"></span> 编号为 1 到 𝑛
。你最终的得分通过如下方式得到：评委们按编号排成一排，每次取出前三名评委，留下其中评分的中位数并将其加入队尾，直到只剩最后一名评委，该评委的评分就
是你最终的得分。现在你知道了所有评委的评分和部分评委的编号，你想要知道，对于剩余评委所有可能的编号情况中，你的得分最高能达到多少。</p>
<p>我们正着搞貌似有点麻烦，所以考虑二分，转化成一个判定型问题（其实考试的时候我想到二分了，但是没有细想，也没有时间，因为我觉得这题暴力分拿满就行了，并且搜索题还没写，略微有点慌）</p>
<p>我们考虑‘01规划’，把大于mid的都判定为1，小与mid的判定为0，</p>
<p>由题可知，我们每次取出三个数，我们希望结果是大于等于mid的，所以我们就要这三个数里面有两个1</p>
<p><strong>然后考虑每个数如何变为1，设<span
class="math inline">\(f(x)\)</span>表示表示x这个数字变成1需要多少个1</strong></p>
<p>显然：</p>
<p><span
class="math inline">\(f(mid^+)=0​\)</span>大于mid的数，不需要变化，所以为0</p>
<p><span
class="math inline">\(f(mid^-)=inf​\)</span>小于mid的数字，变不成，所以为inf</p>
<p><span
class="math inline">\(f(?)=1​\)</span>未知大小，显然可以一次变成</p>
<p>其实代码在执行的时候，会不停的判定，许多不合法的情况都会给false掉</p>
<p>注意在二分的时候，我们是找，“在某一个区间范围内的最大值”，所以固定的格式要记住</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">66</span>, inf = <span class="number">214748364</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">s</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">w</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)&#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) w = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) s = s * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s * w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (! x) <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">num</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="type">char</span> c[<span class="number">66</span>];</span><br><span class="line">    <span class="keyword">while</span> (x) c[++ num] = x % <span class="number">10</span> + <span class="number">48</span>, x /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (num) <span class="built_in">putchar</span>(c[num --]);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line"><span class="type">int</span> n, m, res;</span><br><span class="line"><span class="type">int</span> num[N], num2[N], val[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, <span class="built_in">lim</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n - m; ++ i) <span class="keyword">if</span> (num2[i] &gt;= x) ++ lim;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) q.<span class="built_in">push</span>(num[i] ? (num[i] &gt;= x ? <span class="number">0</span> : inf) : <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (! q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        a = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (q.<span class="built_in">empty</span>()) <span class="keyword">return</span> a &lt;= lim;</span><br><span class="line">        b = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();	</span><br><span class="line">        c = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="built_in">min</span>(inf, <span class="built_in">min</span>(a + b, <span class="built_in">min</span>(a + c, b + c))));</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, k; </span><br><span class="line"></span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        j = <span class="built_in">read</span>(), k = <span class="built_in">read</span>();</span><br><span class="line">        num[k] = val[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n - m; ++ i) val[i + m] = num2[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">sort</span>(val + <span class="number">1</span>, val + n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = n;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">pd</span>(val[mid])) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">put</span>(val[l]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>赌注</title>
    <url>/2020/10/21/%E8%B5%8C%E6%B3%A8/</url>
    <content><![CDATA[<p>题目大意：这 N
个分身每个都是庄家。你可以到庄家那边下注，每次可以猜大猜小，猜一次一元钱。每一次开彩前，你都可以到任意个庄家那里下赌注。<span id="more"></span>如果开彩结果是大，你就可以得到你之前猜大的庄家相应的
ai元钱。如果开彩结果是小，你就可以得到你之前猜小的庄家相应的
bi元钱。你可以在同一个庄家那里既猜大又猜小（这样是两块钱），也可以什么都不猜（这样不用钱）。想要从它的分身中坑走尽量多的钱。但是会根据你下注的信息控制开彩的结果，让你赢的钱数尽量少。问怎么样下注，才能坑走神仙
czk 最多的钱</p>
<p>这题不难，是个贪心，可是考试时候怎么没有想到呢</p>
<p>题目转化：给定a，b两个序列，每次从a中选定一些数字，b中选定一些数字，其和分别即为
<span class="math inline">\(sum_a,sum_b\)</span></p>
<p>取 <span class="math display">\[ans=\dfrac
{min(sum_a,sum_b)}{(num_a+num_b)}\]</span></p>
<p>首先我们给他排个序，一定不会更差</p>
<p>考虑当我们取sumb为答案的时候，也就是suma一定比sumb大的时候的情况，维护双指针，挨个就可以了</p>
<p>然后再考虑取suma为答案的时候，也就是sumb一定比suma大的时候的情况</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> a[N], b[N], res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">double</span> x , <span class="type">double</span> y)</span></span>&#123;<span class="keyword">return</span> x &gt; y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">scanf</span> (<span class="string">&quot;%lf%lf&quot;</span>, &amp;a[i], &amp;b[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n, cmp), <span class="built_in">sort</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + n, cmp);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">suma</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">sumb</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="function"><span class="type">int</span> <span class="title">tot</span><span class="params">(<span class="number">1</span>)</span>, <span class="title">num</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        suma += a[i]; ++ num;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (sumb + b[tot] &lt;= suma &amp;&amp; tot &lt;= n)</span><br><span class="line">        &#123;</span><br><span class="line">            sumb += b[tot ++]; ++ num;</span><br><span class="line">            res = <span class="built_in">max</span>(res, sumb - num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tot &gt; n) <span class="keyword">break</span>;</span><br><span class="line">        res = <span class="built_in">max</span>(res, sumb - num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    suma = sumb = <span class="number">0</span>; tot = <span class="number">1</span>, num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        sumb += b[i]; ++ num;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (suma + a[tot] &lt;= sumb &amp;&amp; tot &lt;= n)</span><br><span class="line">        &#123;</span><br><span class="line">            suma += a[tot ++]; ++ num;</span><br><span class="line">            res = <span class="built_in">max</span>(res, suma - num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tot &gt; n) <span class="keyword">break</span>;</span><br><span class="line">        res = <span class="built_in">max</span>(res, suma - num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%.4lf&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>运输任务</title>
    <url>/2020/10/23/%E8%BF%90%E8%BE%93%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<p>题目大意：一棵树，要依此经过好多点，
有的有向边每经过一次，费用翻倍，问最后的费用是多少<span id="more"></span></p>
<p>看到这些路径问题，就联想树上差分</p>
<p>我们记录一个<span
class="math inline">\(up[x]\)</span>表示由x指出来的边，<span
class="math inline">\(down[x]\)</span>表示由<span
class="math inline">\(fa[x]\)</span>指向x的边</p>
<p>然后树上差分一下就好了</p>
<p>回顾树上差分的知识：</p>
<p>点差分：</p>
<p><span
class="math inline">\(d[s]-1,d[lca]-1\)</span>相当于对他的lca直系的left侧仅次于lca的一个节点到s进行操作，公式表示为<span
class="math inline">\(d[lca]-1=a[lca]-(a[left]+1)\)</span></p>
<p><span
class="math inline">\(d[t]-1,d[lca_{fa}]-1\)</span>相当于对lca到lca的直系的right侧直到t进行操作，公式表示为<span
class="math inline">\(d[lca_{fa}] -
1=a[lca_{fa}]-(a[lca]+1)\)</span></p>
<p>边差分：</p>
<p><span class="math inline">\(d[s]-1,d[t]-1,d[lca]-=2\)</span></p>
<p>还有一个小知识：<span
class="math inline">\(2^0+2^1+2^2+...2^i=2^{i+1}-1​\)</span></p>
<p>然后这就是一个树上差分的板子题了，<strong>注意开ll并且1e6的K</strong></p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#define int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">ll res;</span><br><span class="line"><span class="type">int</span> dep[N], fa[N][<span class="number">34</span>], base[N], up[N], down[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, y;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">30</span>; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (fa[x][i - <span class="number">1</span>]) fa[x][i] = fa[fa[x][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = head[x]; i; i = nex[i])</span><br><span class="line">    &#123;</span><br><span class="line">        y = ver[i];</span><br><span class="line">        <span class="keyword">if</span> (y == fa[x][<span class="number">0</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        fa[y][<span class="number">0</span>] = x;</span><br><span class="line">        dep[y] = dep[x] + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[x] &lt; dep[y]) <span class="built_in">swap</span>(x, y);</span><br><span class="line">    <span class="type">int</span> delta = dep[x] - dep[y], i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; -- i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (delta &amp; (<span class="number">1</span> &lt;&lt; i))</span><br><span class="line">        &#123;</span><br><span class="line">            x = fa[x][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; -- i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (fa[x][i] != fa[y][i])</span><br><span class="line">        &#123;</span><br><span class="line">            x = fa[x][i], y = fa[y][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Gres</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> yhm_fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, y;</span><br><span class="line">    <span class="keyword">for</span> (i = head[x]; i; i = nex[i])</span><br><span class="line">    &#123;</span><br><span class="line">        y = ver[i];</span><br><span class="line">        <span class="keyword">if</span> (y == yhm_fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">Gres</span>(y, x);</span><br><span class="line">        up[x] += up[y];</span><br><span class="line">        down[x] += down[y];</span><br><span class="line">        <span class="keyword">if</span> (len[i] == <span class="number">1</span>) res = (res + (<span class="number">1ll</span> * base[down[y]] - <span class="number">1</span> + mod) % mod) % mod;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (len[i ^ <span class="number">1</span>] == <span class="number">1</span>) res = ((res + <span class="number">1ll</span> * base[up[y]] - <span class="number">1</span> + mod) % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, x, y, z; n = <span class="built_in">read</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>(), z = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span> (! z) <span class="built_in">add_edge</span>(x, y, z), <span class="built_in">add_edge</span>(y, x, z);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">add_edge</span>(x, y, <span class="number">0</span>), <span class="built_in">add_edge</span>(y, x, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>), base[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++ i) base[i] = (<span class="number">1ll</span> * base[i - <span class="number">1</span>] * <span class="number">2</span>) % mod;</span><br><span class="line"></span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        y = <span class="built_in">read</span>();</span><br><span class="line">        <span class="type">int</span> LCA = <span class="built_in">lca</span>(x, y);</span><br><span class="line">        ++ up[x], -- up[LCA];</span><br><span class="line">        ++ down[y], -- down[LCA];</span><br><span class="line">        x = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Gres</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">put</span>(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<p>期望得分：100+0+50pts</p>
<p>实际得分：50+0+20pts</p>
<p>第一题因为ll和一个小细节挂掉50分，第二题没想到树上差分，第三题暴力写的太暴力了，T了30分</p>
<p>归根结底是没有对知识构建一个合理的知识体系，以后要多自己回想知识体系</p>
<p>毕竟每一章节算法不多，枚举用哪个就好。。</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>树上差分</tag>
      </tags>
  </entry>
  <entry>
    <title>轰炸</title>
    <url>/2020/10/18/%E8%BD%B0%E7%82%B8/</url>
    <content><![CDATA[<p>题目大意：n 个点，m
条边的有向图，每次选择若干点将其标记，不能存在两个不同的点 i,j
满足可以从 i 到达 j。问最少取几次可以使所有点都被标记过。<span id="more"></span></p>
<p>缩完点之后跑DAG的最长路</p>
<p>傻逼的错误示范：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    val[x] = siz[x];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = heads[x]; i; i = nexs[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y = vers[i];</span><br><span class="line">        <span class="keyword">if</span> (val[y]) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y);</span><br><span class="line">        val[x] += val[y];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>归根结底还是思路没有捋清楚，或者说，经过将近一个半小时的思考，思路混乱了，在最接近正解的时候挂掉了</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ver[N &lt;&lt; <span class="number">1</span>], nex[N &lt;&lt; <span class="number">1</span>], head[N], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ver[++ cnt] = y;</span><br><span class="line">    nex[cnt] = head[x];</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(head[x] = cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, res, ret;</span><br><span class="line"><span class="type">int</span> num, top, tot;</span><br><span class="line"><span class="type">int</span> dfn[N], low[N], in[N], sta[N], tar[N], siz[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x] = low[x] = ++ tot; in[x] = <span class="number">1</span>, sta[++ top] = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = nex[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y = ver[i];</span><br><span class="line">        <span class="keyword">if</span> (! dfn[y])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(y);</span><br><span class="line">            low[x] = <span class="built_in">min</span>(low[x], low[y]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (in[y]) low[x] = <span class="built_in">min</span>(low[x], dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (low[x] == dfn[x])</span><br><span class="line">    &#123;</span><br><span class="line">        ++ num;</span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            y = sta[top --]; in[y] = <span class="number">0</span>;</span><br><span class="line">            tar[y] = num;</span><br><span class="line">            ++ siz[num];</span><br><span class="line">        &#125;<span class="keyword">while</span> (x != y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue&lt;<span class="type">int</span>&gt;q; <span class="type">int</span> rd[N], cd[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> vers[N], nexs[N], heads[N], cnts;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vers[++ cnts] = y;</span><br><span class="line">    nexs[cnts] = heads[x];</span><br><span class="line">    ++ rd[y], ++ cd[x];</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(heads[x] = cnts);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> val[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (val[x]) <span class="keyword">return</span> val[x];</span><br><span class="line">    <span class="type">int</span> now = siz[x];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = heads[x]; i; i = nexs[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y = vers[i];</span><br><span class="line">        now = <span class="built_in">max</span>(now, <span class="built_in">dfs</span>(y) + siz[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val[x] = now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//	freopen(&quot;t2.in&quot;, &quot;r&quot;, stdin), freopen(&quot;t2.out&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">add_edge</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="keyword">if</span> (! dfn[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">1</span>; x &lt;= n; ++ x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = head[x]; i; i = nex[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> y = ver[i];</span><br><span class="line">            <span class="keyword">if</span> (tar[x] == tar[y]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;x-&gt;&quot; &lt;&lt; x &lt;&lt; &quot; y-&gt;&quot; &lt;&lt; y &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;tar[x]-&gt;&quot; &lt;&lt; tar[x] &lt;&lt; &quot; tar[y]-&gt;&quot; &lt;&lt; tar[y] &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">            <span class="built_in">add</span>(tar[x], tar[y]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;num----&gt;&quot; &lt;&lt; num &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= num; ++ i) res = <span class="built_in">max</span>(res, <span class="built_in">dfs</span>(i));</span><br><span class="line">    <span class="built_in">put</span>(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<p>真的好难受，本以为A掉的题结果挂了，就差那么一点啊，真的就一点啊</p>
<p>期望得分：100+100+30pts</p>
<p>实际得分：0+20+30pts</p>
<p>第一题纯属傻逼，看不出来是壮压</p>
<p>第二题真可惜</p>
<p>第三题，放弃了，打暴力就走了</p>
<p>虎瘦雄心在，人穷志不短，无论落魄到何种地步，都要坚守做人的底线，心怀勇气的走下去，只有这样才会慢慢好起来</p>
<p>我相信我自己没有问题，我一定会起来的！</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>遗传病</title>
    <url>/2020/11/16/%E9%81%97%E4%BC%A0%E7%97%85/</url>
    <content><![CDATA[<p>题目大意:动态维护一个序列的gcd为1的数目<span id="more"></span></p>
<p>这题容斥...</p>
<p>两个数互质等价于质因数的集合交集为空集,记 |S|
为当前已登记的人中质因子集合的子集有S的个数,其中S是一个质因数集合</p>
<p>特别的|{1}| = 等于当前登记人数</p>
<p>与30互质的数的个数:|{1}| - |{2}| - |{3}| - |{5}| + |{2, 3}| + |{2,
5}| + |{3, 5}| - |{2, 3, 5}|</p>
<p>并且通过手算我们可以知道,素质子前六个撑起来就大于5e5了</p>
<p>所以<span class="math inline">\(2^6 \times
n\)</span>还是可以接受的</p>
<p>代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, q, tot, las;</span><br><span class="line"><span class="type">int</span> a[N], cnt[N * <span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> rec[N * <span class="number">5</span>][<span class="number">10</span>];</span><br><span class="line"><span class="type">bool</span> vis[N * <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">yhm_div</span><span class="params">(<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, x = a[pos];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i * i &lt;= x; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            rec[a[pos]][++ rec[a[pos]][<span class="number">0</span>]] = i;</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) rec[a[pos]][++ rec[a[pos]][<span class="number">0</span>]] = x;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, <span class="built_in">res</span>(<span class="number">0</span>), MAXSTATE = (<span class="number">1</span> &lt;&lt; rec[x][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; MAXSTATE; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> tmp = <span class="number">1</span>, num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; rec[x][<span class="number">0</span>]; ++ j) <span class="keyword">if</span> (i &amp; (<span class="number">1</span> &lt;&lt; j)) tmp *= rec[x][j + <span class="number">1</span>], ++ num;</span><br><span class="line">        res += (num &amp; <span class="number">1</span>) ? cnt[tmp] : -cnt[tmp];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">updata</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> delta)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, MAXSTATE = (<span class="number">1</span> &lt;&lt; rec[x][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; MAXSTATE; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; rec[x][<span class="number">0</span>]; ++ j) <span class="keyword">if</span> (i &amp; (<span class="number">1</span> &lt;&lt; j)) tmp *= rec[x][j + <span class="number">1</span>];</span><br><span class="line">        cnt[tmp] += delta;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, x, add;</span><br><span class="line">    n = <span class="built_in">read</span>(), q = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) a[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="keyword">if</span> (! rec[a[i]][<span class="number">0</span>]) <span class="built_in">yhm_div</span>(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q --)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="built_in">read</span>(), add = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (! vis[x])</span><br><span class="line">        &#123;</span><br><span class="line">            vis[x] = <span class="number">1</span>, add = tot ++;</span><br><span class="line">            <span class="keyword">if</span> (a[x] != <span class="number">1</span>) add -= <span class="built_in">func</span>(a[x]);</span><br><span class="line">            <span class="keyword">else</span> ++ cnt[<span class="number">1</span>];</span><br><span class="line">            <span class="built_in">updata</span>(a[x], <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">put</span>((las += add));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            vis[x] = <span class="number">0</span>, add = -- tot;</span><br><span class="line">            <span class="built_in">updata</span>(a[x], <span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span> (a[x] != <span class="number">1</span>) add -= <span class="built_in">func</span>(a[x]);</span><br><span class="line">            <span class="keyword">else</span> -- cnt[<span class="number">1</span>];</span><br><span class="line">            <span class="built_in">put</span>((las -= add));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后记:</p>
<p>此题思想相当好,非常巧妙也非常自然,水到渠成的感觉</p>
<p>但是小细节也多,比如updata的时候必须从1开始否则就会出问题</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>透彻血堂</title>
    <url>/2020/11/14/%E9%80%8F%E5%BD%BB%E8%A1%80%E5%A0%82/</url>
    <content><![CDATA[<p>题目大意：动态维护区间最大子段和<span id="more"></span></p>
<p>看到区间，考虑线段树，ST表，差分一系列的数据结构</p>
<p>然后看到最大子段和筛选出用线段树</p>
<p>我们维护多个变量分别如下：</p>
<blockquote>
<p>tag :区间标记，1退房0开房</p>
<p>lmax:紧靠左侧的最大子段和</p>
<p>rmax:紧靠右侧的最大子段和</p>
<p>dat:整个区间的最大子段和</p>
<p>len:区间长度</p>
</blockquote>
<p><strong>其实线段树最主要的就是考虑up，down</strong></p>
<p>考场上就是卡在了不知道怎么维护l，rmax上</p>
<p>出了组数据把自己hack了发现区间的lmax为什么不仅仅是左儿子的lmax还有右儿子的lmax考场上当时第一题没写出来心里很**</p>
<p>所以就弃疗了</p>
<p>现在想想也没什么，再手跑一下其实就出来了</p>
<p>然后还有一个很精彩的地方就是求最大子段和的左端点，不同于正常的线段树</p>
<p>直接分为左儿子，右儿子，中间三部分</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e4</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SEGMENTTREE</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> lmax, rmax, dat, tag, len;</span><br><span class="line">&#125;tree[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = p &lt;&lt; <span class="number">1</span>, r = (p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>;</span><br><span class="line">    tree[p].lmax = (tree[l].lmax == tree[l].len) ? tree[l].lmax + tree[r].lmax : tree[l].lmax;</span><br><span class="line">    tree[p].rmax = (tree[r].rmax == tree[r].len) ? tree[r].rmax + tree[l].rmax : tree[r].rmax;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(tree[p].dat = <span class="built_in">max</span>(<span class="built_in">max</span>(tree[l].dat, tree[r].dat), tree[l].rmax + tree[r].lmax));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (! tree[p].tag) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> l = p &lt;&lt; <span class="number">1</span>, r = (p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>, c = tree[p].tag;</span><br><span class="line">    tree[l].tag = tree[r].tag = c;</span><br><span class="line">    tree[l].dat = tree[l].lmax = tree[l].rmax = (c == <span class="number">1</span>) ? tree[l].len : <span class="number">0</span>;</span><br><span class="line">    tree[r].dat = tree[r].lmax = tree[r].rmax = (c == <span class="number">1</span>) ? tree[r].len : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(tree[p].tag = <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[p].dat = tree[p].lmax = tree[p].rmax = tree[p].len = r - l + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(p &lt;&lt; <span class="number">1</span>, l, mid), <span class="built_in">build</span>((p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(<span class="built_in">up</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">updata</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> nl, <span class="type">int</span> nr, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nl &lt;= l &amp;&amp; nr &gt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[p].dat = tree[p].lmax = tree[p].rmax = (c == <span class="number">1</span>) ? tree[p].len : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">void</span>)(tree[p].tag = c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">down</span>(p);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (nl &lt;= mid) <span class="built_in">updata</span>(p &lt;&lt; <span class="number">1</span>, l, mid, nl, nr, c);</span><br><span class="line">    <span class="keyword">if</span> (nr &gt; mid) <span class="built_in">updata</span>((p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>, mid + <span class="number">1</span>, r, nl, nr, c);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(<span class="built_in">up</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="built_in">down</span>(p);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (tree[p &lt;&lt; <span class="number">1</span>].dat &gt;= c) <span class="keyword">return</span> <span class="built_in">query</span>(p &lt;&lt; <span class="number">1</span>, l, mid, c);</span><br><span class="line">    <span class="keyword">if</span> (tree[p &lt;&lt; <span class="number">1</span>].rmax + tree[(p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>].lmax &gt;= c) <span class="keyword">return</span> mid - tree[p &lt;&lt; <span class="number">1</span>].rmax + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>((p &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>, mid + <span class="number">1</span>, r, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, x, y, opt;</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        opt = <span class="built_in">read</span>(), x = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (tree[<span class="number">1</span>].dat &lt; x) <span class="built_in">put</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> id = <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, x);</span><br><span class="line">                <span class="built_in">updata</span>(<span class="number">1</span>, <span class="number">1</span>, n, id, id + x - <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">                <span class="built_in">put</span>(id);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="number">2</span>) y = <span class="built_in">read</span>(), <span class="built_in">updata</span>(<span class="number">1</span>, <span class="number">1</span>, n, x, x + y - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>道路</title>
    <url>/2020/11/16/%E9%81%93%E8%B7%AF/</url>
    <content><![CDATA[<p>题目大意:
我们看见了一个由m行n列的1*1的格子组成的矩阵，每个格子(i,j)有对应的高度h[i][j]和初始的一个非负权值v[i][j]。<span id="more"></span>我们可以随便选择一个格子作为起点，然后在接下来的每一步当中，我们能且只能到达与当前格子有边相邻的四个格子中的高度不超过当前格子高度的格子，每当我们到达一个新格子（包括一开始选择的初始格子），我们就能得到该格子的权值分，然后该格子的权值就会等概率变成不比当前的权值大的一个非负权值。每一个格子在满足前面条件情况下，可以走任意多次。我们希望得到一个最大的期望权值和路径，并给出这个最大的期望权值和。</p>
<p>这题说白了就是选定一个点，然后不定走走走，但是有个特殊的地方就是这个点走过一次之后的权值会等概率的变成不大于当前权值的一个数字</p>
<p>来自一位大佬的话,每一次取完之后如果可以回来的话取值范围:[0,v_i],平均期望就是0.5v_i</p>
<p>所以<span class="math inline">\(v_i+0.5v_i+0.25v_i +
...-&gt;2v_i\)</span></p>
<p>然后我们考虑对每一个块缩点,缩点之后拓扑排序求最长路</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">66</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dirx[<span class="number">5</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> diry[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, res, sum;</span><br><span class="line"><span class="type">int</span> h[N][N], v[N][N], bel[N][N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;e[N * N];</span><br><span class="line"><span class="type">int</span> f[N * N], val[N * N], lix[N * N], liy[N * N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> tx, <span class="type">int</span> ty)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">l</span><span class="params">(<span class="number">1</span>)</span>, <span class="title">r</span><span class="params">(<span class="number">1</span>)</span>, x, y, nx, ny, i</span>;</span><br><span class="line">    lix[<span class="number">1</span>] = tx, liy[<span class="number">1</span>] = ty, val[sum] = v[tx][ty], bel[tx][ty] = sum;</span><br><span class="line">    <span class="keyword">for</span> (; l &lt;= r; ++ l)</span><br><span class="line">    &#123;</span><br><span class="line">        x = lix[l], y = liy[l];</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            nx = x + dirx[i], ny = y + diry[i];</span><br><span class="line">            <span class="keyword">if</span> (! nx || nx &gt; m || ! ny || ny &gt; n || h[nx][ny] != h[x][y] || bel[nx][ny]) <span class="keyword">continue</span>;</span><br><span class="line">            lix[++ r] = nx, liy[r] = ny;</span><br><span class="line">            val[sum] += v[nx][ny];</span><br><span class="line">            bel[nx][ny] = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r &gt; <span class="number">1</span>) val[sum] *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f[x] != <span class="number">-1</span>) <span class="keyword">return</span> f[x];</span><br><span class="line">    f[x] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (<span class="type">int</span>)e[x].<span class="built_in">size</span>(); ++ j) f[x] = <span class="built_in">max</span>(f[x], <span class="built_in">func</span>(e[x][j]));</span><br><span class="line">    f[x] += val[x];</span><br><span class="line">    <span class="keyword">return</span> f[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">    <span class="type">int</span> i, j, x, y;</span><br><span class="line">    m = <span class="built_in">read</span>(), n = <span class="built_in">read</span>(), <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++ i) <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; ++ j) h[i][j] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++ i) <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; ++ j) v[i][j] = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; ++ i) <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; ++ j) <span class="keyword">if</span> (! bel[i][j]) ++ sum, <span class="built_in">bfs</span>(i, j);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (x = <span class="number">1</span>; x &lt;= m; ++ x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (y = <span class="number">1</span>; y &lt;= n; ++ y)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++ i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> nx = x + dirx[i], ny = y + diry[i];</span><br><span class="line">                <span class="keyword">if</span> (! nx || nx &gt; m || ! ny || ny &gt; n || h[nx][ny] &gt;= h[x][y]) <span class="keyword">continue</span>;</span><br><span class="line">                e[bel[x][y]].<span class="built_in">push_back</span>(bel[nx][ny]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= sum; ++ i) res = <span class="built_in">max</span>(res, <span class="built_in">func</span>(i));</span><br><span class="line">    <span class="built_in">put</span>(res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>金条</title>
    <url>/2020/11/11/%E9%87%91%E6%9D%A1/</url>
    <content><![CDATA[<p>题目大意：小林在一家商店里购物，共有 i 件物品，第 i 件物品的价格为
i。小林身上带 了许多金条，每根金条的价值都为整数，价值为 1~N
的金条数量都足够多。
对于任何一件物品，小林只会用同一价值的若干金条购买它，而且不能找零。
因此，对于第 i 件物品，会有 C(i)种购买方法。小林只会选择这样的一件物品 i
进行购买：C(i) &gt; max{ C(j) }， 1 &lt;= j &lt; i。
请你告诉小林，他能购买的最贵的物品的价格是多少。<span id="more"></span></p>
<p>看起来很麻烦其实就是求n以内的最大的<a
href="https://www.luogu.com.cn/problem/P1463">反质数</a></p>
<p>有几个性质或者结论定理：</p>
<ul>
<li>1 ~ n中最大的反质数，是1 ~ n 中约数个数最多的数中最小的一个</li>
</ul>
<p>对于ans，设任意的一个x，显然满足：</p>
<p>若x小于ans，则f(x)&lt;f(ans)</p>
<p>若x大于ans，则f(x) &lt;f(ans)</p>
<p>第一个性质说明这个ans是反质数，第二个性质说明大于ans的都不是反质数，顾ans即为所求</p>
<ul>
<li>一个数的约数的个数等于所有素因子的次数+1的乘积</li>
</ul>
<p><span class="math inline">\(48=2^4\times 3^1\)</span></p>
<p>因此有<span class="math inline">\((4+1)\times
(1+1)\)</span>个约数</p>
<p>这是显然的到道理</p>
<ul>
<li>关于反质数：x的质因子是连续的多干戈最小的质数，并且质数单调递减</li>
</ul>
<p>记住就好</p>
<p>代码如下：（根绝性质dfs）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> p[<span class="number">13</span>] = &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>&#125;;</span><br><span class="line"><span class="type">int</span> n, ans, gans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">DFS</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> gx, <span class="type">int</span> id, <span class="type">int</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (gx == gans &amp;&amp; x &lt; ans) ans = x;</span><br><span class="line">    <span class="keyword">if</span> (gx &gt; gans) ans = x, gans = gx;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x * p[id] &lt;= n)</span><br><span class="line">        &#123;</span><br><span class="line">            x *= p[id];</span><br><span class="line">            <span class="built_in">DFS</span>(x, gx * (i + <span class="number">1</span>), id + <span class="number">1</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">DFS</span> (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">20</span>);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>铁球落地</title>
    <url>/2020/11/14/%E9%93%81%E7%90%83%E8%90%BD%E5%9C%B0/</url>
    <content><![CDATA[<p>题目来源：<a
href="https://www.luogu.com.cn/problem/P1442">铁球落地</a></p>
<p>题目大意：从一个木板上往下掉，大致就是如此的模型<span id="more"></span></p>
<p>正解是线段树优化dp，但是我不会，</p>
<p>可以用比较暴力的最短路来解决</p>
<p>中间有很多小细节需要处理，比如我接下来与谁连边等等，处理好了可以优化很多复杂度</p>
<p>代码连边那里暂时没有看懂会头会补上的</p>
<p>题解代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span> (disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e5</span> + <span class="number">5</span>, maxm = <span class="number">4e5</span> + <span class="number">5</span>, inf = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="type">int</span> head[maxm], nxt[maxm], v[maxm], w[maxm], h[maxn], x[maxn], y[maxn], dis[maxn];<span class="comment">//h为高度，xy为左右端点</span></span><br><span class="line"><span class="type">bool</span> vis[maxn];</span><br><span class="line"><span class="type">int</span> n, m, cnt, sx, sy;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addline</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> </span>&#123; v[cnt] = y, w[cnt] = z, nxt[cnt] = head[x], head[x] = cnt++; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">char</span> c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c&lt;<span class="string">&#x27;0&#x27;</span> || c&gt;<span class="string">&#x27;9&#x27;</span>) c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (c &gt;= <span class="string">&#x27;0&#x27;</span>&amp;&amp;c &lt;= <span class="string">&#x27;9&#x27;</span>) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + c - <span class="string">&#x27;0&#x27;</span>, c = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">qsort</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span><span class="comment">//手写快排</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">int</span> mid = h[(l + r) &gt;&gt; <span class="number">1</span>], L = l, R = r;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (h[l] &gt; mid)	l++;</span><br><span class="line">        <span class="keyword">while</span> (h[r] &lt; mid)	r--;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= r) &#123; <span class="built_in">swap</span>(h[l], h[r]), <span class="built_in">swap</span>(x[l], x[r]), <span class="built_in">swap</span>(y[l], y[r]), l++, r--; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (L &lt; r)	<span class="built_in">qsort</span>(L, r);</span><br><span class="line">    <span class="keyword">if</span> (l &lt; R)	<span class="built_in">qsort</span>(l, R);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">connect</span><span class="params">()</span><span class="comment">//重点操作：连边</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//0号为铁球，一倍点（1-n）为左端点，二倍点（n+1-2n)为右端点，2*n+1为地板（最终汇点）</span></span><br><span class="line">    <span class="built_in">addline</span>(<span class="number">0</span>, <span class="number">1</span>, sy - h[<span class="number">1</span>] + sx - x[<span class="number">1</span>]), <span class="built_in">addline</span>(<span class="number">0</span>, n + <span class="number">1</span>, sy - h[<span class="number">1</span>] + y[<span class="number">1</span>] - sx);</span><br><span class="line">    <span class="comment">//应该是数据原因导致排序后第一块木板一定在铁球下方，所以让其和木板的左右两端点相连，假如改数据也没问题，在读入时把大于小球高度的木板全部删除，再在这个函数中按高度枚举到能接到小球的木板当成1号木板即可</span></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; Q;<span class="comment">//用队列辅助链接</span></span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>())	Q.<span class="built_in">pop</span>();</span><br><span class="line">    Q.<span class="built_in">push</span>(<span class="number">1</span>);<span class="comment">//第一块木板入队</span></span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">bool</span> left = <span class="literal">false</span>, right = <span class="literal">false</span>;<span class="comment">//小剪枝：左右都有木板承接就可以不用枚举了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; h[i] &gt; h[j] &amp;&amp; h[i] - h[j] &lt;= m &amp;&amp; j &lt;= n; j++)<span class="comment">//暴力枚举能落下的木板</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!left &amp;&amp; x[j] &lt; x[i] &amp;&amp; x[i] &lt; y[j])<span class="comment">//计算木板i的左端点是否能落到木板j，根据不等式推一下就明白了</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//如果可以</span></span><br><span class="line">                <span class="built_in">addline</span>(i, j, h[i] - h[j] + x[i] - x[j]);<span class="comment">//木板i的左端点链接木板j的左端点</span></span><br><span class="line">                <span class="built_in">addline</span>(i, j + n, h[i] - h[j] + y[j] - x[i]);<span class="comment">//木板i的左端点链接木板j的右端点（二倍点）</span></span><br><span class="line">                left = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (!vis[j])	Q.<span class="built_in">push</span>(j), vis[j] = <span class="literal">true</span>;<span class="comment">//j没入队过才能搜，防止搜多超时</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!right &amp;&amp; x[j] &lt; y[i] &amp;&amp; y[i] &lt; y[j])<span class="comment">//计算木板i的右端点是否能落到木板j，与上面同理</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">addline</span>(i + n, j, h[i] - h[j] + y[i] - x[j]);</span><br><span class="line">                <span class="built_in">addline</span>(i + n, j + n, h[i] - h[j] + y[j] - y[i]);</span><br><span class="line">                right = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (!vis[j])	Q.<span class="built_in">push</span>(j), vis[j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left &amp;&amp; right)	<span class="keyword">break</span>;<span class="comment">//左右端点都有木板接着就不用枚举了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!left&amp;&amp;h[i] &lt;= m)	<span class="built_in">addline</span>(i, n &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, h[i]);<span class="comment">//如果左端点没有落点，判断能不能落到地上(点为2*n+1)</span></span><br><span class="line">        <span class="keyword">if</span> (!right&amp;&amp;h[i] &lt;= m)	<span class="built_in">addline</span>(i + n, n &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, h[i]);<span class="comment">//判断右端点，同理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">SPFA</span><span class="params">()</span><span class="comment">//SPFA+SLF优化</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>())	Q.<span class="built_in">pop_back</span>();</span><br><span class="line">    dis[<span class="number">0</span>] = <span class="number">0</span>, Q.<span class="built_in">push_back</span>(<span class="number">0</span>), vis[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!Q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = Q.<span class="built_in">front</span>(); Q.<span class="built_in">pop_front</span>(); vis[x] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">register</span> <span class="type">int</span> i = head[x]; i != <span class="number">-1</span>; i = nxt[i])</span><br><span class="line">            <span class="keyword">if</span> (dis[v[i]] &gt; dis[x] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v[i]] = dis[x] + w[i];</span><br><span class="line">                <span class="keyword">if</span> (!vis[v[i]])</span><br><span class="line">                &#123;</span><br><span class="line">                    vis[v[i]] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (!Q.<span class="built_in">empty</span>())</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> (dis[v[i]] &gt; dis[Q.<span class="built_in">front</span>()])	Q.<span class="built_in">push_back</span>(v[i]);</span><br><span class="line">                        <span class="keyword">else</span>  Q.<span class="built_in">push_front</span>(v[i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>  Q.<span class="built_in">push_back</span>(v[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line">    n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>(), sx = <span class="built_in">read</span>(), sy = <span class="built_in">read</span>();<span class="comment">//sx,sy为小球坐标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)	h[i] = <span class="built_in">read</span>(), x[i] = <span class="built_in">read</span>(), y[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">qsort</span>(<span class="number">1</span>, n), <span class="built_in">connect</span>(), <span class="built_in">SPFA</span>();<span class="comment">//先排序，连接好边就跑一边SPFA</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dis[n &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);<span class="comment">//最终汇点，即地板（2*n+1）离小球的最短距离即是答案</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后记：</p>
<p>记录此题的主要目的就是发现这个题的模型十分棒，从一个与图论毫不相关的东西转换到了图论，实在是妙不可言啊！</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>链式前向星</title>
    <url>/2020/07/05/%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F/</url>
    <content><![CDATA[<p>关于存图方式常用的有两种 <span id="more"></span></p>
<h3 id="第一种-邻接矩阵">第一种 邻接矩阵</h3>
<p>直接暴力存图</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> u, v, w;</span><br><span class="line">cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">a[u][v] = w;</span><br></pre></td></tr></table></figure>
<p>即意为在<span class="math inline">\(u\)</span>与<span
class="math inline">\(v\)</span>之间连上一条权值为<span
class="math inline">\(w\)</span>的边</p>
<p>也可以借助<span
class="math inline">\(vector\)</span>来存储，但是<span
class="math inline">\(vector\)</span>容易被卡，不建议用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;q[N];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">   <span class="type">int</span> u, v, w;</span><br><span class="line">   cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">   q[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<span class="math inline">\(u\)</span>节点的后面新开一个小空间
存<span class="math inline">\(v\)</span>，表示<span
class="math inline">\(u\)</span>，<span
class="math inline">\(v\)</span>之间有边</p>
<p>以上存无边权的，下面的<span
class="math inline">\(pair\)</span>类型的<span
class="math inline">\(vector\)</span>是存储有边权的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;pari&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt;q[N];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">   <span class="type">int</span> u, v, w;</span><br><span class="line">   cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">   q[u].<span class="built_in">push</span>(<span class="built_in">make_pair</span>(v, w));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第二种-邻接表">第二种 邻接表</h3>
<p>也就是 链式前向星</p>
<p>链式前向星的原理是通过某种合法又合理的操作，使得整个图联动起来</p>
<p>写链式前向星，一般都是以下格式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span> &#123;</span><br><span class="line">   <span class="type">int</span> frm, to, val, nxt;</span><br><span class="line">&#125;e[N];<span class="type">int</span> cnt, head[N];</span><br></pre></td></tr></table></figure>
<p>其中<span class="math inline">\(cnt\)</span>存边的编号，<span
class="math inline">\(head[x]\)</span>表示<span
class="math inline">\(x\)</span>这个节点最后一次加入的边的编号是多少(也可以理解为以<span
class="math inline">\(x\)</span>为起点最后一次加入的边的编号）</p>
<p>结构体中的<span class="math inline">\(e[i]\)</span>表示<span
class="math inline">\(i\)</span>这条边的各种信息</p>
<p><span class="math inline">\(e[i].frm\)</span> 表示<span
class="math inline">\(i\)</span>这条边的起点是哪里</p>
<p><span class="math inline">\(e[i].to\)</span>表示<span
class="math inline">\(i\)</span>这条边的终点是哪里</p>
<p><span class="math inline">\(e[i].val\)</span> 表示<span
class="math inline">\(i\)</span>这条边的权值是多少</p>
<p><span class="math inline">\(e[i].nx\)</span>t 表示与<span
class="math inline">\(i\)</span>这条边起点相同的上一条边的编号是多少</p>
<p>对于新加入的边，我们首先<span
class="math inline">\(cnt\)</span>(边的编号)要递加</p>
<p>其次我们对于这条边，更新他的各种信息:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span> <span class="params">(<span class="type">int</span> u, v, w)</span> </span>&#123;</span><br><span class="line">   e[++cnt].frm = u;</span><br><span class="line">   e[cnt].to = v;</span><br><span class="line">   e[cnt].val = w;</span><br><span class="line">   e[cnt].nxt = head[u];</span><br><span class="line">   head[u] = cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上边那个函数表示cnt这条边的起点是u，终点是v，权值是w</p>
<p>我们考虑如何来理解这个nxt与head数组</p>
<p>我们这条边的共起点的上一条边必定是我们这条边的起点最后一次加入的一条边（有点绕）</p>
<p>如下:</p>
<p>对于1 2 1这条边</p>
<p><span class="math inline">\(edge[1].to = 2;edge[1].nxt = 0;head[1] =
1;\)</span></p>
<p>对于2 3 2这条边</p>
<p><span class="math inline">\(edge[2].to = 3;edge[2].nxt = 0;head[2] =
2;\)</span></p>
<p>对于3 4 3这条边</p>
<p><span class="math inline">\(edge[3].to = 4;edge[3].nxt = 0;head[3] =
3;\)</span></p>
<p>对于1 3 4这条边</p>
<p><span class="math inline">\(edge[4].to = 3;edge[4].nxt = 1;head[1] =
4;\)</span></p>
<p>对于4 1 5这条边</p>
<p><span class="math inline">\(edge[5].to = 1;edge[5].nxt = 0;head[4] =
5;\)</span></p>
<p>对于1 5 6这条边</p>
<p><span class="math inline">\(edge[6].to = 5;edge[6].nxt = 4;head[1] =
6;\)</span></p>
<p>对于4 5 7这条边</p>
<p><span class="math inline">\(edge[7].to = 5;edge[7].nxt = 5;head[4] =
7;\)</span></p>
<p>所以我们的<span class="math inline">\(i\)</span>这条边的<span
class="math inline">\(nxt\)</span>（与<span
class="math inline">\(i\)</span>共起点的上一条边的编号）就是<span
class="math inline">\(head[x]\)</span> (<span
class="math inline">\(x\)</span>这条边最后一次加入的边的编号)(未更新前的)</p>
<p>当我们这条边信息更新完了之后，再去更新<span
class="math inline">\(head\)</span>数组</p>
<p>再次回想<span class="math inline">\(head\)</span>数组定义，以<span
class="math inline">\(x\)</span>为顶点最后一次加入的边，不就是当前这条边的编号吗</p>
<p>顾:</p>
<h2 id="section"><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">e[i].nxt = headx[x];</span><br><span class="line">head[x] = cnt;</span><br></pre></td></tr></table></figure></h2>
<p><span class="math inline">\(End..\)</span></p>
<hr />
<p>8.31 update:</p>
<p>现在常用数组版本：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> to[N &lt;&lt; <span class="number">1</span>], len[N &lt;&lt; <span class="number">1</span>], nex[N &lt;&lt; <span class="number">1</span>], head[N &lt;&lt; <span class="number">1</span>], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   to[++ cnt] = y;</span><br><span class="line">   len[cnt] = z;</span><br><span class="line">   nex[cnt]= head[x];</span><br><span class="line">   head[x] = cnt;</span><br><span class="line">   <span class="keyword">return</span>;<span class="comment">//随手打return是个好习惯</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学后感</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>随机</title>
    <url>/2020/10/07/%E9%9A%8F%E6%9C%BA/</url>
    <content><![CDATA[<p>题目大意：给定一个长度为 𝑛 的序列，你会在 [1,𝑛] 范围内随机两个正整数
𝑙, 𝑟 ，然后若有 𝑙 &gt; 𝑟 ，则交换 𝑙, 𝑟 。你想要知道区间 [𝑙, 𝑟]
内不同元素个数的期望。</p>
<span id="more"></span>
<p>暴力很好想 也很好写</p>
<p>但是<span
class="math inline">\(n^2\)</span>终究过不去，正解就是对暴力的优化</p>
<p>考虑枚举每一个i作为重点的贡献</p>
<p>或者说，以i为分界点，i之前的为L，i之后的一段为R，这都是i产生的贡献</p>
<p>至于为什么<span
class="math inline">\(nex[i]-i\)</span>但是不用加1？</p>
<p><strong>因为nex[i]数组表示的是i这个位置之后第一个再次出现i的位置</strong></p>
<p>如果加1的话，就会多算一个数字</p>
<p>又因为区间可以反过来再算一遍，所以要乘以2</p>
<p>减n是因为单个区间会被算重</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">s</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">w</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) w = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) s = s * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s * w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> pos[N], nex[N], a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, <span class="built_in">ret</span> (<span class="number">0</span>);</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) a[i] = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= N; ++ i) pos[i] = n + <span class="number">1</span>, nex[i] = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = n; i &gt;= <span class="number">1</span>; -- i)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">if</span> (pos[a[i]] == n + <span class="number">1</span>) pos[a[i]] = i;</span><br><span class="line">    <span class="keyword">else</span> nex[i] = pos[a[i]], pos[a[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) ret += i * (nex[i] - i);</span><br><span class="line"></span><br><span class="line">    ret = ret * <span class="number">2</span>; ret -= n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%.3lf&quot;</span>, <span class="number">1.0</span> / (n * n) * ret);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>思维题</tag>
      </tags>
  </entry>
  <entry>
    <title>魔数</title>
    <url>/2020/10/01/%E9%AD%94%E6%95%B0/</url>
    <content><![CDATA[<p>题目大意：小林和亮亮是好朋友。小林有一个幸运数字
a，亮亮有一个幸运数字 b。<span id="more"></span>一个数字称之为“幸运数”当且仅当它只由
a 和 b
组成。小林称一个数为“魔数”，当且仅当这个数各数位之和为“幸运数”，且这个数字本身也是“幸运数”。举个例子：小林的幸运数字为
2，亮亮的幸运数字为 6，那么 23 不是“幸运数”，而 26、222
是“幸运数”。进一步，222 是“魔数”（因为 2+2+2=6），而 26 不是“魔数”（因为
2+6=8）。亮亮想要知道，有多少个 n 位的“魔数”（一个 n 位数不包含前导
0），由于 这个数字会很大，所以亮亮只关心这个数模
1000000007（10^9+7，是一个质数）的结果。</p>
<p>数据范围：30%：n &lt;= 5；60%：n&lt;=100；100%；n&lt;=1e6</p>
<p>上来其实我也不会，以为是个数位dp准备写完暴力分就拍拍屁股走人</p>
<p>后来发现暴力分数太少，不值得。。。</p>
<p>就准备想正解，先打了个表</p>
<p>然后<strong>发现n位数，只会产生n+1个有效数字</strong></p>
<p><strong>每一个有效数字从小到大排列的话，会发现每一个有效数字出现的次数恰好就是<span
class="math inline">\(C_n^i\)</span></strong></p>
<p>然后就做完了</p>
<p>其实逆元的话，最好线性求，用费马小定理的话还要带着一个log</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">66</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">s</span><span class="params">(<span class="number">0</span>)</span>, <span class="title">w</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) w = <span class="number">-1</span>; ch = <span class="built_in">getchar</span>();&#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) s = s * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>, ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> s * w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">put</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (! x) <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">&#x27;-&#x27;</span>), x = -x;</span><br><span class="line">    <span class="function">ll <span class="title">num</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="type">char</span> c[<span class="number">66</span>];</span><br><span class="line">    <span class="keyword">while</span> (x) c[++ num] = x % <span class="number">10</span> + <span class="number">48</span>, x /= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (num) <span class="built_in">putchar</span>(c[num --]);</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>)(<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll res, fac[N], ifac[N], f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">ksm</span><span class="params">(ll a, ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * a % mod;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">C</span><span class="params">(ll n, ll m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fac[n] * ifac[m] % mod * ifac[n - m] % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pres_dou</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) fac[i] = fac[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">    ifac[n] = <span class="built_in">ksm</span>(fac[n], mod - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; -- i) ifac[i] = ifac[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// for (i = 0; i &lt;= n; ++ i) ifac[i] = ksm(fac[i], mod - 2);</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= n; ++ i) f[i] = <span class="built_in">C</span>(n, i);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, a, b, n;</span><br><span class="line">    a = <span class="built_in">read</span>(), b = <span class="built_in">read</span>(), n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">pres_dou</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pd = <span class="number">0</span>, cnt = <span class="number">0</span>, fuck = b * i + a * (n - i);</span><br><span class="line">        <span class="keyword">while</span> (fuck)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> w = fuck % <span class="number">10</span>;</span><br><span class="line">            fuck /= <span class="number">10</span>, ++ cnt;</span><br><span class="line">            <span class="keyword">if</span> (w == a || w == b) ++ pd;	</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pd == cnt) res = (res % mod + f[i] % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">put</span>(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>魔塔</title>
    <url>/2020/10/26/%E9%AD%94%E5%A1%94/</url>
    <content><![CDATA[<p>题目大意：把 问 题 再 抽 象 一 下 就 是 ， 勇 士 有 K 个 属 性 ， 大
小 分 别 为v[1],v[2],…,v[K]，一共有 N 只怪物，每只怪物也有相应的 K
个属性，第 i 只怪 物 的 第 j 项 属 性 标 记 为 <span
class="math inline">\(a[i][j]\)</span> 。 <span id="more"></span>若 对 于 任 意 的 j
（ 1≤j≤K ） 都 有a[i][j]≤v[j]，则勇士可以干掉第 i 只怪物，而且干掉第 i
只怪物后，勇士的各项属性都会得到提升，其中第 j 项属性的提升了
b[i][j]。现在小 Z
好奇，按照最优策略来打怪，最多能干掉多少只怪物（n属于1e5）</p>
<p>我不会贪心，我写的暴力，但是我A了</p>
<p>对于k等于1的情况，特判</p>
<p>对于k不等于1的情况，就直接搞，我常数小，就只是700ms就过了，其实可以把我卡成<span
class="math inline">\(o(n^2)\)</span>的</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">66</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, i, j, k, pd, res;</span><br><span class="line"><span class="type">int</span> me[<span class="number">7</span>], a[N][<span class="number">7</span>], b[N][<span class="number">7</span>], vis[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">yhzhyhm</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> f, g;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> yhzhyhm &amp;x) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> f &lt; x.f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;yh[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">yhm_clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(me, <span class="number">0</span>, <span class="keyword">sizeof</span> me);</span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span> a);</span><br><span class="line">    <span class="built_in">memset</span>(b, <span class="number">0</span>, <span class="keyword">sizeof</span> b);</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;yh, <span class="number">0</span>, <span class="keyword">sizeof</span> yh);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">yh_func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    me[<span class="number">1</span>] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i) yh[i].f = <span class="built_in">read</span>(), yh[i].g = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">sort</span>(yh + <span class="number">1</span>, yh + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (me[<span class="number">1</span>] &gt;= yh[i].f)</span><br><span class="line">        &#123;</span><br><span class="line">            me[<span class="number">1</span>] += yh[i].g;</span><br><span class="line">            ++ res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">put</span>(res), <span class="built_in">put</span>(me[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">yhm_func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), k = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> (<span class="type">void</span>)(<span class="built_in">yh_func</span>());</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= k; ++ i) me[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= k; ++ j) a[i][j] = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= k; ++ j) b[i][j] = <span class="built_in">read</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        pd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= k; ++ j) <span class="keyword">if</span> (me[j] &gt;= a[i][j]) ++ num;</span><br><span class="line">            <span class="keyword">if</span> (num == k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= k; ++ j) me[j] += b[i][j];</span><br><span class="line">                ++ res;</span><br><span class="line">                vis[i] = <span class="number">1</span>;</span><br><span class="line">                pd = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span> (pd == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">put</span>(res);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= k; ++ i) <span class="built_in">putf</span>(me[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> T = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (T --) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">yhm_clear</span>();</span><br><span class="line">        <span class="built_in">yhm_func</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>补：</p>
<p>正解， 此题有性质：k很小</p>
<p>所以我们可以开k个小根堆，分别把每一维都扔进去，现比较第一维，如果发现第一维合适，再比较第二维，以此类推</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; P;</span><br><span class="line">priority_queue&lt;P,vector&lt;P&gt;,greater&lt;P&gt; &gt;q[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N][<span class="number">5</span>],b[N][<span class="number">5</span>],v[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(T --)</span><br><span class="line">    &#123;</span><br><span class="line">        shuru;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++) <span class="keyword">while</span>(!q[i].<span class="built_in">empty</span>()) q[i].<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++) IO::<span class="built_in">read</span>(v[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++) IO::<span class="built_in">read</span>(a[i][j]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++) IO::<span class="built_in">read</span>(b[i][j]);</span><br><span class="line">            q[<span class="number">0</span>].<span class="built_in">push</span>(<span class="built_in">P</span>(a[i][<span class="number">0</span>],i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> p=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;m<span class="number">-1</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(!q[i].<span class="built_in">empty</span>() &amp;&amp; q[i].<span class="built_in">top</span>().first&lt;=v[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> x=q[i].<span class="built_in">top</span>().second; q[i].<span class="built_in">pop</span>();</span><br><span class="line">                    q[i+<span class="number">1</span>].<span class="built_in">push</span>(<span class="built_in">P</span>(a[x][i+<span class="number">1</span>],x));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!q[m<span class="number">-1</span>].<span class="built_in">empty</span>() &amp;&amp; q[m<span class="number">-1</span>].<span class="built_in">top</span>().first&lt;=v[m<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                <span class="type">int</span> x=q[m<span class="number">-1</span>].<span class="built_in">top</span>().second; q[m<span class="number">-1</span>].<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++) v[i]+=b[x][i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p==ans) <span class="keyword">break</span>;</span><br><span class="line">            p=ans;</span><br><span class="line">        &#125;</span><br><span class="line">        shuchu;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
</search>
